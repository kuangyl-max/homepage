<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kuangyl-max.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":5},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Linux学习 命令 scp 应用   screen wc 统计行数 du 查看占用空间 history 查看历史命令 rm dirname [ ！-n］和［！-d］ &amp;和wait并行 概述   sort 语法：sort(选项)(参数)   uniq 注意 split 语法   grep 关于2&gt;&amp;1的含义     Python学习 函数 sys.path.append">
<meta property="og:type" content="article">
<meta property="og:title" content="命令及工具">
<meta property="og:url" content="https://kuangyl-max.github.io/2020/12/19/learnNotes/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="Linux学习 命令 scp 应用   screen wc 统计行数 du 查看占用空间 history 查看历史命令 rm dirname [ ！-n］和［！-d］ &amp;和wait并行 概述   sort 语法：sort(选项)(参数)   uniq 注意 split 语法   grep 关于2&gt;&amp;1的含义     Python学习 函数 sys.path.append">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/2020/11/26/18-05-02-c75faa9d75cb4643d8657525e516d96b--Users-foo-Desktop-workspace-BayesGit-document-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-media-image1-407fd3.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/2020/11/26/18-08-06-71d9605f41d12dc20061272dffff4f98-workspace-BayesGit-document-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-media-image2-9bb1c9.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/18/10-38-25-9ed0f2c2e2292e28a824d57791052b73-20201218103825-d38026.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-29-30-52998d84f183f42a3527e52b3a07034c-20201217092929-8c62e8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-32-11-60c68d68ff6c4d21d31c5870883a5102-20201217093211-51046e.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-32-57-bc8010be0c642e2c43700273cdf74a91-20201217093257-f77065.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-33-29-621923843fa32b4724058a3b104407ce-20201217093329-d78398.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-03-03-19d8a54e9da736c90acaaebee8f688ca-image3-57d037.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-03-16-9f52dd0a72b02beba2956f86c969d28d-image4-1ef15b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-03-31-6f66d8b0fb4adb680790691bc38f933b-image5-d93179.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-02-44-c04e9d495ebf2d4668822b6e400c0db7-image6-ed0f28.png">
<meta property="og:image" content="https://kuangyl-max.github.io/2020/12/19/learnNotes/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/image7.png">
<meta property="og:image" content="https://kuangyl-max.github.io/2020/12/19/learnNotes/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/image8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-15-37-a6a2dd0f6867bb70fb069c41e1c86fec-image9-af7524.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-15-48-57b46febe52b66ef5fd10fb46d99857e-image10-9c1a34.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/image11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/15/15-05-37-003127015b900cbc3ed190db9d1a25ad-image-20201215150533726-0b14e6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-16-08-08a57b88fcc3dcd7c497a071cc0e4956-image12-748697.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-16-24-64cf0f76079732d9ff04aeabf154a99f-image13-dc5739.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/6bf091c95bf2b6c46d7bbaef31d04e44.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/b2ae3c19f68043d2182359e3dbb45ce7.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/be104797974d858ea0c3742be1735338.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/c3c63320b27026a63cae1bd69bb1918a.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/18567ee5d067de4a6300695527147702.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/6a75de955a7a79ab1a4aafbb44e50854.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/1c5b0740cf105cd1ebc446303939841f.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/17e17da591ba443cb4c20969dd77bc81.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/05105dfa7b24e44f746a22ac12a38ba5.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/ec547c09a9c45985da87f4e94e26f49d.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/2977ae3f86232a7a95c604e04247cb5d.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/797b572b521b401829704502f0ccef91.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/b6e9e82bb2db90826e8ab9e31970e2f8.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/01/b1e672abf7d0db1d84a15af9beadd67d.png">
<meta property="og:image" content="http://www.feiguyunai.com/wp-content/uploads/2020/03/dfe1be6e04c31daf54f24e7d16ca15c8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-17-19-cbcb88da5f3b55ab6a6bb41c1019e995-image15-1fbb47.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/05/18-05-51-79d11f189c72f852cb064dc6dc0668d8-image-20201205180543710-724945.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180715-2020-12-05-18-07-16.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180740-2020-12-05-18-07-40.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180754-2020-12-05-18-07-55.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180805-2020-12-05-18-08-06.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/13/09-43-36-1e86b868bb36524bef9ae76be9b53dd3-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RkZGQ2NjY2cXE=,size_16,color_FFFFFF,t_70-c7a109.png">
<meta property="og:image" content="https://pic1.zhimg.com/v2-fa1b0b20624cd7f8c31f2879e6c2820d_r.jpg?source=1940ef5c">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182720-2020-12-05-18-27-25.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182904-2020-12-05-18-29-14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183048-2020-12-05-18-30-50.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183149-2020-12-05-18-31-52.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-03-e0c1cd706c9becd959756c6b89e22b5f-image17-61c157.png">
<meta property="og:image" content="https://kuangyl-max.github.io/2020/12/19/learnNotes/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/image18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/19/14-11-24-7826e183aae6d0792ba5986fe94e25ef-image-20201219140957470-2e54dc.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-23-2e2011e3bb51a81ccbaa15e5a905487e-image19-b07eeb.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-44-729f65c734788aa782d054c4bded528d-image20-dee2cb.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-30-06-2012268feac886848fd1c027c8329c5d--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-f0ea7f.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-07-3140921b12cc7d9a949076b2bb80d637--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-ec896c.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-41-f6ddf40f921f9953b6f84d107a11f689--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-20201205153241447-d86c8b.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205155858-2020-12-05-15-58-59.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage22.png-2020-12-05-16-32-09.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image23-2020-12-05-16-34-27.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image24-2020-12-05-16-34-46.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image25-2020-12-05-16-35-01.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image26-2020-12-05-16-35-44.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage27.png-2020-12-05-16-49-50.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-24-7d7b962a0e07f5d49418c4268577902f-image28-614ef5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-49-1d7bb19fe4188d6de19a5120f330096e-image29-5332f5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-20-1deb9320af5a425d8e1e02ca5c9184e8-image30-40c5b0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-33-3d49d3ec358fcd726421df18e3439ff2-image31-e7bed9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-47-fc603198cc94a93c22b3c1a4cf86ae01-image32-05ae14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-55-db53e89c0d0421c1afd2dc1c9e257bec-image33-a0649c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-06-7192d4ded3c4a88a0a438d4c4ae50a64-image34-e57f36.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-16-7805d35ac338422bfca0392abf72374d-image35-79c71e.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-29-3787014405122b6bab510595d1f67c8f-image36-58d7e9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-46-907a7552e60ade951ac68fefd0ae0475-image37-5a4873.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-54-7861202049bf28c4e0b02a0e0cfb9646-image38-d2549a.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-01-5f3dd4037789e1471433f7b4c6471dd8-image39-3701ae.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-14-79701861ba33c16dd061af7ab8d9fdb2-image40-3604cf.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-27-8d95fbbaac75e564a6e381a823963be1-image41-b9f423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-34-f3588fbd8ff4cc8f57fd7b52145b133d-image42-d1b4a6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-45-0117a0f019fd2f1c5b58c3d84d94fa01-image43-0c7c1c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-52-5e1c6ec87cd49947634dde35b1dbca61-image44-25d6d0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-58-1f3bf58e1d2102553824b87ab13bbd30-image45-3c423b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-14-1867d75af9c5dc305130349b6adcbd8f-image46-2d79c2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-06-ca6d1ccb0acf2b7980d2193ccd72ddc7-image47-6c2615.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-06-b5ddd5f3cf54db08d07746d951b5039f-image48-9450fb.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-44-83545c1a9844f53a24e53f3b2bca1aa6-image49-eea995.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-20-53-4c5865f227274bbf92353bbd22b50d65-image50-2cb8e9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-23-f398f7bb150853bc40db13154a57314a-image51-93b6f3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-30-80bdcc06dbf6463f2baf0a7387760fb5-image52-dea17a.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-37-aebe80c876b2d1692544da5a0b26cf4c-image53-1fecda.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-36-41-62de41087818c40969de93e5b28b34c1-image54-ed2cca.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-38-45-69d072a8079102da338071daa6fa4c10-image55-d2410c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-41-23-7f4e8338e960623aa43e3d6d484a0b70-image56-912ad6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-43-36-30ae050b2c58b91225b65b8f0be254f0-image57-1b4ae6.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPx9FqYNKfgUian0EKdca922a8cuU9ias8ArtftZibX3mWQU522F3eaCr2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPOVPLf0eWZkV4LFvwKNf8yw0H5z5E5PSCm4oIZPtFy2ut6JXRw7tVeQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPHic5bC1371koNCsDUTibdjDGQCYRqPYoXCp9bIbI5ZDkYqTRL2P6WIuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPNm3BUIjzbIHHdDOYTh4zn8g5ANnghchS3ZN2aITCLfyicknBaCjw5Cw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-17-7ef69757a13bfe2536d6f65b32bf84f8-640-20201214180517107-b444a2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-21-3d206f4a4f74e4e797681f8293543bd2-640-20201214180521647-e4d94b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-26-165843d8f8591097a8d21c14081cd3a7-640-20201214180526352-592182.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-29-0dcf8375faf69beafc18f80d85e9279e-640-20201214180529295-0fa918.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-38-e8ce65f0cf8b05be3f041e7a1e9ba33b-640-20201214180538497-36cea5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/14/18-13-25-d5dcfa68b40d86c2dcce8e2a53634e72-image-20201214181320489-597f03.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/14/18-13-52-d457231776eadea559ff54df9817e238-image-20201214181350669-0117c6.png">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-40-076866c9e6006d8a200e132ab0667394-640-20201214181540882-1b0e90.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-44-79bf2e53e6a6fc82cb6645b3ee455b85-640-20201214181544517-9b8012.png">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-27-a5759803b903116dc0de724780a01cec-640-20201214181527890-3e2947.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-23-4652ece19222eb0b9e1ec6bb3caad7f8-640-20201214181523340-5c5f18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-16-21916b94f2e0fb561a501b60b239e291-640-20201214181516539-0807b2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-12-6af618885fe831714e7fb3bba923d7f4-640-20201214181512139-afb9fe.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-16-12-1eb6119b8512ac69ac870d987948018c-640-20201214181612487-606ae1.png">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-16-19-df0402440bafe66c5d211906718d0133-640-20201214181619169-120505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-46-55-050d1acb38f4212d33bb1ffc4e707801-image58-59716b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/08/11-19-59-4e26d867f4adf689a4423f28e1b23f5e-image-20201208111950637-f55c89.png">
<meta property="article:published_time" content="2020-12-19T04:57:15.668Z">
<meta property="article:modified_time" content="2020-12-19T06:14:29.057Z">
<meta property="article:author" content="小邝">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/2020/11/26/18-05-02-c75faa9d75cb4643d8657525e516d96b--Users-foo-Desktop-workspace-BayesGit-document-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-media-image1-407fd3.jpeg">

<link rel="canonical" href="https://kuangyl-max.github.io/2020/12/19/learnNotes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>命令及工具 | 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband">
<a target="_blank" rel="noopener" href="https://github.com/kuangyl-max" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kuangyl-max.github.io/2020/12/19/learnNotes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="小邝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          命令及工具
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-19 12:57:15 / 修改时间：14:14:29" itemprop="dateCreated datePublished" datetime="2020-12-19T12:57:15+08:00">2020-12-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%9E%E4%B9%A0%E6%96%87%E6%A1%A3/" itemprop="url" rel="index"><span itemprop="name">实习文档</span></a>
                </span>
            </span>

          
            <span id="/2020/12/19/learnNotes/" class="post-meta-item leancloud_visitors" data-flag-title="命令及工具" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
	<span>℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/19/learnNotes/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/19/learnNotes/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- TOC -->

<ul>
<li><a href="#linux%E5%AD%A6%E4%B9%A0">Linux学习</a><ul>
<li><a href="#%E5%91%BD%E4%BB%A4">命令</a><ul>
<li><a href="#scp">scp</a><ul>
<li><a href="#%E5%BA%94%E7%94%A8">应用</a></li>
</ul>
</li>
<li><a href="#screen">screen</a></li>
<li><a href="#wc-%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0">wc 统计行数</a></li>
<li><a href="#du-%E6%9F%A5%E7%9C%8B%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4">du 查看占用空间</a></li>
<li><a href="#history-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4">history 查看历史命令</a></li>
<li><a href="#rm">rm</a></li>
<li><a href="#dirname">dirname</a></li>
<li>[<a href="#--n%E5%92%8C-d"> ！-n］和［！-d］</a></li>
<li><a href="#%E5%92%8Cwait%E5%B9%B6%E8%A1%8C">&amp;和wait并行</a><ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
</ul>
</li>
<li><a href="#sort">sort</a><ul>
<li><a href="#%E8%AF%AD%E6%B3%95sort%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0">语法：sort(选项)(参数)</a></li>
</ul>
</li>
<li><a href="#uniq-%E6%B3%A8%E6%84%8F">uniq 注意</a></li>
<li><a href="#split">split</a><ul>
<li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li>
</ul>
</li>
<li><a href="#grep">grep</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E21%E7%9A%84%E5%90%AB%E4%B9%89">关于2&gt;&amp;1的含义</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#python%E5%AD%A6%E4%B9%A0">Python学习</a><ul>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a><ul>
<li><a href="#syspathappend%E7%94%A8%E6%B3%95">sys.path.append()用法</a></li>
<li><a href="#sysstdoutsysstdin">sys.stdout、sys.stdin</a></li>
</ul>
</li>
<li><a href="#%E7%BB%8F%E9%AA%8C">经验</a><ul>
<li><a href="#python%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">Python执行路径问题</a></li>
<li><a href="#urllib%E6%A8%A1%E5%9D%97%E7%9A%84urlopen%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E4%BE%8B">urllib模块的urlopen()的使用方法及实例</a></li>
<li><a href="#%E5%88%86%E5%9D%97%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">分块读取文件</a></li>
<li><a href="#logging">logging</a></li>
<li><a href="#python%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%92%8C%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0">python－读取文件和计算文件行数</a></li>
<li><a href="#groupby">Groupby</a></li>
<li><a href="#druid">Druid</a></li>
<li><a href="#olap%E4%B9%8Bdruid%E4%B9%8B%E6%9F%A5%E8%AF%A2">OLAP之Druid之查询</a><ul>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
<li><a href="#topn">TopN</a></li>
</ul>
</li>
<li><a href="#mmap%E6%A8%A1%E5%9D%97">mmap模块</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a></li>
<li><a href="#pandas-read_csv">Pandas-read_csv</a><ul>
<li><a href="#read_csv%E5%87%BD%E6%95%B0">read_csv函数</a></li>
</ul>
</li>
<li><a href="#pycallgraph-%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">pycallgraph 生成流程图(函数调用）</a></li>
<li><a href="#autocode-python-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE">AutoCode-Python 绘制流程图</a></li>
<li><a href="#crystal-flow">Crystal FLOW</a></li>
<li><a href="#%E5%87%A0%E6%AC%BE%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%BD%AF%E4%BB%B6">几款代码转流程图软件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#git">Git</a><ul>
<li><a href="#git%E5%91%BD%E4%BB%A4%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AD%A6%E4%B9%A0">git命令交互式学习</a></li>
<li><a href="#git-ssh-%E9%85%8D%E7%BD%AE">Git ssh 配置：</a></li>
<li><a href="#%E7%96%91%E9%9A%BE">疑难</a><ul>
<li><a href="#github%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E8%B6%85%E8%BF%87100m%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6">Github如何上传超过100M的大文件</a></li>
<li><a href="#git-lfs%E7%9A%84%E4%BD%BF%E7%94%A8">git lfs的使用</a><ul>
<li><a href="#1%E4%BB%80%E4%B9%88%E6%98%AFgit-lfs">1.什么是git lfs</a></li>
<li><a href="#2%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88">2.优点是什么</a></li>
<li><a href="#3%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85">3.怎么安装</a></li>
<li><a href="#4%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8">4.怎么使用</a></li>
</ul>
</li>
<li><a href="#git-add%E8%AF%A6%E8%A7%A3">git add详解</a></li>
<li><a href="#git%E7%A7%BB%E9%99%A4%E5%B7%B2%E7%BB%8Fadd%E7%9A%84%E6%96%87%E4%BB%B6">git移除已经add的文件</a></li>
<li><a href="#%E6%8F%90%E4%BA%A4%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6">提交忽略某些文件</a><ul>
<li><a href="#1%E8%AE%BE%E7%BD%AEgitignore">1.设置.gitignore</a></li>
<li><a href="#2%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4">2.使用命令</a></li>
<li><a href="#3%E4%BD%BF%E7%94%A8gitinfoexclude">3.使用.git/info/exclude</a></li>
</ul>
</li>
<li><a href="#git-clean%E6%B8%85%E9%99%A4%E6%9C%AA%E8%B7%9F%E8%B8%AA%E7%9A%84%E6%96%87%E4%BB%B6">git clean清除未跟踪的文件</a></li>
<li><a href="#git%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9Acommit">git删除指定commit</a></li>
<li><a href="#git%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9Acommit-%E7%BB%AD">git删除指定commit-续</a></li>
<li><a href="#git-rebase-vs-git-revert">git rebase Vs git revert</a></li>
<li><a href="#git-commit%E5%92%8Cgit-push%E7%9A%84%E5%8C%BA%E5%88%AB">git commit和git push的区别</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AFbranch%E5%92%8C%E4%BD%BF%E7%94%A8pull-request">创建分支branch和使用Pull request</a></li>
<li><a href="#github-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%B9%B6%E4%B8%94%E6%9D%83%E9%99%90%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86">GitHub 实现多人协同提交代码并且权限分组管理</a></li>
<li><a href="#git%E5%A4%9A%E5%88%86%E6%94%AF%E5%B9%B3%E8%A1%8C%E5%8F%91%E5%B1%95%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E9%A1%B9%E7%9B%AE">Git多分支平行发展（一个仓库包含多个不同的项目）</a></li>
<li><a href="#git%E4%B8%ADsubmodule%E7%9A%84%E4%BD%BF%E7%94%A8">Git中submodule的使用</a></li>
<li><a href="#git-clone%E7%A7%BB%E5%8A%A8%E6%9C%AC%E5%9C%B0%E5%8E%82%E5%BA%93">git clone移动本地厂库</a></li>
<li><a href="#git-pull%E5%92%8Cgit-fetch%E7%9A%84%E5%8C%BA%E5%88%AB">git pull和git fetch的区别</a></li>
<li><a href="#fatal-does-not-appear-to-a-git-repository">fatal: does not appear to a git repository</a></li>
<li><a href="#git-fork%E4%B8%8Eclone%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">git fork与clone有什么区别及使用场景</a><ul>
<li><a href="#git-clone">git clone</a></li>
<li><a href="#git-fork">git fork</a></li>
</ul>
</li>
<li><a href="#git-%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF-git-push-origin">git 推送本地分支到远程分支 git push origin</a></li>
<li><a href="#git-remote%E5%85%B3%E8%81%94%E4%BA%86%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E4%BB%93%E5%BA%93">git remote关联了两个或多个仓库</a></li>
<li><a href="#git-add%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6">git add外部文件</a></li>
<li><a href="#git-add-%E6%96%87%E4%BB%B6">git add 文件</a></li>
<li><a href="#git-commit-%E6%8F%90%E4%BA%A4%E5%88%B0%E7%89%88%E6%9C%AC%E5%BA%93">git commit 提交到版本库</a></li>
</ul>
</li>
<li><a href="#git-%E5%BB%96%E9%9B%AA%E5%B3%B0%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3">git 廖雪峰学习文档</a><ul>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA">工作区和暂存区</a><ul>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8C%BAworking-directory">工作区（Working Directory）</a></li>
<li><a href="#%E7%89%88%E6%9C%AC%E5%BA%93repository">版本库（Repository）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%80git%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E9%85%8D%E7%BD%AE">一、git初始化本地仓库和配置</a></li>
<li><a href="#%E4%BA%8C%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6">二、提交文件</a></li>
<li><a href="#%E4%B8%89%E5%9B%9E%E9%80%80">三、回退</a><ul>
<li><a href="#1%E6%9F%A5%E7%9C%8Bcommit%E4%BF%A1%E6%81%AF%E5%92%8C%E5%91%BD%E4%BB%A4%E4%BF%A1%E6%81%AF">1.查看commit信息和命令信息</a></li>
<li><a href="#2%E5%9B%9E%E9%80%80">2.回退</a></li>
<li><a href="#3head%E4%BB%8B%E7%BB%8D">3.HEAD介绍</a></li>
<li><a href="#4%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8Blog">4.查看远程log</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E5%88%87%E6%8D%A2%E6%9A%82%E5%AD%98%E5%8C%BA%E5%B7%A5%E4%BD%9C%E5%8C%BA">四、切换暂存区、工作区</a></li>
<li><a href="#%E4%BA%94%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6">五、删除文件</a><ul>
<li><a href="#1%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6">1.删除本地文件</a></li>
<li><a href="#2%E8%AF%AF%E5%88%A0">2，误删</a></li>
<li><a href="#3%E5%88%A0%E9%99%A4%E8%BF%9C%E7%AB%AF%E6%96%87">3.删除远端文</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">六、本地分支和远程分支</a><ul>
<li><a href="#1%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%B8%A6%E6%98%9F%E5%8F%B7%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%93%E5%89%8D%E6%89%80%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">1.查看本地分支，带星号的表示当前所在本地分支</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">2.创建本地分支</a></li>
<li><a href="#3%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">3.创建远程分支</a></li>
<li><a href="#4%E5%90%88%E5%B9%B6%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">4.合并本地分支</a></li>
<li><a href="#5origin">5.origin</a></li>
<li><a href="#6git-fetch-%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93">6.git fetch 更新远程代码到本地仓库</a></li>
<li><a href="#7fetch%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">7.fetch更新本地仓库两种方式</a></li>
<li><a href="#8%E5%90%88%E5%B9%B6%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">8.合并远程分支</a></li>
<li><a href="#9%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">9.删除本地分支</a></li>
<li><a href="#10%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">10.删除远程分支</a></li>
<li><a href="#11%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%96%B0%E5%88%86%E6%94%AF%E5%B9%B6%E5%B0%86%E6%96%B0%E5%88%86%E6%94%AF%E5%92%8C%E8%BF%9C%E7%A8%8B%E6%9F%90%E4%B8%AA%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3%E8%81%94">11.创建本地新分支并将新分支和远程某个分支相关联</a></li>
<li><a href="#12%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF">12.修改commit信息</a></li>
<li><a href="#13%E5%88%A0%E9%99%A4commit%E4%BF%A1%E6%81%AF">13.删除commit信息</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5">七、分支策略</a></li>
<li><a href="#%E5%85%ABbug%E5%88%86%E6%94%AF%E5%92%8C%E6%9A%82%E5%AD%98%E5%B7%A5%E4%BD%9C%E7%8E%B0%E5%9C%BA">八、bug分支和暂存工作现场</a><ul>
<li><a href="#1bug%E5%88%86%E6%94%AF%E7%9A%84%E7%94%A8%E9%80%94">1.bug分支的用途</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BAbug%E5%88%86%E6%94%AF%E7%9A%84%E6%B5%81%E7%A8%8B">2.创建bug分支的流程</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9Dfeature%E5%88%86%E6%94%AF">九、feature分支</a></li>
<li><a href="#%E5%8D%81github%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">十、github远程仓库</a><ul>
<li><a href="#1%E4%BD%BF%E7%94%A8ssh%E5%88%9B%E5%BB%BAkey">1.使用ssh创建key</a></li>
<li><a href="#2%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94">2.本地仓库和远程仓库关联</a></li>
<li><a href="#3%E5%85%B3%E8%81%94%E4%BB%93%E5%BA%93%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">3.关联仓库出现问题解决办法</a></li>
<li><a href="#4%E6%9C%89%E6%97%B6%E5%80%99%E4%B8%8D%E6%83%B3%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E5%BB%BA%E8%AE%AE%E8%BF%98%E6%98%AF%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E5%A5%BD">4.有时候不想解决冲突(建议还是解决冲突好）</a></li>
<li><a href="#5%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF">5.删除分支</a></li>
<li><a href="#6%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">6.创建远程分支</a></li>
<li><a href="#7%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AFcommit%E4%BF%A1%E6%81%AF%E7%94%A8%E4%BA%8E%E5%9B%9E%E9%80%80%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC">7.查看远程分支commit信息用于回退到远程分支的某个版本</a></li>
<li><a href="#8%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%90%8D%E7%A7%B0">8.修改远程仓库名称</a></li>
<li><a href="#9-fork%E5%88%AB%E4%BA%BA%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8E%E5%A6%82%E4%BD%95%E5%90%8C%E5%8E%9F%E4%BB%93%E5%BA%93%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0">9. fork别人的仓库后如何同原仓库保持同步更新</a></li>
<li><a href="#10-git-pull-cant-update">10. git pull can’t update</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%80%E5%A4%9A%E4%BA%BA%E5%90%88%E4%BD%9C%E6%B5%81%E7%A8%8B">十一、多人合作流程</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C%E7%89%88%E6%9C%AC%E6%A0%87%E7%AD%BE">十二、版本标签</a></li>
<li><a href="#%E5%8D%81%E4%B8%89%E5%BF%BD%E7%95%A5%E7%89%B9%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6">十三，忽略特特殊文件</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B%E8%87%AA%E5%AE%9A%E4%B9%89git%E6%9C%8D%E5%8A%A1%E5%99%A8">十四、自定义Git服务器</a></li>
<li><a href="#%E5%8D%81%E4%BA%94git%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">十五、git常见错误及解决办法</a></li>
</ul>
</li>
<li><a href="#window-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE">Window 终端配置</a><ul>
<li><a href="#scoop%E9%85%8D%E7%BD%AE">Scoop配置</a><ul>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
</ul>
</li>
<li><a href="#%E6%88%96">或</a><ul>
<li><a href="#%E5%B0%86scoop%E5%AE%89%E8%A3%85%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F">将Scoop安装到自定义目录(命令行方式)</a></li>
<li><a href="#%E5%B0%86scoop%E9%85%8D%E7%BD%AE%E4%B8%BA%E5%B0%86%E5%85%A8%E5%B1%80%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E5%BD%95-scoop_global%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F">将Scoop配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)</a></li>
<li><a href="#%E4%B8%8A%E9%9D%A2%E4%B8%A4%E5%8F%A5%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">上面两句运行的结果(环境变量)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mapreduce">MapReduce</a><ul>
<li><a href="#mapreduce%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">MapReduce工作流程</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a><ul>
<li><a href="#%E5%AE%89%E8%A3%85-1">安装</a></li>
<li><a href="#on-duplicate-key-update">on duplicate key update</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">数据库查询优化</a><ul>
<li><a href="#11%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95">1.1使用索引</a></li>
<li><a href="#12%E4%BC%98%E5%8C%96sql%E8%AF%AD%E5%8F%A5">1.2优化SQL语句</a></li>
<li><a href="#13-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1">1.3 优化数据库对象</a></li>
</ul>
</li>
<li><a href="#redis">Redis</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95">算法</a><ul>
<li><a href="#%E5%A4%96%E6%8E%92%E5%BA%8F">外排序</a></li>
</ul>
</li>
<li><a href="#hexo">Hexo</a><ul>
<li><a href="#brew-%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99">Brew 安装报错</a></li>
<li><a href="#%E5%88%A9%E7%94%A8hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0github-pages%E5%8D%9A%E5%AE%A2">利用Hexo在多台电脑上提交和更新github pages博客</a></li>
<li><a href="#%E5%86%99%E6%96%87%E7%AB%A0">写文章</a></li>
</ul>
</li>
<li><a href="#markdown%E6%8F%92%E4%BB%B6">Markdown插件</a><ul>
<li><a href="#%E4%B8%80%E9%94%AE%E5%B0%86-word-%E8%BD%AC%E6%8D%A2%E4%B8%BA-markdown">一键将 Word 转换为 Markdown</a><ul>
<li><a href="#%E6%96%B9%E6%B3%95%E4%B8%80writage--pandoc----%E5%8F%8C%E5%89%91%E5%90%88%E7%92%A7">方法一：Writage + Pandoc – 双剑合璧！</a><ul>
<li><a href="#%E6%9B%B4%E5%8A%A0%E5%BF%AB%E6%8D%B7%E6%9C%89%E6%97%B6%E7%95%A5%E5%9D%91%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%8Cword-to-markdown-converter%E5%9C%A8%E7%BA%BF%E8%BD%AC%E6%8D%A2%E7%BD%91%E9%A1%B5">更加快捷（有时略坑）的方法二：Word to Markdown Converter在线转换网页！</a></li>
<li><a href="#%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8">图片的下载与存储</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9C%A8%E7%BA%BF%E7%89%88word2markdown">在线版word2markdown</a></li>
<li><a href="#ulysses-mac%E6%94%AF%E6%8C%81-%E7%BA%AF%E6%96%87%E6%9C%AC-markdown2word-%E4%BD%86%E4%BB%98%E8%B4%B9">Ulysses mac支持 纯文本 Markdown2Word ，但付费</a></li>
<li><a href="#%E6%96%B9%E6%B3%951-markdown-image">方法1 markdown-image</a></li>
<li><a href="#%E6%96%B9%E6%B3%952-pandoc">方法2 pandoc</a></li>
<li><a href="#%E6%96%B9%E6%B3%953">方法3</a></li>
<li><a href="#%E6%96%B9%E6%B3%954-picgogithub-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87">方法4 picGo+GitHub 上传图片</a></li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%8F%91%E5%85%BB%E6%88%90">开发养成</a></li>
<li><a href="#%E8%AE%BA%E6%96%87%E5%B7%A5%E5%85%B7">论文工具</a></li>
<li><a href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">机器学习</a><ul>
<li><a href="#%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99">课程&amp;资料</a></li>
</ul>
</li>
<li><a href="#c%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%85%A8%E5%A5%97c%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%B7%B2%E6%9B%B4%E6%96%B0%E5%AE%8C%E6%AF%95">C++入门教程，全套C++基础教程（已更新完毕）</a></li>
</ul>
<!-- /TOC -->
<h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>&nbsp;&nbsp;从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3</span><br><span class="line"></span><br><span class="line">scp -r www.runoob.com:/home/root/others/ /home/space/music/ <span class="comment">#-r上传文件夹</span></span><br></pre></td></tr></table></figure>
<p>原文链接如下</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/?s=scp">https://www.runoob.com/?s=scp</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-scp.html">https://www.runoob.com/linux/linux-comm-scp.html</a></li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#远程下载到本地</span></span><br><span class="line">scp hostname@150.136.15.14:/home/data.csv</span><br><span class="line">/Users/foo/Desktop/workspace/work/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地上传到远程</span></span><br><span class="line">scp /Users/foo/Desktop/workspace/work/data.csv</span><br><span class="line">hostname@150.136.15.14:/home/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="scp在命令行中带密码远程下载文件"><a href="#scp在命令行中带密码远程下载文件" class="headerlink" title="scp在命令行中带密码远程下载文件"></a>scp在命令行中带密码远程下载文件</h4><ol>
<li><strong>sshpass安装</strong></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013015301/article/details/89468461">https://blog.csdn.net/u013015301/article/details/89468461</a></p>
<ol start="2">
<li>** scp 在脚本中使用输入密码的解决方法**</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/farces/blog/326860">https://my.oschina.net/farces/blog/326860</a></p>
<h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><ol>
<li>创建一个新的窗口</li>
</ol>
<p>安装完成后，直接敲命令screen就可以启动它。但是这样启动的screen会话没有名字，实践上推荐为每个screen会话取一个名字，方便分辨：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S david</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入screen</li>
</ol>
<p>&nbsp;&nbsp;screen启动后，会创建第一个窗口，并在其中打开一个系统默认的shell，一般都会是bash。所以你敲入命令screen之后，会立刻又返回到命令提示符，仿佛什么也没有发生似的，其实你已经进入Screen的世界了。当然，也可以在screen命令之后加入你喜欢的参数，使之直接打开你指定的程序，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen vi david.txt</span><br></pre></td></tr></table></figure>
<p>screen创建一个执行vi david.txt的单窗口会话，退出vi 将退出该窗口/会话。</p>
<ol start="3">
<li>查看窗口和窗口名称</li>
</ol>
<p>打开多个窗口后，可以使用快捷键C-a w列出当前所有窗口。<br>如果使用文本终端，这个列表会列在屏幕左下角，如果使用X环境下的终端模拟器，这个列表会列在标题栏里。窗口列表的样子一般是这样：</p>
<p>0$ bash 1-$ bash 2*$ bash</p>
<p>这个例子中我开启了三个窗口，其中*号表示当前位于窗口2，-号表示上一次切换窗口时位于窗口1。</p>
<hr/>
screen默认会为窗口命名为编号和窗口中运行程序名的组合，上面的例子中窗口都是默认名字。练习了上面查看窗口的方法，你可能就希望各个窗口可以有不同的名字以方便区分了。可以使用快捷键C-A来为当前窗口重命名，按下快捷键后，screen会允许你为当前窗口输入新的名字，回车确认。

<ol start="4">
<li>会话分离与恢复</li>
</ol>
<p>你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个screen窗口编辑/tmp/david.txt文件：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen vi /tmp/david.txt</span><br></pre></td></tr></table></figure>
<p>之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入C-a d，screen会给出detached提示：</p>
<ol start="5">
<li>暂时中断会话</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/2020/11/26/18-05-02-c75faa9d75cb4643d8657525e516d96b--Users-foo-Desktop-workspace-BayesGit-document-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-media-image1-407fd3.jpeg" alt="IMG_256">{width=”9.375in”<br>height=”4.260416666666667in”}</p>
<p>半个小时之后回来了，找到该screen会话：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen <span class="literal">-ls</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/2020/11/26/18-08-06-71d9605f41d12dc20061272dffff4f98-workspace-BayesGit-document-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-media-image2-9bb1c9.jpeg" alt="IMG_257">{width=”7.291666666666667in”<br>height=”0.9479166666666666in”}</p>
<ol start="6">
<li>重新连接会话：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen <span class="literal">-r</span> <span class="number">12865</span></span><br></pre></td></tr></table></figure>
<h4 id="常用screen命令"><a href="#常用screen命令" class="headerlink" title="常用screen命令"></a>常用screen命令</h4></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">screen -S yourname           # 新建一个叫yourname的session</span><br><span class="line">screen -ls                   # 列出当前所有的session</span><br><span class="line">screen -r yourname           # 回到yourname这个session</span><br><span class="line">screen -d yourname           # 远程detach某个session    # detach快捷键 ctrl a + d</span><br><span class="line">screen -d -r yourname        # 结束当前session并回到yourname这个session</span><br><span class="line">screen -S yourname -X quit   # 删除叫yourname的session</span><br></pre></td></tr></table></figure>

<p><strong>重名的怎么删，如下图：</strong></p>
<ol>
<li>没有重名的直接可以<code>screen -S session_name -X quit</code></li>
<li>重名的，需要带上id删，<code>screen -S id.session_name -X quit</code></li>
</ol>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangliheng/p/6173530.html">https://www.cnblogs.com/yangliheng/p/6173530.html</a><h3 id="wc-统计行数"><a href="#wc-统计行数" class="headerlink" title="wc 统计行数"></a>wc 统计行数</h3></li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wc <span class="literal">-l</span> test1.sh</span><br><span class="line"></span><br><span class="line">lines =`wc <span class="literal">-l</span> <span class="variable">$</span>&#123;bid_origin_file&#125; | awk <span class="operator">-F</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br></pre></td></tr></table></figure>
<h3 id="crontab定时任务"><a href="#crontab定时任务" class="headerlink" title="crontab定时任务"></a>crontab定时任务</h3><p>crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<p>Linux下的任务调度分为两类，系统任务调度和用户任务调度。</p>
<p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p>
<p>/etc/crontab文件包括下面几行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/crontab</span><br><span class="line"></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"></span><br><span class="line">MAILTO=HOME=/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> run-parts</span></span><br><span class="line"></span><br><span class="line">51 * * * * root run-parts /etc/cron.hourly</span><br><span class="line"></span><br><span class="line">24 7 * * * root run-parts /etc/cron.daily</span><br><span class="line"></span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly</span><br><span class="line"></span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly</span><br></pre></td></tr></table></figure>


<p>前四行是用来配置crond任务运行的环境变量</p>
<ul>
<li>第一行SHELL变量指定了系统要使用哪个shell，这里是bash，</li>
<li>第二行PATH变量指定了系统执行命令的路径，</li>
<li>第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户，</li>
<li>第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。</li>
</ul>
<p><strong>用户任务调度</strong>：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p>
<p>使用者权限文件：</p>
<ul>
<li><p>/etc/cron.deny</p>
<p>说明：该文件中所列用户不允许使用crontab命令</p>
</li>
<li><p>/etc/cron.allow</p>
<p>该文件中所列用户允许使用crontab命令</p>
</li>
<li><p>/var/spool/cron/</p>
<p>所有用户crontab文件存放的目录,以用户名命名</p>
</li>
</ul>
<p><strong>crontab文件的含义：</strong></p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute hour day month week command</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>minute： 表示分钟，可以是从0到59之间的任何整数。</p>
<p>hour：表示小时，可以是从0到23之间的任何整数。</p>
<p>day：表示日期，可以是从1到31之间的任何整数。</p>
<p>month：表示月份，可以是从1到12之间的任何整数。</p>
<p>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</p>
<p>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/18/10-38-25-9ed0f2c2e2292e28a824d57791052b73-20201218103825-d38026.png" alt="fix-dir/picgo/2020/12/18/10-38-25-9ed0f2c2e2292e28a824d57791052b73-20201218103825-d38026"></p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/intval/p/5763929.html">https://www.cnblogs.com/intval/p/5763929.html</a></p>
<h3 id="crontab命令"><a href="#crontab命令" class="headerlink" title="crontab命令"></a>crontab命令</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ftl1012/p/crontab.html">https://www.cnblogs.com/ftl1012/p/crontab.html</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usage: crontab [-u user] file</span><br><span class="line">    crontab [-u user] [ -e | -l | -r ]</span><br><span class="line">        (default operation is replace, per 1003.2)</span><br><span class="line">    -e   (edit user&#x27;s ``crontab``)</span><br><span class="line">    -l   (list user&#x27;s ``crontab``)</span><br><span class="line">    -r   (delete user&#x27;s ``crontab``)</span><br><span class="line">    -i   (prompt before deleting user&#x27;s ``crontab``)</span><br><span class="line">    -s   (selinux context)</span><br></pre></td></tr></table></figure>

<h3 id="du-查看占用空间"><a href="#du-查看占用空间" class="headerlink" title="du 查看占用空间"></a>du 查看占用空间</h3><p>常用命令举例：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看某个目录下哪个文件最大\</span></span><br><span class="line">du <span class="literal">-sh</span> \*\|grep G\</span><br><span class="line"><span class="comment">#查看某个目录下文件的大小\</span></span><br><span class="line">du <span class="literal">-ha</span> xxx.csv\</span><br><span class="line"><span class="comment">#查看某个目录下所有文件的大小\</span></span><br><span class="line">du <span class="literal">-ha</span>\</span><br><span class="line"><span class="comment">#查看所有目录使用空间\</span></span><br><span class="line">df <span class="literal">-h</span></span><br><span class="line"><span class="comment">#查看linux目录剩余空间大小\</span></span><br><span class="line"><span class="comment">#df命令是linux系统以磁盘分区为单位查看文件系统，可以加上参数查看磁盘剩余空间信息，命令格式：\</span></span><br><span class="line">df <span class="literal">-hl</span></span><br></pre></td></tr></table></figure>
<p>详细参数：</p>
<p>du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X<br>&lt;文件&gt;][--block-size][--exclude=&lt;目录或文件&gt;][--max-depth=&lt;目录层数&gt;][--help][--version][目录或文件]</p>
<p>参数说明：</p>
<ul>
<li>-a或-all 显示目录中个别文件的大小。</li>
<li>-b或-bytes 显示目录或文件大小时，以byte为单位。</li>
<li>-c或--total<br>除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</li>
<li>-D或--dereference-args 显示指定符号连接的源文件大小。</li>
<li>-h或--human-readable 以K，M，G为单位，提高信息的可读性。</li>
<li>-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。</li>
<li>-k或--kilobytes 以1024 bytes为单位。</li>
<li>-l或--count-links 重复计算硬件连接的文件。</li>
<li>-L&lt;符号连接&gt;或--dereference&lt;符号连接&gt;<br>显示选项中所指定符号连接的源文件大小。</li>
<li>-m或--megabytes 以1MB为单位。</li>
<li>-s或--summarize 仅显示总计。</li>
<li>-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</li>
<li>-x或--one-file-xystem<br>以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</li>
<li>-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。</li>
<li>--exclude=&lt;目录或文件&gt; 略过指定的目录或文件。</li>
<li>--max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。</li>
<li>--help 显示帮助。</li>
<li>--version 显示版本信息。</li>
</ul>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>查看整个磁盘还剩多少空间，可以使用命令 ：<code>df -h</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-29-30-52998d84f183f42a3527e52b3a07034c-20201217092929-8c62e8.png" alt="fix-dir/picgo/2020/12/17/09-29-30-52998d84f183f42a3527e52b3a07034c-20201217092929-8c62e8"></p>
<ol>
<li>如果并不关心磁盘还剩余多少空间，只是需要知道当前的文件夹下的磁盘使用情况，可以使用如下命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du --max-depth&#x3D;1 -h</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-32-11-60c68d68ff6c4d21d31c5870883a5102-20201217093211-51046e.png" alt="fix-dir/picgo/2020/12/17/09-32-11-60c68d68ff6c4d21d31c5870883a5102-20201217093211-51046e"></p>
<ol start="2">
<li>使用 <code>du --max-depth=1 -h </code>命令来查找磁盘的使用情况，默认是当前的路径。</li>
</ol>
<p>-h：为了方便读懂每个文件的大小，如果没有这个参数显示的文件大小就没有k,M,G等。</p>
<p>得到结果中，前面n-1行的是该目录下每个文件夹的大小。最后一行显示的是该目录总的大小。</p>
<ol start="3">
<li>如果并不关心该目录下每个文件的大小，只想知道其中某一个文件（文件夹）的大小，需要使用下面命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-32-57-bc8010be0c642e2c43700273cdf74a91-20201217093257-f77065.png" alt="fix-dir/picgo/2020/12/17/09-32-57-bc8010be0c642e2c43700273cdf74a91-20201217093257-f77065"></p>
<ol start="4">
<li>还有另外一个命令，也可以得到得到同样的效果：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du --max-depth&#x3D;0 -h</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-33-29-621923843fa32b4724058a3b104407ce-20201217093329-d78398.png" alt="fix-dir/picgo/2020/12/17/09-33-29-621923843fa32b4724058a3b104407ce-20201217093329-d78398"></p>
<p>其实在man手册里面已经告诉了我们：–max-depth=0的功能和-s的功能是一样的。</p>
<h3 id="history-查看历史命令"><a href="#history-查看历史命令" class="headerlink" title="history 查看历史命令"></a>history 查看历史命令</h3><h3 id="coscmd文档v1-8-3-0"><a href="#coscmd文档v1-8-3-0" class="headerlink" title="coscmd文档v1.8.3.0"></a>coscmd文档v1.8.3.0</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/35906f1b854b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">https://www.jianshu.com/p/35906f1b854b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>
<h3 id="usr-bin-expect"><a href="#usr-bin-expect" class="headerlink" title="/usr/bin/expect"></a>/usr/bin/expect</h3><p>项目中遇到/usr/bin/expect 使用：login.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># expect超过超时时间没有监测到要找的字符串，则不执行</span></span><br><span class="line"><span class="built_in">set</span> timeout 30</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取传入的三个参数</span></span><br><span class="line"><span class="built_in">set</span> host [lindex <span class="variable">$argv</span> 0]</span><br><span class="line"><span class="built_in">set</span> code [lindex <span class="variable">$argv</span> 1]</span><br><span class="line"><span class="built_in">set</span> passwd [lindex <span class="variable">$argv</span> 2]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 运行ssh连接命令</span></span><br><span class="line">spawn ssh <span class="variable">$host</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 自动输入验证码&amp;密码</span></span><br><span class="line">expect &#123;</span><br><span class="line">  <span class="string">&quot;Verification code:&quot;</span> &#123; send <span class="string">&quot;<span class="variable">$code</span>\n&quot;</span>; exp_continue&#125;</span><br><span class="line">  <span class="string">&quot;Password:&quot;</span> &#123; send <span class="string">&quot;<span class="variable">$passwd</span>\n&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 退出expect返回终端，可以继续输入，否则将一直在expect不能退出到终端</span></span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>执行脚本<code>./ssh.exp host code passwd</code></p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><ul>
<li>spawn : expect脚本中用于向机器发出首个linux命令用，该命令将在系统中创建一个进程</li>
<li>expect : expect脚本中用于等待和分析机器执行结果用</li>
<li>send : expect脚本中用于模仿“人”向机器进程发出linux命令用</li>
<li>interact : expect脚本中用于将交互双方由expect脚本和机器内核改为——&gt;字符终端和机器内核（即为正常人和机器交互的模式）</li>
</ul>
<h5 id="sh脚本调用expect"><a href="#sh脚本调用expect" class="headerlink" title="sh脚本调用expect"></a>sh脚本调用expect</h5><p>   expect只能用来代替人向终端输入指令。有时候在此之前还需要运行一些shell脚本的命令。所有就需要使用sh脚本来调用expect。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 登录信息</span></span><br><span class="line">host=<span class="string">&quot;这里是主机地址&quot;</span></span><br><span class="line">passwd=<span class="string">&quot;这里是密码&quot;</span></span><br><span class="line">secret=<span class="string">&quot;这个是用来计算code的加密串，无视它&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获得动态码</span></span><br><span class="line">code=`这里是计算code的命令，继续无视它`</span><br><span class="line"> </span><br><span class="line"><span class="comment"># expect调用login脚本</span></span><br><span class="line">expect login.sh <span class="variable">$host</span> <span class="variable">$code</span> <span class="variable">$passwd</span></span><br></pre></td></tr></table></figure>

<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>-r 就是向下递归，不管有多少级目录，一并删除<br>-f 就是直接强行删除，不作任何提示的意思</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除文件夹实例：</span></span><br><span class="line"><span class="built_in">rm</span> <span class="literal">-rf</span> /var/log/httpd/access</span><br><span class="line"><span class="comment">#将会删除/var/log/httpd/access目录以及其下所有文件、文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除文件使用实例：</span></span><br><span class="line"><span class="built_in">rm</span> <span class="operator">-f</span> /var/log/httpd/access.log</span><br><span class="line"><span class="comment">#将会强制删除/var/log/httpd/access.log这个文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="source、sh、bash、-执行脚本的区别"><a href="#source、sh、bash、-执行脚本的区别" class="headerlink" title="source、sh、bash、./执行脚本的区别"></a>source、sh、bash、./执行脚本的区别</h3><p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/128918.htm">https://www.jb51.net/article/128918.htm</a></p>
<h3 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(cd \&#96;dirname \$0\&#96;;pwd)</span><br></pre></td></tr></table></figure>
<p>在命令行状态下单纯执行 $ cd `dirname $0`<br>是毫无意义的。因为他返回当前路径的&quot;.&quot;。</p>
<p>这个命令写在脚本文件里才有作用，他返回这个脚本文件放置的目录，并可以根据这个目录来定位所要运行程序的相对位置（绝对位置除外）。</p>
<p>以上命令 $(dirname &quot;$0&quot;)<br>将返回该文件当前的上一层路径，通过cd到该路径，通过pwd获得当前路径</p>
<blockquote>
<p>另一个写法是：cd `dirname $0` 其中反引号··等同于$()。</p>
</blockquote>
<h3 id="！-n］和［！-d］"><a href="#！-n］和［！-d］" class="headerlink" title="[ ！-n］和［！-d］"></a>[ ！-n］和［！-d］</h3><ul>
<li>! 一般在shell脚本中表示取反</li>
<li>[] 这个叫条件表达式 简易版的if\</li>
<li>n 用于判断变量是否为空,注意只要有一个符号就不为空,空格也不行\</li>
<li>d directory意思 用于判断目录是否存在</li>
<li>[ ! -n ] [ ! -d ] 的意思你应该懂了<br>[ ! -n ] 判断变量如果不为空则条件成立<br>[ ! -d ] 判断变量如果不是目录则条件成立</li>
</ul>
<p>Eg:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ! -d \<span class="variable">$&#123;split_tmp_path&#125;</span> ];<span class="keyword">then</span></span><br><span class="line">  mkdir -p \<span class="variable">$&#123;split_tmp_path&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><p>测试：文件是否存在，文件属性，访问权限等</p>
<table>
<thead>
<tr>
<th><strong>[</strong> <strong>-f</strong> <strong>fname</strong> <strong>]</strong></th>
<th><strong>fname</strong> 存在且是普通文件时，返回真 ( 即返回 <strong>0</strong> )</th>
</tr>
</thead>
<tbody><tr>
<td><strong>[</strong> <strong>-L</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong> 存在且是链接文件时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-d</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong> 存在且是一个目录时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-e</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong>（文件或目录）存在时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-s</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong> 存在且大小大于 <strong>0</strong> 时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-r</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong>（文件或目录）存在且可读时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-w</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong>（文件或目录）存在且可写时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-x</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong>（文件或目录）存在且可执行时，返回真</td>
</tr>
</tbody></table>
<h3 id="参数用法"><a href="#参数用法" class="headerlink" title="$参数用法"></a>$参数用法</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>当前脚本的文件名（间接运行时还包括绝对路径）</td>
</tr>
<tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数</td>
</tr>
<tr>
<td>$@</td>
<td><code>$*</code>和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号 (“”) 包含时，都以”<code>$1</code>“ “<code>$2</code>“ … “<code>$n</code>“ 的形式输出所有参数。但是当它们被双引号 (“”) 包含时，”<code>\$*</code>“会将所有的参数作为一个整体，以<code>&quot;$1 $2 … $n&quot;</code>的形式输出所有参数；”<code>$@</code>“会将各个参数分开，以<code>&quot;$1&quot;&quot;$2&quot; … &quot;$n&quot;</code>的形式输出所有参数。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值</td>
</tr>
<tr>
<td>$$</td>
<td>当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID</td>
</tr>
<tr>
<td>$_</td>
<td>上一个命令的最后一个参数</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的 ID 号</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span>    <span class="comment"># 当前脚本的文件名（间接运行时还包括绝对路径）。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$n</span>    <span class="comment"># 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1 。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span>    <span class="comment"># 传递给脚本或函数的参数个数。</span></span><br><span class="line"><span class="built_in">echo</span> $*    <span class="comment"># 传递给脚本或函数的所有参数。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span>    <span class="comment"># 传递给脚本或函数的所有参数。被双引号 (&quot; &quot;) 包含时，与 $* 不同，下面将会讲到。</span></span><br><span class="line"><span class="built_in">echo</span> $?    <span class="comment"># 上个命令的退出状态，或函数的返回值。</span></span><br><span class="line"><span class="built_in">echo</span> $$    <span class="comment"># 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$_</span>    <span class="comment"># 上一个命令的最后一个参数</span></span><br><span class="line"><span class="built_in">echo</span> $!    <span class="comment"># 后台运行的最后一个进程的 ID 号</span></span><br></pre></td></tr></table></figure>


<p>详见链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4db526ff6560">https://www.jianshu.com/p/4db526ff6560</a></p>
<h3 id="amp-和wait并行"><a href="#amp-和wait并行" class="headerlink" title="&amp;和wait并行"></a>&amp;和wait并行</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>我们知道shell中的命令都是串行执行的，如果想要充分利用服务器的资源，就需要些小技巧了。</p>
<p>假定业务上多个业务逻辑没有先后关系，每个脚本的执行时间也很长<br>，推荐并行执行。</p>
<p>一般情况下,我们会把每个业务逻辑写到一个单独的脚本里，在服务器上逐一调用，每次都要手工去敲命令。</p>
<p>如果我们把这些脚本放到一个调用脚本里呢？<br>执行的时候去调用这个调用脚本，事实上linux会根据脚本中的顺序<br>串行去调用这些脚本，还不如自己在服务器上一个个的执行快呢，最起码手工逐个调用脚本还是并行的。</p>
<p><strong>在每个进程中使用&amp;符号进行让脚本在后台运行，无需等待当前进程结束。</strong></p>
<p><strong>为了确保每个进程都执行完成，最后务必使用wait关键字，用来确保每一个子进程都执行完成。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前目录下执行如下脚本 相对路径</span></span><br><span class="line"></span><br><span class="line">./1.sh &amp; <span class="comment">#!相当于启动子进程</span></span><br><span class="line"></span><br><span class="line">./2.sh &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span> <span class="comment">#相当于join操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;继续执行剩下的逻辑...&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort：将文件进行排序并输出</p>
<p>补充说明:</p>
<blockquote>
<p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。</p>
</blockquote>
<h4 id="语法：sort-选项-参数"><a href="#语法：sort-选项-参数" class="headerlink" title="语法：sort(选项)(参数)"></a>语法：sort(选项)(参数)</h4><ol>
<li><strong>选项：</strong></li>
</ol>
<ul>
<li><p>-b：忽略每行前面开始出的空格字符；</p>
</li>
<li><p>-c：检查文件是否已经按照顺序排序；</p>
</li>
<li><p>-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；</p>
</li>
<li><p>-f：排序时，将小写字母视为大写字母；</p>
</li>
<li><p>-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</p>
</li>
<li><p>-m：将几个排序号的文件进行合并；</p>
</li>
<li><p>-M：将前面3个字母依照月份的缩写进行排序；</p>
</li>
<li><p>-n：依照数值的大小排序；</p>
</li>
<li><p>-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；</p>
</li>
<li><p>-r：以相反的顺序来排序；</p>
</li>
<li><p>-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；</p>
</li>
<li><p>+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</p>
</li>
</ul>
<ol start="2">
<li><strong>参数：</strong><br>文件：指定待排序的文件列表。</li>
</ol>
<p>sort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p>
<h3 id="uniq-注意"><a href="#uniq-注意" class="headerlink" title="uniq 注意"></a>uniq 注意</h3><p>使用shell统计多行文本中非重复行数<br>sort命令可以对文本的内容进行排序<br>uniq命令可以对文本内容连续的内容进行去重，<strong>非连续的重复内容无法去重</strong></p>
<p>sort 文件 | uniq 可以达到去除所有重复数据的目的（因为先排序了，这样相同的内容一定在连续的一片，再uniq）</p>
<p>sort 文件 |uniq  等价于   sort -u 文件<br>所以最终的命令可以是：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> <span class="literal">-u</span> 文本 | wc <span class="literal">-l</span></span><br></pre></td></tr></table></figure>
<h3 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a>iconv</h3><p>由于UTF-8编码同时支持中文、还是日文、韩文、阿拉伯文在类的各种语言，所以它在Mac中被广泛使用，而目前Mac上的Excel在导入CSV文件时虽然给出了UTF8的选项，但是导入以后的中文还是乱码，这是因为它实际上是不支持UTF8编码方式导致的，至少对于Excel 2011 for Mac是这样。</p>
<p>那么怎么解决这个问题呢，方法很简单：<strong>将文件的编码方式由UTF8转为Excel支持的中文编码方式</strong>，Mac上的iconv工具专门就可以用来干这个事情。例如，在Excel给出的中文编码方式中有GB18030，那么我们可以通过Mac上的iconv工具将文件编码由UTF8转为GB18030。只需要在命令行中键入如下的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f UTF8 -t GB18030 源文件.csv &gt;新文件.csv</span><br></pre></td></tr></table></figure>



<h3 id="文件并、交、差"><a href="#文件并、交、差" class="headerlink" title="文件并、交、差"></a>文件并、交、差</h3><p><strong>方法一</strong>（直接用文件名）：取两个文本文件的并集、交集、差集</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">并</span></span><br><span class="line">sort -m &lt;(sort file1 | uniq) &lt;(sort file2 | uniq) | uniq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">交</span></span><br><span class="line">sort -m &lt;(sort file1 | uniq) &lt;(sort file2 | uniq) | uniq -d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">差 file1 - file2:</span></span><br><span class="line">sort -m &lt;(sort file1 | uniq) &lt;(sort file2 | uniq) &lt;(sort file2 | uniq) | uniq -u</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>（用变量参数）：取两个文本文件的并集、交集、差集</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file1=XXXX</span><br><span class="line">file2=YYYY</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并:</span></span><br><span class="line">sort -m &lt;(sort $file1 | uniq) &lt;(sort $file2 | uniq) | uniq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 交:</span></span><br><span class="line">sort -m &lt;(sort $file1 | uniq) &lt;(sort $file2 | uniq) | uniq -d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 差 file1 - file2:</span></span><br><span class="line">sort -m &lt;(sort $file1 | uniq) &lt;(sort $file2 | uniq) &lt;(sort $file2 | uniq) | uniq -u</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file1=XXXX</span><br><span class="line">file2=YYYY</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并:</span></span><br><span class="line">cat $file1 $file2 | sort | uniq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 交:</span></span><br><span class="line">cat $file1 $file2 | sort | uniq -d</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li><p>uniq -d 会输出重复行</p>
</li>
<li><p>uniq -u 只显示唯一的行</p>
</li>
</ul>
<p>grep命令</p>
<p>grep命令是常用来搜索文本内容的，根据输入的pattern，输出命中的内容。可以利用它的文件输入pattern特性，来求两个文件的交集。</p>
<p>那差集可以利用-v这个参数，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep -F -v -f a.file b.file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -F -v -f b.file a.file</span></span><br><span class="line">其中第一个命令求B-A，第二个命令求A-B</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1）grep求交集不要求输入文件是排序的，但最好是唯一的</p>
<p>2）差集时注意输入文件的顺序</p>
<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>Linux split命令用于将一个文件分割成数个。</p>
<p>该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split [--help][--version][-&lt;行数&gt;][-b &lt;字节&gt;][-C&lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li><p>-&lt;行数&gt; : 指定每多少行切成一个小文件</p>
</li>
<li><p>-b&lt;字节&gt; : 指定每多少字节切成一个小文件</p>
</li>
<li><p>–help : 在线帮助</p>
</li>
<li><p>–version : 显示版本信息</p>
</li>
<li><p>-C&lt;字节&gt; : 与参数”-b”相似，但是在切 割时将尽量维持每行的完整性</p>
</li>
<li><p>[输出文件名] : 设置切割后文件的前置文件名，<br>split会自动在前置文件名后再加上编号</p>
</li>
</ul>
<p><strong>举个例子</strong><br>将文件message,按照10k分割  前缀是pg  后缀是三位置有效数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -b 10k -d -a 3   messages pg   </span><br></pre></td></tr></table></figure>
<p> -b 后面跟大小 可以是m k 或者是g </p>
<p>-d 表示文件后缀为数字类型</p>
<p>-a 3 表示文件后缀的数字类型是三位有效数字</p>
<p>message 是源文件名称</p>
<p>pg 是生成分割后的文件的前缀</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-03-03-19d8a54e9da736c90acaaebee8f688ca-image3-57d037.png">{width=”5.186111111111111in”<br>height=”3.7368055555555557in”}</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-03-16-9f52dd0a72b02beba2956f86c969d28d-image4-1ef15b.png">{width=”5.405555555555556in”<br>height=”2.9180555555555556in”}</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-03-31-6f66d8b0fb4adb680790691bc38f933b-image5-d93179.png">{width=”5.871527777777778in”<br>height=”2.8465277777777778in”}</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-02-44-c04e9d495ebf2d4668822b6e400c0db7-image6-ed0f28.png">{width=”6.014583333333333in”<br>height=”4.415972222222222in”}</p>
<h4 id="获取ip地址"><a href="#获取ip地址" class="headerlink" title="获取ip地址"></a>获取ip地址</h4><h5 id="方法一：ifconfig-a"><a href="#方法一：ifconfig-a" class="headerlink" title="方法一：ifconfig -a"></a>方法一：ifconfig -a</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|tr -d <span class="string">&quot;addr:&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>命令解释</strong></p>
<ol>
<li>ifconfig -a 　　　　 和window下执行此命令一样道理，返回本机所有ip信息</li>
<li>grep inet          截取包含ip的行</li>
<li>grep -v 127.0.0.1   去掉本地指向的那行</li>
<li>grep -v inet6       去掉包含inet6的行</li>
<li>awk { print $2}     $2 表示默认以空格分割的第二组 同理 $1表示第一组</li>
<li>tr -d “addr:        删除”addr:”这个字符串</li>
</ol>
<p>其他方法参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/poloyy/p/12212868.html">https://www.cnblogs.com/poloyy/p/12212868.html</a></li>
</ul>
<h3 id="关于2-gt-amp-1的含义"><a href="#关于2-gt-amp-1的含义" class="headerlink" title="关于2&gt;&amp;1的含义"></a>关于2&gt;&amp;1的含义</h3><ol>
<li><p>含义：<strong>将标准错误输出重定向到标准输出</strong></p>
</li>
<li><p><strong>符号&gt;&amp;是一个整体</strong>，不可分开，分开后就不是上述含义了。<br>比如有些人可能会这么想：2是标准错误输入，1是标准输出，&gt;是重定向符号，那么&quot;将标准错误输出重定向到标准输出&quot;是不是就应该写成&quot;2&gt;1&quot;就行了？是这样吗？\</p>
</li>
</ol>
<blockquote>
<p>如果是尝试过，你就知道<strong>2&gt;1的写法其实是将标准错误输出重定向到名为&quot;1&quot;的文件里去了</strong></p>
</blockquote>
<ol start="3">
<li>写成<strong>2&amp;&gt;1</strong>也是不可以的</li>
</ol>
<p><strong>为什么2&gt;&amp;1要放在后面</strong></p>
<p>考虑如下一条shell命令</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java <span class="literal">-jar</span> app.jar \&gt;log <span class="number">2</span>\&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一个&amp;表示把条命令放到后台执行</p>
</blockquote>
<p>为什么2&gt;&amp;1一定要写到&gt;log后面，才表示标准错误输出和标准输出都定向到log中？<br>我们<strong>不妨把1和2都理解是一个指针</strong>,然后来看上面的语句就是这样的：</p>
<ol>
<li><p>本来1-----&gt;屏幕 （1指向屏幕）</p>
</li>
<li><p>执行&gt;log后， 1-----&gt;log (1指向log)</p>
</li>
<li><p>执行2&gt;&amp;1后， 2-----&gt;1 (2指向1，而1指向log,因此2也指向了log)</p>
</li>
</ol>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaominpro/article/details/82630528">https://blog.csdn.net/zhaominpro/article/details/82630528</a><blockquote>
<p>关于输入/输出重定向本文就不细说了，不懂的可以参考<a target="_blank" rel="noopener" href="http://www.runoob.com/linux/linux-shell-io-redirections.html">这里</a>，主要是要了解&gt;&lt; &lt;&lt; &gt;&gt; &lt;&amp; &gt;&amp; 这6个符号的使用</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3></li>
</ul>
<p>Bash 2.x 以上支持一维数组，下标从 0 开始。</p>
<p>使用 declare 声明或直接给变量名加下标来赋值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a variable</span><br><span class="line">variable=(item1 item2 item2 ... )</span><br><span class="line"></span><br><span class="line">variable=(item1 item2 item2 ... )</span><br><span class="line">variable[n]=value</span><br></pre></td></tr></table></figure>

<p>数组的引用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;variable[n]&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>举例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a stu</span><br><span class="line">stu=(math1101 math1102 math1103)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;stu[0]&#125;</span>  <span class="comment"># 列出stu的第一个元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;stu[*]&#125;</span>  <span class="comment"># 列出stu的所有元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#stu[*]&#125;</span> <span class="comment"># 给出数组stu中元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数组与数组元素的删除</span></span><br><span class="line"><span class="built_in">unset</span> stu[1]   <span class="comment"># 删除stu的第二个元素</span></span><br><span class="line"><span class="built_in">unset</span> stu      <span class="comment"># 删除整个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数组赋值时无须按顺序赋值</span></span><br><span class="line">x[3]=100; <span class="built_in">echo</span> <span class="variable">$&#123;x[*]&#125;</span></span><br><span class="line">state=(ME [3]=CA [2]=NT); <span class="built_in">echo</span> <span class="variable">$&#123;state[*]&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h4><p>内置命令 declare 可用来声明变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare [选项] variable[&#x3D;value]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>-r</strong></td>
<td><strong>将变量设为只读 (</strong> <strong>readonly</strong> <strong>)</strong></td>
</tr>
<tr>
<td><strong>-x</strong></td>
<td><strong>将变量输出到子</strong> <strong>shell</strong> <strong>中（**</strong>export** <strong>为全局变量）</strong></td>
</tr>
<tr>
<td><strong>-i</strong></td>
<td><strong>将变量设为整型 (</strong> <strong>integer</strong> <strong>)</strong></td>
</tr>
<tr>
<td><strong>-a</strong></td>
<td><strong>将变量设置为一个数组 (</strong> <strong>array</strong> <strong>)</strong></td>
</tr>
<tr>
<td><strong>-f</strong></td>
<td><strong>列出函数的名字和定义 (</strong> <strong>function</strong> <strong>)</strong></td>
</tr>
<tr>
<td><strong>-F</strong></td>
<td><strong>只列出函数名</strong></td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="bash调试"><a href="#bash调试" class="headerlink" title="bash调试"></a>bash调试</h3><p>调试需vscode下安装bash debug ,且bash版本是4.* or 5.*</p>
<p>升级bash如下</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peng-lan/p/11201711.html">Mac进行 usr/bin 目录下修改权限问题，operation not permitted</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/litifeng/p/8448019.html">Mac升级bash到最新版本</a></p>
<p>mac自带的bash为3.2版本，而最新的bash是4.9，需要升级了，才能支持关联数组等新特性。</p>
<p>1、brew install bash</p>
<p>2、安装到/usr/local/bin/bash里面。可以通过修改/etc/shells文件，来完成开机使用新版本的bash</p>
<p>3、但是，无法改变/bin/bash的版本，这里仍旧为3.2版本，这给使用脚本带来不便，因为默认都是#!/bin/bash</p>
<p>4、细查后，发现原来mac系统禁止更改系统目录的权限，引入sip机制，需要先关闭，修改，再打开这一系列操作。</p>
<p>5、下面是打开和关闭sip的步骤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)重启OSX系统，然后按住Command+R</span><br><span class="line"></span><br><span class="line">(2)出现界面之后，选择Utilities menu中Terminal</span><br><span class="line"></span><br><span class="line">(3)在Terminal中输入csrutil disable关闭SIP(csrutil enable打开SIP)</span><br><span class="line"></span><br><span class="line">(4)重启reboot OSX</span><br></pre></td></tr></table></figure>

<p>6、关闭sip后，加入软连接，在打开sip</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /bin/bash  /bin/bash.origin</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/bash /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="写出健壮的-Bash-脚本"><a href="#写出健壮的-Bash-脚本" class="headerlink" title="写出健壮的 Bash 脚本"></a>写出健壮的 Bash 脚本</h2><p>可解决如“<strong>如何让shell中某语句执行错误就能自动退出</strong>”问题</p>
<p>原文<a target="_blank" rel="noopener" href="https://www.oschina.net/news/26744/build-robust-bash-script">https://www.oschina.net/news/26744/build-robust-bash-script</a></p>
<h3 id="使用set-u"><a href="#使用set-u" class="headerlink" title="使用set -u"></a>使用set -u</h3><p>你因为没有对变量初始化而使脚本崩溃过多少次？对于我来说，很多次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chroot=<span class="variable">$1</span></span><br><span class="line">...</span><br><span class="line">rm -rf <span class="variable">$chroot</span>/usr/share/doc</span><br></pre></td></tr></table></figure>

<p>如果上面的代码你没有给参数就运行，你不会仅仅删除掉chroot中的文档，而是将系统的所有文档都删除。那你应该做些什么呢？好在bash提供了<em>set -u</em>，当你使用未初始化的变量时，让bash自动退出。你也可以使用可读性更强一点的<code>set -o nounset</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">david% bash /tmp/shrink-chroot.sh</span><br><span class="line"></span><br><span class="line"><span class="variable">$chroot</span>=</span><br><span class="line"></span><br><span class="line">david% bash -u /tmp/shrink-chroot.sh</span><br><span class="line"></span><br><span class="line">/tmp/shrink-chroot.sh: line 3: <span class="variable">$1</span>: unbound variable</span><br><span class="line"></span><br><span class="line">david%</span><br></pre></td></tr></table></figure>



<h3 id="使用set-e"><a href="#使用set-e" class="headerlink" title="使用set -e"></a>使用set -e</h3><p>你写的每一个脚本的开始都应该包含<em>set -e</em>。这告诉bash一但有任何一个语句返回非真的值，则退出bash。使用-e的好处是避免错误滚雪球般的变成严重错误，能尽早的捕获错误。更加可读的版本：<em>set -o errexit</em></p>
<p>使用-e把你从检查错误中解放出来。如果你忘记了检查，bash会替你做这件事。不过你也没有办法使用*$?*来获取命令执行状态了，因为bash无法获得任何非0的返回值。你可以使用另一种结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span>-ne 0]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;command failed&quot;</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>可以替换成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> || &#123; <span class="built_in">echo</span> <span class="string">&quot;command failed&quot;</span>; <span class="built_in">exit</span> 1; &#125;</span><br></pre></td></tr></table></figure>

<p>或者使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;command failed&quot;</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>如果你必须使用返回非0值的命令，或者你对返回值并不感兴趣呢？你可以使用 <em>command || true</em> ，或者你有一段很长的代码，你可以暂时关闭错误检查功能，不过我建议你谨慎使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> +e</span><br><span class="line"></span><br><span class="line">command1</span><br><span class="line"></span><br><span class="line">command2</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br></pre></td></tr></table></figure>

<p>相关文档指出，bash默认返回管道中最后一个命令的值，也许是你不想要的那个。比如执行 <em>false | true</em> 将会被认为命令成功执行。如果你想让这样的命令被认为是执行失败，可以使用 <em>set -o pipefail</em></p>
<h3 id="程序防御-考虑意料之外的事"><a href="#程序防御-考虑意料之外的事" class="headerlink" title="程序防御 - 考虑意料之外的事"></a>程序防御 - 考虑意料之外的事</h3><p>你的脚本也许会被放到“意外”的账户下运行，像缺少文件或者目录没有被创建等情况。你可以做一些预防这些错误事情。比如，当你创建一个目录后，如果父目录不存在，<strong>mkdir</strong> 命令会返回一个错误。如果你创建目录时给<strong>mkdir</strong>命令加上-p选项，它会在创建需要的目录前，把需要的父目录创建出来。另一个例子是 <strong>rm</strong> 命令。如果你要删除一个不存在的文件，它会“吐槽”并且你的脚本会停止工作。（因为你使用了-e选项，对吧？）你可以使用-f选项来解决这个问题，在文件不存在的时候让脚本继续工作。 </p>
<h3 id="准备好处理文件名中的空格"><a href="#准备好处理文件名中的空格" class="headerlink" title="准备好处理文件名中的空格"></a>准备好处理文件名中的空格</h3><p>有些人从在文件名或者命令行参数中使用空格，你需要在编写脚本时时刻记得这件事。你需要时刻记得用引号包围变量。</p>
<p>if [ $filename = “foo” ];</p>
<p>当*$filename*变量包含空格时就会挂掉。可以这样解决：</p>
<p>if [ “$filename” = “foo” ];</p>
<p>使用*$@*变量时，你也需要使用引号，因为空格隔开的两个参数会被解释成两个独立的部分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">david% <span class="function"><span class="title">foo</span></span>() &#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> &#125;; foo bar <span class="string">&quot;baz quux&quot;</span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line">baz</span><br><span class="line"></span><br><span class="line">quux</span><br><span class="line"></span><br><span class="line">david% <span class="function"><span class="title">foo</span></span>() &#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> &#125;; foo bar <span class="string">&quot;baz quux&quot;</span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line">baz quux</span><br></pre></td></tr></table></figure>

<p>我没有想到任何不能使用*”$@”*的时候，所以当你有疑问的时候，使用引号就没有错误。</p>
<p>如果你同时使用find和xargs，你应该使用 -print0 来让字符分割文件名，而不是换行符分割。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">david% touch <span class="string">&quot;foo bar&quot;</span></span><br><span class="line"></span><br><span class="line">david% find | xargs ls</span><br><span class="line"></span><br><span class="line">ls: ./foo: No such file or directory</span><br><span class="line"></span><br><span class="line">ls: bar: No such file or directory</span><br><span class="line"></span><br><span class="line">david% find -print0 | xargs -0 ls</span><br><span class="line"></span><br><span class="line">./foo bar</span><br></pre></td></tr></table></figure>

<p>其他见原文</p>
<h1 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="sys-path-append-用法"><a href="#sys-path-append-用法" class="headerlink" title="sys.path.append()用法"></a>sys.path.append()用法</h3><p>使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path [<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;C:Python352\Lib\idlelib\&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>sys.path 返回的是一个列表！</p>
<p>该路径已经添加到系统的环境变量了，当我们要添加自己的搜索目录时，可以通过列表的append()方法；</p>
<p>对于模块和自己写的脚本不在同一个目录下，在脚本开头加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&#39;引用模块的地址\&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="sys-stdout、sys-stdin"><a href="#sys-stdout、sys-stdin" class="headerlink" title="sys.stdout、sys.stdin"></a>sys.stdout、sys.stdin</h3><p>如果需要更好的控制输出，而print不能满足需求，sys.stdout，sys.stdin，sys.stderr就是你需要的。</p>
<ol>
<li>sys.stdout与print：</li>
</ol>
<p>在python中调用print时，事实上调用了sys.stdout.write(obj+&#39;\n&#39;)</p>
<p>print 将需要的内容打印到控制台，然后追加一个换行符</p>
<p>以下两行代码等价：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.stdout.write(\<span class="string">&#x27;hello\&#x27; + \&#x27;\\n\&#x27;)</span></span><br><span class="line"><span class="string">print(\&#x27;hello\&#x27;)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>sys.stdin与input</li>
</ol>
<p>sys.stdin.readline()会将标准输入全部获取，包括末尾的&#39;\n&#39;，因此用len计算长度时是把换行符&#39;\n&#39;算进去了的，但是input()获取输入时返回的结果是不包含末尾的换行符&#39;\n&#39;的。</p>
<p>因此如果在平时使用sys.stdin.readline()获取输入的话，不要忘了去掉末尾的换行符，可以用strip()函数（sys.stdin.readline( ).strip(&#39;\n&#39;)）或sys.stdin.readline()[:-1]这两种方法去掉换行。</p>
<p><img src="%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/image7.png" alt="IMG_256">{width=”3.40625in”<br>height=”1.3854166666666667in”}</p>
<p><img src="%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/image8.png" alt="IMG_257">{width=”4.697916666666667in”<br>height=”1.6770833333333333in”}</p>
<p> </p>
<ol start="3">
<li>从控制台重定向到文件</li>
</ol>
<p>原始的sys.stdout指向控制台，如果把文件的对象引用赋给sys.stdout，那么print调用的就是文件对象的write方法。</p>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/keye/p/7859181.html">https://www.cnblogs.com/keye/p/7859181.html</a></li>
</ul>
<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><h3 id="Python执行路径问题"><a href="#Python执行路径问题" class="headerlink" title="Python执行路径问题"></a>Python执行路径问题</h3><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-15-37-a6a2dd0f6867bb70fb069c41e1c86fec-image9-af7524.png">{width=”7.823611111111111in”<br>height=”3.067361111111111in”}</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-15-48-57b46febe52b66ef5fd10fb46d99857e-image10-9c1a34.png">{width=”7.691666666666666in”<br>height=”3.5722222222222224in”}</p>
<p>定时任务python执行 脚本路径 要一致</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/image11.png">{width=”4.884027777777778in”<br>height=”1.03125in”}</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-crontab.html">https://www.runoob.com/linux/linux-comm-crontab.html</a></p>
<h3 id="name-‘reload’-is-not-defined解决方法"><a href="#name-‘reload’-is-not-defined解决方法" class="headerlink" title="name ‘reload’ is not defined解决方法"></a>name ‘reload’ is not defined解决方法</h3><p>原因是，python版本的问题</p>
<p>python2.7版本，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reload(sys)　　　　　　　　　　　　　　<span class="comment">#重新加载sys模块</span></span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)　　 <span class="comment">#设置默认编码格式为utf-8</span></span><br></pre></td></tr></table></figure>

<p>在3.x版本中，应改成如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">importlib.reload(sys)</span><br><span class="line"><span class="comment">#sys.setdefaultencoding(&#x27;utf8&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>设置编码格式的代码可以注释掉，因为3.x版本中默认就是utf-8编码</p>
<p>另，有可能vscode run 和 debug 选取编译器不同，导致出现问题</p>
<p>统一编译器</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/15/15-05-37-003127015b900cbc3ed190db9d1a25ad-image-20201215150533726-0b14e6.png" alt="image-20201215150533726"></p>
<h3 id="configparser"><a href="#configparser" class="headerlink" title="configparser"></a>configparser</h3><p>使用</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32392853/article/details/81603659">https://blog.csdn.net/qq_32392853/article/details/81603659</a></p>
<p><strong>注意事项</strong></p>
<p>configparser.NoSectionError: No section 解决方案</p>
<p>首先在读取配置文件时，我们在当前目录下能够正常运行，<code>python main.py</code>但是当我们切换到其他目录下，比如上级目录<code>python ./test/main.py</code>，运行的时候可能会报错，<code>configparser.NoSectionError: No section xx</code> .产生此问题的原因是<code>cofig.ini</code>文件路径不对，没有正确读取。<br>举一反三，在其他需要用到路径的地方，我们都需要注意，在此目录下能后正确运行，换成其他目录可能会产生错误，因此在使用<code>os.getcwd()</code>时需要注意。一般来说，可以采用下面方法解决。</p>
<p><strong>解决方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取配置文件</span></span><br><span class="line">cfg = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">cfg.read(os.path.join(BASE_DIR ,<span class="string">&#x27;config.ini&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意使用<code>os.path.join</code> 以适应linux和windows不同目录分隔符的写法。<br>如果是多层级的话，可以使用<code>os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</code></p>
<h3 id="urllib模块的urlopen-的使用方法及实例"><a href="#urllib模块的urlopen-的使用方法及实例" class="headerlink" title="urllib模块的urlopen()的使用方法及实例"></a>urllib模块的urlopen()的使用方法及实例</h3><p>Python urllib 库提供了一个从指定的 URL<br>地址获取网页数据，然后对其进行分析处理，获取想要的数据。</p>
<p><strong>urllib模块urlopen()函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlopen(url, data&#x3D;None, proxies&#x3D;None)</span><br></pre></td></tr></table></figure>
<p>创建一个表示远程url的类文件对象，然后像本地文件一样操作这个类文件对象来获取远程数据。</p>
<ul>
<li>参数url表示远程数据的路径，一般是网址；\</li>
<li>参数data表示以post方式提交到url的数据(玩过web的人应该知道提交数据的两种方式：post与get)；\</li>
<li>参数proxies用于设置代理。</li>
</ul>
<p>urlopen返回 一个类文件对象(fd)，它提供了如下方法：<br>read() , readline() , readlines() , fileno() , close()<br>：这些方法的使用方式与文件对象完全一样;</p>
<ul>
<li>info()：返回一个httplib.HTTPMessage对象，表示远程服务器返回的头信息(header)</li>
<li>getcode()：返回Http状态码。如果是http请求，200表示请求成功完成;404表示网址未找到；</li>
<li>geturl()：返回请求的url；</li>
</ul>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/langdashu/p/4963053.html">https://www.cnblogs.com/langdashu/p/4963053.html</a></li>
</ul>
<h3 id="分块读取文件"><a href="#分块读取文件" class="headerlink" title="分块读取文件"></a>分块读取文件</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zx8167107/article/details/81083249">https://blog.csdn.net/zx8167107/article/details/81083249</a></p>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><ol>
<li>级别排序:CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG</li>
</ol>
<ul>
<li><p>debug : 打印全部的日志,详细的信息,通常只出现在诊断问题上</p>
</li>
<li><p>info : 打印info,warning,error,critical级别的日志,确认一切按预期运行</p>
</li>
<li><p>warning :打印warning,error,critical级别的日志,一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”),这个软件还能按预期工作</p>
</li>
<li><p>error : 打印error,critical级别的日志,更严重的问题,软件没能执行一些功能</p>
</li>
<li><p>critical :打印critical级别,一个严重的错误,这表明程序本身可能无法继续运行。这时候，如果需要显示低于WARNING级别的内容，可以引入NOTSET级别来显示：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import logging # 引入logging模块</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level&#x3D;logging.NOTSET) # 设置日志级别</span><br><span class="line"></span><br><span class="line">logging.debug(u\&quot;如果设置了日志级别为NOTSET,那么这里可以采取debug、info的级别的内容也可以显示在控制台上了&quot;)</span><br></pre></td></tr></table></figure>
<p>回显：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-16-08-08a57b88fcc3dcd7c497a071cc0e4956-image12-748697.png" alt="IMG_256">{width=”8.729166666666666in”<br>height=”0.28125in”}</p>
<ol start="2">
<li>部分名词解释</li>
</ol>
<p>Logging.Formatter：这个类配置了日志的格式，在里面自定义设置日期和时间，输出日志的时候将会按照设置的格式显示内容。<br>Logging.Logger：Logger是Logging模块的主体，进行以下三项工作：<br>  a. 为程序提供记录日志的接口<br>  b. 判断日志所处级别，并判断是否要过滤<br>  c. 根据其日志级别将该条日志分发给不同handler<br><strong>常用函数有：</strong></p>
<ul>
<li>Logger.setLevel() 设置日志级别\</li>
<li>Logger.addHandler() 和 Logger.removeHandler() 添加和删除一个Handler\</li>
<li>Logger.addFilter() 添加一个Filter,过滤作用\</li>
<li>Logging.Handler：Handler基于日志级别对日志进行分发，如设置为WARNING级别的Handler只会处理WARNING及以上级别的日志。\</li>
<li>setFormatter() 设置Formatter<br>formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s -%(message)s&#39;)</li>
</ul>
<p>参数说明:<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xianyulouie/p/11041777.html">https://www.cnblogs.com/xianyulouie/p/11041777.html</a></p>
<h3 id="python－读取文件和计算文件行数"><a href="#python－读取文件和计算文件行数" class="headerlink" title="python－读取文件和计算文件行数"></a>python－读取文件和计算文件行数</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34213260/article/details/85062841">https://blog.csdn.net/qq_34213260/article/details/85062841</a></p>
<p>linecache是专门支持读取大文件，而且支持行式读取的函数库。<br>linecache预先把文件读入缓存起来，后面如果你访问该文件的话就不再从硬盘读取。</p>
<h3 id="Groupby"><a href="#Groupby" class="headerlink" title="Groupby"></a>Groupby</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupby</span>(<span class="params">iterable: Iterable[_T], key: Callable[[_T], _S]</span>)</span></span><br><span class="line"><span class="function">-&gt; Iterator[Tuple[_S, Iterator[_T]]]:</span></span><br></pre></td></tr></table></figure>

<p>返回一个迭代器，可用于读取大文件</p>
<p>另，由于这个工具包的<br>groupby，针对相邻的数据的key进行分组，若不相邻，则即使key相同，也不会分到一组，故需要对原始日志进行排序<br>EG:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line">lst=[[<span class="number">1</span>,<span class="string">&quot;lili&quot;</span>],</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="string">&quot;lilei&quot;</span>],</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>,<span class="string">&quot;liu&quot;</span>],</span><br><span class="line"></span><br><span class="line">[<span class="number">4</span>,<span class="string">&quot;bob&quot;</span>],</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="string">&quot;merry&quot;</span>],</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="string">&quot;jerk&quot;</span>],</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="string">&quot;jerry&quot;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key,group <span class="keyword">in</span> groupby(lst,itemgetter(<span class="number">0</span>)):</span><br><span class="line">  print(key,list(group))</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">lst=sorted(lst,key=itemgetter(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">for</span> key,group <span class="keyword">in</span> groupby(lst,itemgetter(<span class="number">0</span>)):</span><br><span class="line">  print(key,list(group))</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-16-24-64cf0f76079732d9ff04aeabf154a99f-image13-dc5739.png">{width=”3.6055555555555556in”<br>height=”1.9743055555555555in”}</p>
<h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><ul>
<li><p>Druid 在 Airbnb爱彼迎数据分析上的应用:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/70093649">https://zhuanlan.zhihu.com/p/70093649</a></p>
</li>
<li><p>Druid介绍及入门:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27466827/article/details/82777112">https://blog.csdn.net/qq_27466827/article/details/82777112</a></p>
</li>
<li><p>Druid是什么和Druid的介绍:<a target="_blank" rel="noopener" href="https://blog.csdn.net/nuliPerfect/article/details/52108036?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">https://blog.csdn.net/nuliPerfect/article/details/52108036?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control</a></p>
</li>
<li><p>Druid基本概念及架构介绍:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6f822e0f538c">https://www.jianshu.com/p/6f822e0f538c</a></p>
</li>
</ul>
<h3 id="OLAP之Druid之查询"><a href="#OLAP之Druid之查询" class="headerlink" title="OLAP之Druid之查询"></a>OLAP之Druid之查询</h3><p>Druid的聚合查询主要有三种形式:</p>
<ul>
<li><p>Timeseries</p>
</li>
<li><p>TopN</p>
</li>
<li><p>GroupBy</p>
</li>
</ul>
<p>一般而言，OLAP系统最核心的能力是GroupBy查询，Druid也不例外。<br>但是GroupBy查询资源消耗较多，TopN和Timeseries作为GroupBy的有益补充，能够改善查询的性能。我们建议：如果TopN和Timeseries能够满足业务的应用场景，那么尽量采用这两种查询，而非GroupBy。</p>
<p>Druid提供RESTful的查询接口，用户使用JSON表达查询意图。</p>
<p>查询命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &#x27;broker:&lt;port&gt;/druid/v2/?pretty&#x27; -H</span><br><span class="line">&#x27;Content-Type:application/json&#x27; -d @&lt;query_json_file&gt;</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在Druid查询中，过滤条件是所有查询都可能涉及的部分，并且有一些使用技巧，需要特别注意。请参考Filters。</p>
<p>指标聚合这部分也是非常重要的，Aggregations也提供了系统的介绍，此处就不再赘述了。我们需要指出的是，这一页文档中Filtered<br>Aggregator能够提供非常强大的查询功能，比如在查询过程中根据维度取值定制指标。</p>
<ul>
<li><p>&quot;dimension&quot;: &quot;sample_dim&quot;, #需要聚合的维度列</p>
</li>
<li><p>&quot;filter&quot;:  #过滤条件</p>
</li>
<li><p>&quot;aggregations&quot;:  #返回的指标列</p>
</li>
<li><p>&quot;postAggregations&quot;:  #后处理逻辑，这部分是可选的</p>
</li>
<li><p>&quot;intervals&quot;: [“2012-01-01T00:00:00.000/2012-01-04T00:00:00.000” ]#本次查询覆盖的时间范围</p>
</li>
</ul>
<p>原文链接<br>-<a target="_blank" rel="noopener" href="http://druid.io/docs/0.10.1/querying/aggregations.html">http://druid.io/docs/0.10.1/querying/aggregations.html</a></p>
<h4 id="TopN"><a href="#TopN" class="headerlink" title="TopN"></a>TopN</h4><ul>
<li><p>TopN查询返回的是根据某一维度进行group by后再排序，返回结果集</p>
</li>
<li><p>为了提高执行效率，TopN的查询是近似查询（从我们使用经验来看，返回结果基本是比较准确的）</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;queryType\: &quot;</span>topN<span class="string">&quot;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>dataSource<span class="string">&quot;: &quot;</span>sample_data<span class="string">&quot;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>dimension<span class="string">&quot;: &quot;</span>sample_dim<span class="string">&quot;, #需要聚合的维度列</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="mmap模块"><a href="#mmap模块" class="headerlink" title="mmap模块"></a>mmap模块</h3><p>其大致特点如下：</p>
<ul>
<li><p>普通文件被映射到虚拟地址空间后，程序可以向访问普通内存一样对文件进行访问，在有些情况下可以提高IO效率。</p>
</li>
<li><p>它占用物理内存空间少，可以解决内存空间不足的问题，适合处理超大文件。</p>
</li>
<li><p>不同于通常的字符串对象，它是可变的，可以通过切片的方式更改，也可以定位<strong>当前文件位置m.tell()**或</strong>m.seek()定位到文件的指定位置<strong>，再进行</strong>m.write(str)固定长度的修改操作**。</p>
</li>
</ul>
<p><strong>优点如下：（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/755338d11865%EF%BC%89">https://www.jianshu.com/p/755338d11865）</a></strong></p>
<p>1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。</p>
<p>2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p>
<p>3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</p>
<p>4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</p>
<p><strong>缺点如下:</strong></p>
<ol>
<li><p>文件如果很小，是小于4096字节的，比如10字节，由于内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。虽然被映射的文件只有10字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此mmap函数执行后，实际映射到虚拟内存区域的是4096个字节，11~4096的字节部分用零填充。因此如果连续mmap小文件，会浪费内存空间。</p>
</li>
<li><p>对变长文件不适合，文件无法完成拓展，因为mmap到内存的时候，你所能够操作的范围就确定了。</p>
</li>
<li><p>如果更新文件的操作很多，会触发大量的脏页回写及由此引发的随机IO上。所以在随机写很多的情况下，mmap方式在效率上不一定会比带缓冲区的一般写快。</p>
</li>
</ol>
<p>参考文档</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhoujinyi/p/6062907.html">https://www.cnblogs.com/zhoujinyi/p/6062907.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/eece39beee20">https://www.jianshu.com/p/eece39beee20</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33611327/article/details/81738195">https://blog.csdn.net/qq_33611327/article/details/81738195</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luckywang1103/article/details/50619251">https://blog.csdn.net/luckywang1103/article/details/50619251</a></p>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池的基类是 concurrent.futures 模块中的 Executor，Executor<br>提供了两个子类，即 ThreadPoolExecutor 和 ProcessPoolExecutor，其中<br>ThreadPoolExecutor 用于创建线程池，而 ProcessPoolExecutor<br>用于创建进程池。</p>
<p>如果使用线程池/进程池来管理并发编程，那么只要将相应的 task<br>函数提交给线程池/进程池，剩下的事情就由线程池/进程池来搞定。</p>
<p>Exectuor 提供了如下常用方法：</p>
<ul>
<li>submit(fn, *args, **kwargs)：将 fn 函数提交给线程池。*args 代表传给fn 函数的参数，*kwargs 代表以关键字参数的形式为 fn 函数传入参数。</li>
<li>map(func, *iterables, timeout=None, chunksize=1)：该函数类似于全局函数map(func, *iterables)，只是该函数将会启动多个线程，以异步方式立即对iterables 执行 map 处理。</li>
<li>shutdown(wait=True)：关闭线程池。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shutdown(wait=True) </span></span><br><span class="line">相当于进程池的pool.close()+pool.join()操作</span><br><span class="line">wait=<span class="literal">True</span>，等待池内所有任务执行完毕回收完资源后才继续</span><br><span class="line">wait=<span class="literal">False</span>，立即返回，并不会等待池内的任务执行完毕</span><br><span class="line">但不管wait参数为何值，整个程序都会等到所有任务执行完毕</span><br><span class="line">submit和map必须在shutdown之前</span><br><span class="line"><span class="comment">#add_done_callback(fn)</span></span><br><span class="line">回调函数</span><br></pre></td></tr></table></figure>


<p>程序将 task 函数提交（submit）给线程池后，submit 方法会返回一个 Future对象，Future类主要用于获取线程任务函数的返回值。由于线程任务会在新线程中以异步方式执行，因此，线程执行的函数相当于一个”将来完成”的任务，所以Python 使用 Future 来代表。</p>
<p><strong>Future 提供了如下方法：</strong></p>
<ul>
<li><p>cancel()：取消该 Future代表的线程任务。如果该任务正在执行，不可取消，则该方法返回</p>
</li>
<li><p>False；否则，程序会取消该任务，并返回 True。</p>
</li>
<li><p>cancelled()：返回 Future 代表的线程任务是否被成功取消。</p>
</li>
<li><p>running()：如果该 Future 代表的线程任务正在执行、不可被取消，该方法返回True。</p>
</li>
<li><p>done()：如果该 Funture 代表的线程任务被成功取消或执行完成，则该方法返回True。</p>
</li>
<li><p>result(timeout=None)：获取该 Future 代表的线程任务最后返回的结果。如果Future 代表的线程任务还未成，该方法将会阻塞当前线程，其中 timeout参数指定最多阻塞多少秒。</p>
</li>
<li><p>exception(timeout=None)：获取该 Future代表的线程任务所引发的异常。如果该任务成功完成，没有异常，则该方法返回None。</p>
</li>
<li><p>add_done_callback(fn)：为该 Future代表的线程任务注册一个”回调函数”，当该任务成功完成时，程序会自动触发该fn 函数。</p>
</li>
</ul>
<p>在用完一个线程池后，应该调用该线程池的 shutdown()<br>方法，该方法将启动线程池的关闭序列。调用 shutdown()方法后的线程池不再接收新任务，但会将以前所有的已提交任务执行完成。当线程池中的所有任务都执行完成后，该线程池中的所有线程都会死亡。</p>
<p>使用线程池来执行线程任务的步骤如下：</p>
<ol>
<li><p>调用 ThreadPoolExecutor 类的构造器创建一个线程池。</p>
</li>
<li><p>定义一个普通函数作为线程任务。</p>
</li>
<li><p>调用 ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。</p>
</li>
<li><p>当不想提交任何任务时，调用 ThreadPoolExecutor 对象的 shutdown()方法来关闭线程池。</p>
</li>
</ol>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/90674449">https://blog.csdn.net/whatday/article/details/90674449</a></li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进程池和线程池类似</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;%s is runing&#x27;</span> %os.getpid())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    executor=ProcessPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    futures=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        future=executor.submit(task,i)</span><br><span class="line">        futures.append(future)</span><br><span class="line">    executor.shutdown(<span class="literal">True</span>)</span><br><span class="line">    print(<span class="string">&#x27;+++&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        print(future.result())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangshuyuan/articles/9647752.html">python并发编程之多线程（实战）</a></p>
<h4 id="python线程池-ThreadPoolExecutor-的用法及实战"><a href="#python线程池-ThreadPoolExecutor-的用法及实战" class="headerlink" title="python线程池 ThreadPoolExecutor 的用法及实战"></a>python线程池 ThreadPoolExecutor 的用法及实战</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6d6e4f745c27">https://www.jianshu.com/p/6d6e4f745c27</a></p>
<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>从Python3.2开始，标准库为我们提供了 concurrent.futures 模块，它提供了 ThreadPoolExecutor (线程池)和ProcessPoolExecutor (进程池)两个类。</p>
<p>相比 threading 等模块，该模块通过 submit 返回的是一个 future 对象，它是一个未来可期的对象，通过它可以获悉线程的状态主线程(或进程)中可以获取某一个线程(进程)执行的状态或者某一个任务执行的状态及返回值：</p>
<ol>
<li>主线程可以获取某一个线程（或者任务的）的状态，以及返回值。</li>
<li>当一个线程完成的时候，主线程能够立即知道。</li>
<li>让多线程和多进程的编码接口一致。</li>
</ol>
<p><strong>as_completed</strong></p>
<p>上面虽然提供了判断任务是否结束的方法，但是不能在主线程中一直判断啊。最好的方法是当某个任务结束了，就给主线程返回结果，而不是一直判断每个任务是否结束。</p>
<p>ThreadPoolExecutorThreadPoolExecutor 中 的 as_completed() 就是这样一个方法，当子线程中的任务执行完后，直接用 result() 获取返回结果</p>
<p>用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spider</span>(<span class="params">page</span>):</span></span><br><span class="line">    time.sleep(page)</span><br><span class="line">    print(<span class="string">f&quot;crawl task<span class="subst">&#123;page&#125;</span> finished&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> page</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> t:</span><br><span class="line">        obj_list = []</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">            obj = t.submit(spider, page)</span><br><span class="line">            obj_list.append(obj)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(obj_list):</span><br><span class="line">            data = future.result()</span><br><span class="line">            print(<span class="string">f&quot;main: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">crawl task1 finished</span><br><span class="line">main: <span class="number">1</span></span><br><span class="line">crawl task2 finished</span><br><span class="line">main: <span class="number">2</span></span><br><span class="line">crawl task3 finished</span><br><span class="line">main: <span class="number">3</span></span><br><span class="line">crawl task4 finished</span><br><span class="line">main: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>as_completed()</strong> 方法是一个生成器，在没有任务完成的时候，会一直阻塞，除非设置了 timeout。</p>
<p>当有某个任务完成的时候，会 yield 这个任务，就能执行 for 循环下面的语句，然后继续阻塞住，循环到所有的任务结束。同时，先完成的任务会先返回给主线程。</p>
<h3 id="Pandas-read-csv"><a href="#Pandas-read-csv" class="headerlink" title="Pandas-read_csv"></a>Pandas-read_csv</h3><h4 id="read-csv函数"><a href="#read-csv函数" class="headerlink" title="read_csv函数"></a>read_csv函数</h4><p>默认: 从文件、URL、文件新对象中加载带有分隔符的数据，默认分隔符是逗号。</p>
<p>上述txt文档并没有逗号分隔，所以在读取的时候需要增加sep分隔符参数</p>
<p>参数说明，官方Source: <a target="_blank" rel="noopener" href="https://github.com/pandas-dev/pandas/blob/v0.24.0/pandas/io/parsers.py#L531-L697">https://github.com/pandas-dev/pandas/blob/v0.24.0/pandas/io/parsers.py#L531-L697</a></p>
<p><strong>中文说明以及重点功能案例</strong></p>
<hr>
<p> | <strong>参数</strong> | <strong>中文释义</strong><br>-|——–|———<br> | filepath_or_buffer | 可以是URL，可用URL类型包括：http, ftp, s3和文件，本地文件读取实例：file://localhost/path/to/table.csv<br> | sep | str类型，默认&#39;,&#39; 指定分隔符。如果不指定参数，则会尝试使用默认值逗号分隔。分隔符长于一个字符并且不是’\s+’,将使用python的语法分析器。并且忽略数据中的逗号。正则表达式例子：&#39;\r\t&#39;<br> | delimiter | 定界符，备选分隔符（如果指定该参数，则sep参数失效） 一般不用<br> | delimiter_whitespace | True or False 默认False, 用空格作为分隔符等价于spe=’\s+’如果该参数被调用，则delimite不会起作用<br> | header | 指定第几行作为列名(忽略注解行)，如果没有指定列名，默认header=0; 如果指定了列名header=None<br> | names | 指定列名，如果文件中不包含header的行，应该显性表示header=None ，header可以是一个整数的列表，如0,1,3。未指定的中间行将被删除(例如，跳过此示例中的2行)<br> | index_col(案例1) | 默认为None 用列名作为DataFrame的行标签，如果给出序列，则使用MultiIndex。如果读取某文件,该文件每行末尾都有带分隔符，考虑使用index_col=False使panadas不用第一列作为行的名称。<br> | usecols | 默认None 可以使用列序列也可以使用列名，如 0, 1, 2 or ‘foo’, ‘bar’, ‘baz’ ,使用这个参数可以加快加载速度并降低内存消耗。<br> | squeeze | 默认为False, True的情况下返回的类型为Series，如果数据经解析后仅含一行，则返回Series<br> | prefix | 自动生成的列名编号的前缀，如： ‘X’ for X0, X1, ... 当header =None 或者没有设置header的时候有效<br> | mangle_dupe_cols | 默认为True,重复的列将被指定为’X.0’…’X.N’，而不是’X’…’X’。如果传入False，当列中存在重复名称，则会导致数据被覆盖。<br> | dtype | 例子： {‘a’: np.float64, ‘b’: np.int32} 指定每一列的数据类型，a,b表示列名<br> | engine | 使用的分析引擎。可以选择C或者是python，C引擎快但是Python引擎功能更多一些<br> | converters(案例2) | 设置指定列的处理函数，可以用&quot;序号&quot;也可以使用”列名”进行列的指定<br> | true_values / false_values | 没有找到实际的应用场景，备注一下，后期完善<br> | skipinitialspace | 忽略分隔符后的空格,默认false<br> | skiprows | 默认值 None 需要忽略的行数（从文件开始处算起），或需要跳过的行号列表（从0开始）<br> | skipfooter | 从文件尾部开始忽略。 (c引擎不支持)<br> | nrows | 从文件中只读取多少数据行，需要读取的行数（从文件头开始算起）<br> | na_values | 空值定义，默认情况下, ‘#N/A’, ‘#N/A N/A’, ‘#NA’, ‘-1.#IND’, ‘-1.#QNAN’, ‘-NaN’, ‘-nan’, ‘1.#IND’, ‘1.#QNAN’, ‘N/A’, ‘NA’, ‘NULL’, ‘NaN’, ‘n/a’, ‘nan’, ‘null’. 都表现为NAN<br> | keep_default_na | 如果指定na_values参数，并且keep_default_na=False，那么默认的NaN将被覆盖，否则添加<br> | na_filter | 是否检查丢失值（空字符串或者是空值）。对于大文件来说数据集中没有N/A空值，使用na_filter=False可以提升读取速度。<br> | verbose | 是否打印各种解析器的输出信息，例如：”非数值列中缺失值的数量”等。<br> | skip_blank_lines | 如果为True，则跳过空行；否则记为NaN。<br> | parse_dates | 有如下的操作1. boolean. True -&gt; 解析索引2. list of ints or names. e.g. If 1, 2, 3 -&gt; 解析1,2,3列的值作为独立的日期列；3. list of lists. e.g. If [1, 3] -&gt; 合并1,3列作为一个日期列使用 4. dict, e.g. {‘foo’ : 1, 3} -&gt; 将1,3列合并，并给合并后的列起名为&quot;foo&quot;<br> | infer_datetime_format | 如果设定为True并且parse_dates 可用，那么pandas将尝试转换为日期类型，如果可以转换，转换方法并解析。在某些情况下会快5~10倍<br> | keep_date_col | 如果连接多列解析日期，则保持参与连接的列。默认为False<br> | date_parser | 用于解析日期的函数，默认使用dateutil.parser.parser来做转换。Pandas尝试使用三种不同的方式解析，如果遇到问题则使用下一种方式。1.使用一个或者多个arrays（由parse_dates指定）作为参数；2.连接指定多列字符串作为一个列作为参数；3.每行调用一次date_parser函数来解析一个或者多个字符串（由parse_dates指定）作为参数。<br> | dayfirst | DD/MM格式的日期类型<br> | iterator | 返回一个TextFileReader 对象，以便逐块处理文件。<br> | chunksize | 文件块的大小<br> | compression | 直接使用磁盘上的压缩文件。如果使用infer参数，则使用 gzip, bz2, zip或者解压文件名中以’.gz’, ‘.bz2’, ‘.zip’, or ‘xz’这些为后缀的文件，否则不解压。如果使用zip，那么ZIP包中国必须只包含一个文件。设置为None则不解压。<br> | 新版本0.18.1版本支持zip和xz解压 |  <br> | thousands | 千分位符号，默认’，’<br> | decimal | 小数点符号，默认’.’<br> | lineterminator | 行分割符，只在C解析器下使用<br> | quotechar | 引号，用作标识开始和解释的字符，引号内的分割符将被忽略<br> | quoting | 控制csv中的引号常量。可选 QUOTE_MINIMAL (0), QUOTE_ALL (1), QUOTE_NONNUMERIC (2) or QUOTE_NONE (3)<br> | doublequote | 双引号，当单引号已经被定义，并且quoting 参数不是QUOTE_NONE的时候，使用双引号表示引号内的元素作为一个元素使用。<br> | escapechar | 当quoting 为QUOTE_NONE时，指定一个字符使的不受分隔符限值。<br> | comment | 标识着多余的行不被解析。如果该字符出现在行首，这一行将被全部忽略。这个参数只能是一个字符，空行（就像skip_blank_lines=True）注释行被header和skiprows忽略一样。例如如果指定comment=&#39;#&#39; 解析’#empty\na,b,c\n1,2,3’ 以header=0 那么返回结果将是以’a,b,c&#39;作为header<br> | encoding | 编码方式，指定字符集类型，通常指定为&#39;utf-8&#39;<br> | dialect | 如果没有指定特定的语言，如果sep大于一个字符则忽略。具体查看csv.Dialect 文档<br> | error_bad_lines | 如果一行包含太多的列，那么默认不会返回DataFrame ，如果设置成false，那么会将改行剔除（只能在C解析器下使用）<br> | warn_bad_lines | 如果error_bad_lines =False，并且warn_bad_lines =True 那么所有的”bad lines”将会被输出（只能在C解析器下使用）<br> | low_memory | 分块加载到内存，再低内存消耗中解析。但是可能出现类型混淆。确保类型不被混淆需要设置为False。或者使用dtype 参数指定类型。注意使用chunksize 或者iterator 参数分块读入会将整个文件读入到一个Dataframe，而忽略类型（只能在C解析器中有效）<br> | delim_whitespace | New in version 0.18.1: Python解析器中有效<br> | memory_map | 如果为filepath_or_buffer提供了文件路径，则将文件对象直接映射到内存上，并直接从那里访问数据。使用此选项可以提高性能，因为不再有任何I / O开销，使用这种方式可以避免文件再次进行IO操作<br> | float_precision | 指定C引擎应用于浮点值的转换器</p>
<hr>
<p> </p>
<p>该表格部分参考博客 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/datablog/p/6127000.html">https://www.cnblogs.com/datablog/p/6127000.html</a> 感谢博主的翻译，O(∩_∩)O哈哈~</p>
<h3 id="pycallgraph-生成流程图-函数调用）"><a href="#pycallgraph-生成流程图-函数调用）" class="headerlink" title="pycallgraph 生成流程图(函数调用）"></a>pycallgraph 生成流程图(函数调用）</h3><p>方法1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pycallgraph <span class="keyword">import</span> PyCallGraph <span class="keyword">from</span> pycallgraph.output <span class="keyword">import</span></span><br><span class="line">GraphvizOutput</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> PyCallGraph(output=GraphvizOutput()):</span><br><span class="line"></span><br><span class="line">  \<span class="comment"># 需要绘制流程图的 代码，可以是函数 \# \... \...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pycallgraph graphviz \-- ./你需要生成流程图的.py文件</span><br><span class="line">注意：执行绘制，会执行代码</span><br></pre></td></tr></table></figure>
<p>参考文档<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010751000/article/details/106988825/?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase">https://blog.csdn.net/u010751000/article/details/106988825/?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase</a></p>
<h3 id="AutoCode-Python-绘制流程图"><a href="#AutoCode-Python-绘制流程图" class="headerlink" title="AutoCode-Python 绘制流程图"></a>AutoCode-Python 绘制流程图</h3><p>拥抱开源! 第一弹</p>
<p><a target="_blank" rel="noopener" href="https://github.com/fenglinyushu/autocode-python">https://github.com/fenglinyushu/autocode-python</a></p>
<p>绘制流程图, 自动生成python代码, 支持tkinter可视化编程</p>
<p>很多人不明白可以做什么用。这个项目（包括这个系列的其它项目）主要用于大型复杂项目的代码工作。</p>
<p>程序员在完成代码过程中，可能有很多的自由式发挥，这极大地提高了效率，也较好地完成了领导交给的工作。</p>
<p>其实潜在的问题是相应文档的同步完成，以及后续持续开发和维护的难度。</p>
<p>我是一个20年经验的程序员，有点太老了！：），算是有经验了。在间隔一段时间再看自己的代码时，往往也需要很多时间来理解和找回当时的思路。如果需要修改，会变得十分小心翼翼。</p>
<p>如果换一个人来维护，可能就会是传说中的的”屎山”了</p>
<p>采用AutoCode来完成代码主要就是为了解决上述问题，边绘制流程，边生成代码。这样代码完成时，流程文档也完成了。（AutoCode后续会支持导出到Word/Visio/SVG/BMP）。同时由于流程树节点每个节点都可以展开、合拢，</p>
<p>这样即可以合拢子节点，从而宏观在了解大段程序的基本框架，也可以展开子节点，查看具体的代码细节</p>
<h3 id="Crystal-FLOW"><a href="#Crystal-FLOW" class="headerlink" title="Crystal FLOW "></a>Crystal FLOW </h3><p>一款回顾和可视的从源代码中得到流程图的软件。并且支持C语言的语法高亮显示。 </p>
<p>针对c程序的：Crystal FLOW for C<br>针对c++程序的：Crystal FLOW for C++</p>
<p><a target="_blank" rel="noopener" href="https://www.sgvsarc.com/downloads.htm">https://www.sgvsarc.com/downloads.htm</a></p>
<h3 id="几款代码转流程图软件"><a href="#几款代码转流程图软件" class="headerlink" title="几款代码转流程图软件"></a>几款代码转流程图软件</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aademeng/articles/6905245.html">https://www.cnblogs.com/aademeng/articles/6905245.html</a></p>
<h3 id="我的TensorFlow-GPU-2-0升级之路"><a href="#我的TensorFlow-GPU-2-0升级之路" class="headerlink" title="我的TensorFlow-GPU 2.0升级之路"></a>我的TensorFlow-GPU 2.0升级之路</h3><p><a target="_blank" rel="noopener" href="http://www.feiguyunai.com/index.php/2020/01/05/python-dl-tf2-01/">http://www.feiguyunai.com/index.php/2020/01/05/python-dl-tf2-01/</a></p>
<h4 id="1-1环境分析"><a href="#1-1环境分析" class="headerlink" title="1.1环境分析"></a>1.1环境分析</h4><p>1、目标：升级到TensorFlow-GPU 2.0<br>2、原有环境:<br>Python3.6，TensorFlow-GPU 1.6，ubuntu16.04，GPU驱动为NVIDIA-SMI 387.26<br>3、“硬核”：<br>①如果要升级到TensorFlow-gpu 2.0,cuda 应该是10.+，而10.+，根据表1-1可知，GPU的Driver Version应该&gt;=410+,但我目前的Driver Version 387.26。<br>②TensorFlow支持Python3.7<br>4、在安装TensorFlow-gpu 2.0之前需要做的事情<br>①升级GPU Driver Version&gt;=410（最关键）<br>②安装Python3.7<br>③安装cuda 10<br>④安装TensorFlow-gpu 2.0</p>
<h4 id="1-2参考资料"><a href="#1-2参考资料" class="headerlink" title="1.2参考资料"></a>1.2参考资料</h4><p>以下这些参考资料在安装过程中可能需要。<br>1、如何查找GPU型号与Driver version之间的关系？<br>安装新的支持cuda10+的驱动，具体安装驱动程序，可登录：<br><a target="_blank" rel="noopener" href="https://www.nvidia.com/Download/Find.aspx?lang=en-us">https://www.nvidia.com/Download/Find.aspx?lang=en-us</a> 得到图1-1界面，输入对于GPU型号获取对于驱动程序。<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/6bf091c95bf2b6c46d7bbaef31d04e44.png" alt="img"><br>图1-1 GPU型号及产品系列兼容的Driver版本<br>2、安装GPU驱动有哪些常用方法？<br>安装GPU驱动有一些3种方法，前2种操作比较简单，第3种NVIDIA推荐的手动安装方法，定制比较高，但比较繁琐。<br>①使用标准Ubuntu仓库进行自动化安装<br>②使用PPA仓库进行自动化安装<br>③使用官方的NVIDIA驱动进行手动安装<br>3、如何查看当前内核？<br>安装过程中，可能会出现/boot目录空间问题，这些需要通过一些方法保证/boot空间，方法有删除一些非当前使用的内核或扩充/boot空间等方法。<br>①查看内核列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --get-selections |grep linux-image</span><br></pre></td></tr></table></figure>

<p>②查看当前使用的内核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p>③删除内核方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove linux-image-***-generic</span><br></pre></td></tr></table></figure>



<h4 id="1-3-安装的准备工作"><a href="#1-3-安装的准备工作" class="headerlink" title="1.3 安装的准备工作"></a>1.3 安装的准备工作</h4><p>1、查看显卡基本信息<br>通过命令nvidia-smi 查看显卡基本信息：<br>NVIDIA-SMI 387.26 Driver Version: 387.26<br>2、nvidia 驱动和cuda runtime 版本对应关系<br>查看nvidia官网：<br><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</a><br>表1-1 CUDA与其兼容的Driver版本<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/b2ae3c19f68043d2182359e3dbb45ce7.png" alt="img"><br>从上表可知，因我目前的GPU驱动版本为：Driver Version: 387.26，无法安装cudnn10+<br>需要升级GPU驱动。</p>
<h4 id="1-4-升级GPU驱动"><a href="#1-4-升级GPU驱动" class="headerlink" title="1.4 升级GPU驱动"></a>1.4 升级GPU驱动</h4><p>Ubuntu 社区建立了一个命名为 Graphics Drivers PPA 的全新 PPA，专门为 Ubuntu 用户提供最新版本的各种驱动程序，如Nvidia 驱动。因此我采用通过 PPA 为 Ubuntu 安装 Nvidia 驱动程序，即使用PPA仓库进行自动化安装。<br>1、卸载系统里的Nvidia低版本显卡驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge nvidia*</span><br></pre></td></tr></table></figure>

<p>2、把显卡驱动加入PPA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers</span><br></pre></td></tr></table></figure>

<p>3、更新apt-get</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>4、查找显卡驱动最新的版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>返回如下信息<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/be104797974d858ea0c3742be1735338.png" alt="img"><br>5、采用apt-get命令在终端安装GPU驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nvidia-418 nvidia-settings nvidia-prime</span><br></pre></td></tr></table></figure>

<p>6、重启系统并验证<br>（1）重启系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<p>（2）查看安装情况<br>在终端输入以下命令行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nvidia</span><br></pre></td></tr></table></figure>

<p>如果没有输出，则安装失败。成功安装会有如下类似信息。<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/c3c63320b27026a63cae1bd69bb1918a.png" alt="img"><br>（3）查看Ubuntu自带的nouveau驱动是否运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nvidia</span><br></pre></td></tr></table></figure>

<p>如果终端没有内容输出，则显卡驱动的安装成功！<br>（4）使用nvidia-smi查看GPU驱动是否正常<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/18567ee5d067de4a6300695527147702.png" alt="img"><br>至此，GPU驱动已成功安装，驱动版本为418，接下来就可安装TensorFlow、Pytorch等最新版本了！</p>
<h4 id="1-5安装Python3-7"><a href="#1-5安装Python3-7" class="headerlink" title="1.5安装Python3.7"></a>1.5安装Python3.7</h4><p>1、安装python3.7<br>因TensorFlow-GPU 2.0支持python3.7，故需删除python3.6，安装python3.7<br>（1）使用rm -rf 命令删除目录：anaconda3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf anaconda3</span><br></pre></td></tr></table></figure>

<p>（2）到anaconda官网下载最新的最新的anaconda3版本<br>登录：<a target="_blank" rel="noopener" href="https://www.anaconda.com/distribution/">https://www.anaconda.com/distribution/</a><br>得到如下界面：<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/6a75de955a7a79ab1a4aafbb44e50854.png" alt="img"><br>图1-2 下载anaconda界面<br>下载很快，506MB，5分钟左右就下载完成。<br>得到sh程序包：Anaconda3-2019.10-Linux-x86_64.sh<br>（3）安装python3.7<br>在命令行执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-2019.10-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>

<p>安装过程中，会有几个问题，一般回答yes即可：<br>第一个问题：<br>Do you accept the license terms? [yes|no]<br>选择yes<br>第二个问题：<br>Anaconda3 will now be installed into this location:<br>~/anaconda3</p>
<p>- Press ENTER to confirm the location<br>- Press CTRL-C to abort the installation<br>- Or specify a different location below<br>按回车ENTER即可<br>第三个问题：<br>Do you wish the installer to initialize Anaconda3<br>by running conda init? [yes|no]<br>选择yes将把Python安装目录，自动写入.bashrc文件<br>（4）使用命令conda list查看已安装的一些版本<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/1c5b0740cf105cd1ebc446303939841f.png" alt="img"></p>
<h4 id="1-6安装TensorFlow-GPU-2-0"><a href="#1-6安装TensorFlow-GPU-2-0" class="headerlink" title="1.6安装TensorFlow-GPU 2.0"></a>1.6安装TensorFlow-GPU 2.0</h4><p>如果使用conda安装TensorFlow-gpu 2.0，可用一个命令搞定，如果用pip安装需要3步。</p>
<h5 id="1-6-1-用conda安装"><a href="#1-6-1-用conda安装" class="headerlink" title="1.6.1 用conda安装"></a>1.6.1 用conda安装</h5><p>使用conda安装tensorflow-gpu时，它会自动下载依赖项，比如最重要的cuda和cudnn等，其中cuda将自动安装10版本。<br>①先查看能安装的TensorFlow包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search tensorflw</span><br></pre></td></tr></table></figure>

<p>②安装TensorFlow-GPU 2.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install tensorflow-gpu&#x3D;2.0.0</span><br></pre></td></tr></table></figure>



<h4 id="1-6-2用pip安装"><a href="#1-6-2用pip安装" class="headerlink" title="1.6.2用pip安装"></a>1.6.2用pip安装</h4><p>①先安装cudatoolkit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install cudatoolkit&#x3D;&#x3D;10.0</span><br></pre></td></tr></table></figure>

<p>②安装cudnn</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install cudnn</span><br></pre></td></tr></table></figure>

<p>③安装TensorFlow-gpu 2.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow-gpu&#x3D;&#x3D;2.0.0</span><br></pre></td></tr></table></figure>

<p>【说明】<br>①如果使用conda环境(如果只有一个Python版本，也可不使用conda环境)，创建环境时，采用conda create -n tf2 python=3.7，而不是之前版本的source create *。激活环境也是用conda activate tf2 。<br>②如果卸载需先卸载cudnn，然后再卸载cudatoolkit</p>
<h4 id="1-7-Jupyter-notebook的配置"><a href="#1-7-Jupyter-notebook的配置" class="headerlink" title="1.7 Jupyter notebook的配置"></a>1.7 Jupyter notebook的配置</h4><p>可参考《Python深度学习基于TensorFlow》的8.3小节。</p>
<h4 id="1-8-安装验证"><a href="#1-8-安装验证" class="headerlink" title="1.8 安装验证"></a>1.8 安装验证</h4><p>1、验证tensorflow安装是否成功<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/17e17da591ba443cb4c20969dd77bc81.png" alt="img"><br>说明tensorflow-gpu安装成功，而且gpu使用正常。</p>
<h4 id="1-9-TensorFlow一般方式处理实例"><a href="#1-9-TensorFlow一般方式处理实例" class="headerlink" title="1.9 TensorFlow一般方式处理实例"></a>1.9 TensorFlow一般方式处理实例</h4><p>1.9、1.10小节，都基于以MNIST数据集，数据预处理相同，模型也相同。1.9节采用keras的一般模型训练方法，1.10节采用分布式处理方法，比较两种方式的处理逻辑、性能及所用时间等指标。</p>
<h5 id="1-9-1导入需要的库"><a href="#1-9-1导入需要的库" class="headerlink" title="1.9.1导入需要的库"></a>1.9.1导入需要的库</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br></pre></td></tr></table></figure>



<h5 id="1-9-2导入数据"><a href="#1-9-2导入数据" class="headerlink" title="1.9.2导入数据"></a>1.9.2导入数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在Keras地自带数据集中导入所需的MNIST模块</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="comment">#加载数据到Keras</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br></pre></td></tr></table></figure>



<h5 id="1-9-3数据预处理"><a href="#1-9-3数据预处理" class="headerlink" title="1.9.3数据预处理"></a>1.9.3数据预处理</h5><p>（1）转换为4维数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_train = x_train.reshape(<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">x_test = x_test.reshape(<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>（2）获取通道信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义输入图像数据的行列信息</span></span><br><span class="line">img_rows, img_cols = <span class="number">28</span>, <span class="number">28</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#导入backend模块，使用函数image_data_format()获取通道位置信息</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">if</span> K.image_data_format() == <span class="string">&#x27;channels_first&#x27;</span>:</span><br><span class="line">    x_train = x_train.reshape(x_train.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">    x_test = x_test.reshape(x_test.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">    input_shape = (<span class="number">1</span>, img_rows, img_cols)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    x_train = x_train.reshape(x_train.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    x_test = x_test.reshape(x_test.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    input_shape = (img_rows, img_cols, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>（3）对数据进行缩放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x_train = x_train.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">x_test = x_test.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">x_train /= <span class="number">255</span></span><br><span class="line">x_test /= <span class="number">255</span></span><br></pre></td></tr></table></figure>

<p>（4）把标签数据转换为二值数据格式或one-hot格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用keras自带工具将标签数据转换成二值数据格式，以方便模型训练</span></span><br><span class="line"><span class="keyword">import</span> tensorflow.keras.utils <span class="keyword">as</span> utils</span><br><span class="line">y_train =utils.to_categorical(y_train, <span class="number">10</span>)</span><br><span class="line">y_test = utils.to_categorical(y_test, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>



<h5 id="1-9-4构建模型"><a href="#1-9-4构建模型" class="headerlink" title="1.9.4构建模型"></a>1.9.4构建模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()<span class="comment">#初始化序贯模型</span></span><br><span class="line">model.add(Conv2D(<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">                 activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                 input_shape=(<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))<span class="comment">#二维卷积层</span></span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))<span class="comment">#最大池化层</span></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>))<span class="comment">#二维卷积层</span></span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))<span class="comment">#最大池化层</span></span><br><span class="line">model.add(Flatten())<span class="comment">#Flatten层，把tensor转换成一维形式</span></span><br><span class="line">model.add(Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>))<span class="comment">#定义全连接层</span></span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))<span class="comment">#定义输出层</span></span><br><span class="line">model.summary()<span class="comment">#查看模型结构</span></span><br></pre></td></tr></table></figure>

<p>模型结构如下。<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/05105dfa7b24e44f746a22ac12a38ba5.png" alt="img"></p>
<h5 id="1-9-5编译模型"><a href="#1-9-5编译模型" class="headerlink" title="1.9.5编译模型"></a>1.9.5编译模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.keras <span class="keyword">as</span> keras</span><br><span class="line">model.compile(loss=keras.losses.categorical_crossentropy,</span><br><span class="line">              <span class="comment">#optimizer=keras.optimizers.Adadelta(),</span></span><br><span class="line">              optimizer=keras.optimizers.Adam(),</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure>



<h5 id="1-9-6训练模型"><a href="#1-9-6训练模型" class="headerlink" title="1.9.6训练模型"></a>1.9.6训练模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model.fit(x_train, y_train,</span><br><span class="line">          batch_size=<span class="number">128</span>,</span><br><span class="line">          epochs=<span class="number">12</span>,</span><br><span class="line">          verbose=<span class="number">1</span>,</span><br><span class="line">          validation_data=(x_test, y_test))</span><br></pre></td></tr></table></figure>

<p>运行结果如下。<br>Epoch 9/12<br>60000/60000 [==============================] - 5s 81us/sample - loss: 0.0133 - accuracy: 0.9958 - val_loss: 0.0259 - val_accuracy: 0.9915<br>Epoch 10/12<br>60000/60000 [==============================] - 5s 79us/sample - loss: 0.0101 - accuracy: 0.9969 - val_loss: 0.0264 - val_accuracy: 0.9916<br>Epoch 11/12<br>60000/60000 [==============================] - 5s 81us/sample - loss: 0.0083 - accuracy: 0.9973 - val_loss: 0.0338 - val_accuracy: 0.9892<br>Epoch 12/12<br>60000/60000 [==============================] - 5s 80us/sample - loss: 0.0082 - accuracy: 0.9973 - val_loss: 0.0308 - val_accuracy: 0.9910</p>
<h5 id="1-9-7-GPU的使用情况"><a href="#1-9-7-GPU的使用情况" class="headerlink" title="1.9.7 GPU的使用情况"></a>1.9.7 GPU的使用情况</h5><p><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/ec547c09a9c45985da87f4e94e26f49d.png" alt="img"></p>
<p>一般情况下，实际上只有一个GPU在使用，另一个几乎没有运行。</p>
<h4 id="1-10-TensorFlow分布式处理实例"><a href="#1-10-TensorFlow分布式处理实例" class="headerlink" title="1.10 TensorFlow分布式处理实例"></a>1.10 TensorFlow分布式处理实例</h4><h5 id="1-10-1概述"><a href="#1-10-1概述" class="headerlink" title="1.10.1概述"></a>1.10.1概述</h5><p>TensorFlow 2.0 开始支持更优的多 GPU 与分布式训练。Tensorflow的分布策略目前主要有四个Strategy：<br> MirroredStrategy<br> CentralStorageStrategy<br> MultiWorkerMirroredStrategy<br> ParameterServerStrategy<br>这里主要介绍第1种策略，即镜像策略（MirroredStrategy）。TensorFlow 2.0 在多 GPU 训练上是否更好了呢？是的，镜像策略用于单机多卡数据并行同步更新的情况，在每个GPU上保存一份模型副本，模型中的每个变量都镜像在所有副本中。这些变量一起形成一个名为MirroredVariable的概念变量。通过apply相同的更新，这些变量保持彼此同步。<br>镜像策略用了高效的All-reduce算法来实现设备之间变量的传递更新。默认情况下，它使用NVIDIA NCCL作为all-reduce实现。用户还可以在官方提供的其他几个选项之间进行选择。如图1-3所示。<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/2977ae3f86232a7a95c604e04247cb5d.png" alt="img"><br>图1-3 TensorFlow使用多GPU示意图<br>（1）假设你的机器上有2个GPU。<br>（2）在单机单GPU的训练中，数据是一个batch一个batch的训练。 在单机多GPU中，数据一次处理2个batch(假设是2个GPU训练）， 每个GPU处理一个batch的数据计算。<br>（3）变量，或者说参数，保存在CPU上。<br>（4）刚开始的时候数据由CPU分发给2个GPU， 在GPU上完成了计算，得到每个batch要更新的梯度。<br>（5）然后在CPU上收集完了2个GPU上的要更新的梯度， 计算一下平均梯度，然后更新参数。<br>（6）然后继续循环这个过程。</p>
<h5 id="1-10-2创建一个分发变量和图形的镜像策略"><a href="#1-10-2创建一个分发变量和图形的镜像策略" class="headerlink" title="1.10.2创建一个分发变量和图形的镜像策略"></a>1.10.2创建一个分发变量和图形的镜像策略</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strategy = tf.distribute.MirroredStrategy()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&#x27;Number of devices: &#123;&#125;&#x27;</span>.format(strategy.num_replicas_in_sync))</span><br><span class="line"><span class="comment">#训练脚本就会自动进行分布式训练。如果你只想用主机上的部分GPU训练</span></span><br><span class="line"><span class="comment">#strategy = tf.distribute.MirroredStrategy(devices=[&quot;/gpu:0&quot;, &quot;/gpu:1&quot;])</span></span><br></pre></td></tr></table></figure>



<h5 id="1-10-3定义批处理等变量"><a href="#1-10-3定义批处理等变量" class="headerlink" title="1.10.3定义批处理等变量"></a>1.10.3定义批处理等变量</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BUFFER_SIZE = len(x_train)</span><br><span class="line">BATCH_SIZE_PER_REPLICA = <span class="number">64</span></span><br><span class="line">GLOBAL_BATCH_SIZE = BATCH_SIZE_PER_REPLICA * strategy.num_replicas_in_sync</span><br><span class="line">EPOCHS = <span class="number">12</span></span><br></pre></td></tr></table></figure>



<h5 id="1-10-4创建数据集并进行分发"><a href="#1-10-4创建数据集并进行分发" class="headerlink" title="1.10.4创建数据集并进行分发"></a>1.10.4创建数据集并进行分发</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train)).shuffle(BUFFER_SIZE).batch(GLOBAL_BATCH_SIZE) </span><br><span class="line">test_dataset = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(GLOBAL_BATCH_SIZE) </span><br><span class="line"></span><br><span class="line">train_dist_dataset = strategy.experimental_distribute_dataset(train_dataset)</span><br><span class="line">test_dist_dataset = strategy.experimental_distribute_dataset(test_dataset)</span><br></pre></td></tr></table></figure>



<h5 id="1-10-5创建模型"><a href="#1-10-5创建模型" class="headerlink" title="1.10.5创建模型"></a>1.10.5创建模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_model</span>():</span></span><br><span class="line">  model = tf.keras.Sequential([</span><br><span class="line">      tf.keras.layers.Conv2D(<span class="number">32</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>,input_shape=(<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)),</span><br><span class="line">      tf.keras.layers.MaxPooling2D(),</span><br><span class="line">      tf.keras.layers.Conv2D(<span class="number">64</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">      tf.keras.layers.MaxPooling2D(),</span><br><span class="line">      tf.keras.layers.Flatten(),</span><br><span class="line">      tf.keras.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">      tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">    ])</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>



<h5 id="1-10-6创建存储检查点"><a href="#1-10-6创建存储检查点" class="headerlink" title="1.10.6创建存储检查点"></a>1.10.6创建存储检查点</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建检查点目录以存储检查点。</span></span><br><span class="line">checkpoint_dir = <span class="string">&#x27;./training_checkpoints&#x27;</span></span><br><span class="line">checkpoint_prefix = os.path.join(checkpoint_dir, <span class="string">&quot;ckpt&quot;</span>)</span><br></pre></td></tr></table></figure>



<h5 id="1-10-7定义损失函数"><a href="#1-10-7定义损失函数" class="headerlink" title="1.10.7定义损失函数"></a>1.10.7定义损失函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">  <span class="comment"># 将减少设置为“无”，以便我们可以在之后进行这个减少并除以全局批量大小。</span></span><br><span class="line">  loss_object = tf.keras.losses.CategoricalCrossentropy(</span><br><span class="line">      reduction=tf.keras.losses.Reduction.NONE)</span><br><span class="line">  <span class="comment"># 或者使用 loss_fn = tf.keras.losses.sparse_categorical_crossentropy</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compute_loss</span>(<span class="params">labels, predictions</span>):</span></span><br><span class="line">    per_example_loss = loss_object(labels, predictions)</span><br><span class="line">    <span class="keyword">return</span> tf.nn.compute_average_loss(per_example_loss, global_batch_size=GLOBAL_BATCH_SIZE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="1-10-8定义性能衡量指标"><a href="#1-10-8定义性能衡量指标" class="headerlink" title="1.10.8定义性能衡量指标"></a>1.10.8定义性能衡量指标</h5><p>如损失和准确性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">  test_loss = tf.keras.metrics.Mean(name=<span class="string">&#x27;test_loss&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">#train_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(</span></span><br><span class="line">  train_accuracy = tf.keras.metrics.CategoricalAccuracy(</span><br><span class="line">      name=<span class="string">&#x27;train_accuracy&#x27;</span>)</span><br><span class="line">  <span class="comment">#test_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(</span></span><br><span class="line">  test_accuracy = tf.keras.metrics.CategoricalAccuracy(</span><br><span class="line">      name=<span class="string">&#x27;test_accuracy&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h5 id="1-10-9训练模型"><a href="#1-10-9训练模型" class="headerlink" title="1.10.9训练模型"></a>1.10.9训练模型</h5><p>（1）定义优化器、计算损失值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必须在`strategy.scope`下创建模型和优化器。</span></span><br><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">  model = create_model()</span><br><span class="line"></span><br><span class="line">  optimizer = tf.keras.optimizers.Adam()</span><br><span class="line"></span><br><span class="line">  checkpoint = tf.train.Checkpoint(optimizer=optimizer, model=model)</span><br><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">train_step</span>(<span class="params">inputs</span>):</span></span><br><span class="line">    images, labels = inputs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">      predictions = model(images, training=<span class="literal">True</span>)</span><br><span class="line">      loss = compute_loss(labels, predictions)</span><br><span class="line"></span><br><span class="line">    gradients = tape.gradient(loss, model.trainable_variables)</span><br><span class="line">    optimizer.apply_gradients(zip(gradients, model.trainable_variables))</span><br><span class="line"></span><br><span class="line">    train_accuracy.update_state(labels, predictions)</span><br><span class="line">    <span class="keyword">return</span> loss </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_step</span>(<span class="params">inputs</span>):</span></span><br><span class="line">    images, labels = inputs</span><br><span class="line"></span><br><span class="line">    predictions = model(images, training=<span class="literal">False</span>)</span><br><span class="line">    t_loss = loss_object(labels, predictions)</span><br><span class="line"></span><br><span class="line">    test_loss.update_state(t_loss)</span><br><span class="line">    test_accuracy.update_state(labels, predictions)</span><br></pre></td></tr></table></figure>

<p>（2）训练模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">  <span class="comment"># `experimental_run_v2`将复制提供的计算并使用分布式输入运行它。</span></span><br><span class="line"><span class="meta">  @tf.function</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">distributed_train_step</span>(<span class="params">dataset_inputs</span>):</span></span><br><span class="line">    per_replica_losses = strategy.experimental_run_v2(train_step,</span><br><span class="line">                                                      args=(dataset_inputs,))</span><br><span class="line">    <span class="keyword">return</span> strategy.reduce(tf.distribute.ReduceOp.SUM, per_replica_losses,</span><br><span class="line">                           axis=<span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">  @tf.function</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">distributed_test_step</span>(<span class="params">dataset_inputs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> strategy.experimental_run_v2(test_step, args=(dataset_inputs,))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCHS):</span><br><span class="line">    <span class="comment"># 训练循环</span></span><br><span class="line">    total_loss = <span class="number">0.0</span></span><br><span class="line">    num_batches = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> train_dist_dataset:</span><br><span class="line">      total_loss += distributed_train_step(x)</span><br><span class="line">      num_batches += <span class="number">1</span></span><br><span class="line">    train_loss = total_loss / num_batches</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试循环</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> test_dist_dataset:</span><br><span class="line">      distributed_test_step(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">      checkpoint.save(checkpoint_prefix)</span><br><span class="line"></span><br><span class="line">    template = (<span class="string">&quot;Epoch &#123;&#125;, Loss: &#123;&#125;, Accuracy: &#123;&#125;, Test Loss: &#123;&#125;, &quot;</span></span><br><span class="line">                <span class="string">&quot;Test Accuracy: &#123;&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">print</span> (template.format(epoch+<span class="number">1</span>, train_loss,</span><br><span class="line">                           train_accuracy.result()*<span class="number">100</span>, test_loss.result(),</span><br><span class="line">                           test_accuracy.result()*<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果如下。<br>Epoch 9, Loss: 1.0668369213817641e-05, Accuracy: 99.91753387451172, Test Loss: 0.041710007935762405, Test Accuracy: 99.09666442871094<br>Epoch 10, Loss: 0.006528814323246479, Accuracy: 99.90166473388672, Test Loss: 0.04140192270278931, Test Accuracy: 99.10091400146484<br>Epoch 11, Loss: 0.001252010464668274, Accuracy: 99.90159606933594, Test Loss: 0.04158545285463333, Test Accuracy: 99.10043334960938<br>Epoch 12, Loss: 0.0014430719893425703, Accuracy: 99.90159606933594, Test Loss: 0.041613057255744934, Test Accuracy: 99.09874725341797</p>
<h5 id="1-10-10-GPU使用情况"><a href="#1-10-10-GPU使用情况" class="headerlink" title="1.10.10 GPU使用情况"></a>1.10.10 GPU使用情况</h5><p><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/797b572b521b401829704502f0ccef91.png" alt="img"></p>
<p>由此可知，采用分布式方式，两个GPU都得到充分使用。</p>
<h4 id="1-11-建议使用conda安装TensorFlow"><a href="#1-11-建议使用conda安装TensorFlow" class="headerlink" title="1.11 建议使用conda安装TensorFlow"></a>1.11 建议使用conda安装TensorFlow</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/46599887">https://zhuanlan.zhihu.com/p/46599887</a><br>使用 TensorFlow 开展机器学习工作的朋友，应该有不少是通过 pip 下载的 TensorFlow。但是近日机器学习专家 Michael Nguyen 大声疾呼：“为了性能起见，别再用 pip 下载 TensorFlow了！”，他强力建议的理由基于以下两点：<br>1、更快的CPU性能Conda TensorFlow 包利用了用于深度神经网络或 1.9.0 版本以上的 MKL-DNN 网络的英特尔 Math Kernel Library（MKL），这个库能让性能大幅提升。如下图所示：<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/b6e9e82bb2db90826e8ab9e31970e2f8.png" alt="img"><br>可以看到，相比 pip 安装，使用 Conda 安装后的性能足足提升了 8 倍。这对于仍然经常使用 CPU 训练的人来说，无疑帮助很大。我（Michael Nguyen——译者注）自己平时在把代码放到 GPU 驱动的机器之前，会先使用 CPU 机器跑一遍，使用 Conda 安装 TensorFlow 能大幅加快迭代速度。<br>MKL 库不仅能加快 TensorFlow 包的运行速度，也能提升其它一些广泛使用的程序库的速度，比如 Numpy、NumpyExr、Scikit-Learn。<br>2、简化 GPU 版的安装<br>Conda 安装会自动安装 CUDA 和 GPU 支持所需的 CuDNN 库，但 pip 安装需要你手动完成。大家都比较喜欢一步到位的吧，特别是下载很多个库的时候。<br>【说明】有些软件或版本使用conda安装可能找不到，这时需要使用pip安装，使用pip可以安装一些较新版本。</p>
<h4 id="1-12-安装PyTorch"><a href="#1-12-安装PyTorch" class="headerlink" title="1.12 安装PyTorch"></a>1.12 安装PyTorch</h4><p>1、登录PyTorch官网<br><a target="_blank" rel="noopener" href="https://pytorch.org/">https://pytorch.org/</a><br>2、选择安装配置<br><img src="http://www.feiguyunai.com/wp-content/uploads/2020/01/b1e672abf7d0db1d84a15af9beadd67d.png" alt="img"><br>3、用conda安装<br>复制执行语句到命令行，进行执行，如安装cpu版的PyTorch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision cpuonly -c pytorch</span><br></pre></td></tr></table></figure>

<p>如果这种方式无法执行，或下载很慢，可把-c pytorch去掉， -c参数指明了下载pytorch的通道，优先级比清华镜像更高<br>使用指定的源（如清华源）可以采用如下命令，这样安装速度应该快很多。<br>【说明】如果在windows下安装pytorch出现对xx路径没有权重问题时，在进入cmd时，右键选择用管理员身份安装，如图所示：</p>
<p><img src="http://www.feiguyunai.com/wp-content/uploads/2020/03/dfe1be6e04c31daf54f24e7d16ca15c8.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装cpu版本</span><br><span class="line">conda install pytorch torchvision cpuonly </span><br></pre></td></tr></table></figure>

<p>安装gpu conda 1010版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装gpu版本</span><br><span class="line">conda install pytorch torchvision cudatoolkit&#x3D;10.1</span><br></pre></td></tr></table></figure>

<p>4、使用pip安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#安装GPU最新版本</span><br><span class="line">pip install torch torchvision</span><br><span class="line">#安装CPU版本</span><br><span class="line">pip install torch&#x3D;&#x3D;1.4.0+cpu torchvision&#x3D;&#x3D;0.5.0+cpu -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;torch_stable.html</span><br></pre></td></tr></table></figure>

<p>5、验证安装是否成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">print(torch.__version__)</span><br><span class="line">print(torch.cuda.is_available())   #查看GPU是否可用</span><br></pre></td></tr></table></figure>



<h4 id="1-13-修改安装源"><a href="#1-13-修改安装源" class="headerlink" title="1.13 修改安装源"></a>1.13 修改安装源</h4><p>我们用pip或conda安装软件时，很慢甚至时常报连接失败等问题，出现这些情况，一般是下载的源是国外的网站。可以修改安装源来大大加速下载速度及其稳定性，以下介绍几种利用清华源的方法。<br>1、修改conda安装源<br>在用户当前目录下，创建.condarc文件，然后把以下内容放入该文件即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;pytorch&#x2F;</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br></pre></td></tr></table></figure>

<p>【说明】windows环境也是如此，如果没有.condarc文件，就创建。<br>2、修改pip安装源<br>为了和conda保持一致，选择还是清华的镜像源。步骤如下：<br>（1）修改 ~/.pip/pip.conf 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~&#x2F;.pip&#x2F;pip.conf</span><br></pre></td></tr></table></figure>

<p>【说明】如果是windows环境，在用户当前目录下，修改pip\pip.ini文件<br>没有就创建。<br>（2）添加源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host &#x3D; pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>



<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git命令交互式学习"><a href="#git命令交互式学习" class="headerlink" title="git命令交互式学习"></a>git命令交互式学习</h2><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014734886/article/details/79527710">https://blog.csdn.net/u014734886/article/details/79527710</a></p>
<p><a target="_blank" rel="noopener" href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p>
<p>示例：<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-17-19-cbcb88da5f3b55ab6a6bb41c1019e995-image15-1fbb47.png">{width=”5.540972222222222in”<br>height=”2.9277777777777776in”}</p>
<h2 id="Git-ssh-配置："><a href="#Git-ssh-配置：" class="headerlink" title="Git ssh 配置："></a>Git ssh 配置：</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anyefrozen/p/6379046.html">https://www.cnblogs.com/anyefrozen/p/6379046.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lqlqlq007/article/details/78983879">https://blog.csdn.net/lqlqlq007/article/details/78983879</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lilygg/article/details/97919376?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/lilygg/article/details/97919376?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/winneydd/article/details/99291797">https://blog.csdn.net/winneydd/article/details/99291797</a></p>
<h2 id="疑难"><a href="#疑难" class="headerlink" title="疑难"></a>疑难</h2><h3 id="Github如何上传超过100M的大文件"><a href="#Github如何上传超过100M的大文件" class="headerlink" title="Github如何上传超过100M的大文件"></a>Github如何上传超过100M的大文件</h3><p><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/48b558e3eea2697f38c09a98.html">https://jingyan.baidu.com/article/48b558e3eea2697f38c09a98.html</a></p>
<p>安装git - lfs到本机</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/05/18-05-51-79d11f189c72f852cb064dc6dc0668d8-image-20201205180543710-724945.png" alt="image-20201205180543710"> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<p>选择您希望Git LFS管理的文件类型（或直接编辑.gitattributes）。您可以随时配置其他文件扩展名。这一步成功后会生成一个gitattributes文件</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180715-2020-12-05-18-07-16.png" alt="学习笔记-20201205180715-2020-12-05-18-07-16"><br> 添加并commit gitattributes文件</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180740-2020-12-05-18-07-40.png" alt="学习笔记-20201205180740-2020-12-05-18-07-40"><br>然后再添加大文件到本地缓存区</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180754-2020-12-05-18-07-55.png" alt="学习笔记-20201205180754-2020-12-05-18-07-55"><br> 这里要注意一点：以上是官网步骤，我没这样走。如果你按照以上步骤走的话会还是会出现push fail(如下图)的情况，可参考我的解决办法。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180805-2020-12-05-18-08-06.png" alt="学习笔记-20201205180805-2020-12-05-18-08-06"></p>
<p>参考解决办法：</p>
<p>1-2步没变，第3步我是生成.gitattributes后 add并且commit并且把.gitattributes文件push到远程分支，合并完成后，然后再add并且commit然后再push这个大文件.</p>
<p>简单说，就是我先把这个.gitattributes跟踪文件提交上传到远程，再把大文件提交并上传到远程的，这个要注意顺序。</p>
<p>有的同学已经把大文件提交了，但是.gitattributes还没有提交，这种情况需要回滚版本，具体操作可以参考廖雪峰 - 版本回退</p>
<h3 id="git-lfs的使用"><a href="#git-lfs的使用" class="headerlink" title="git lfs的使用"></a>git lfs的使用</h3><p>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/mianbaoshu/p/10972254.html">https://www.cnblogs.com/mianbaoshu/p/10972254.html</a></p>
<h4 id="1-什么是git-lfs"><a href="#1-什么是git-lfs" class="headerlink" title="1.什么是git lfs"></a>1.什么是git lfs</h4><p>Git LFS（Large File Storage, 大文件存储）是可以把音乐、图片、视频等指定的任意文件存在 Git 仓库之外，而在 Git 仓库中用一个占用空间 1KB 不到的文本指针来代替的小工具。通过把大文件存储在 Git 仓库之外，可以减小 Git 仓库本身的体积，使克隆 Git 仓库的速度加快，也使得 Git 不会因为仓库中充满大文件而损失性能。</p>
<h4 id="2-优点是什么"><a href="#2-优点是什么" class="headerlink" title="2.优点是什么"></a>2.优点是什么</h4><p>git每次保存diff，一些大文件发生变化时，整个仓库就会增加很大的体积，导致clone和pull的数据量大增。对于<code>git lfs</code>来说，在使用<code>git lfs track</code>命令后，git push的时候，<code>git lfs</code>会截取要管理的大文件，并将其传至<code>git lfs</code>的服务器中，从而减小仓库的体积</p>
<h4 id="3-怎么安装"><a href="#3-怎么安装" class="headerlink" title="3.怎么安装"></a>3.怎么安装</h4><p>注意：git lfs 要求 git &gt;= 1.8.2</p>
<p>Linux</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br><span class="line"></span><br><span class="line">sudo apt-get install git-lfs</span><br><span class="line"></span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<p>Mac</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装HomeBrew /usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line">brew install git-lfs</span><br><span class="line"></span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<h4 id="4-怎么使用"><a href="#4-怎么使用" class="headerlink" title="4.怎么使用"></a>4.怎么使用</h4><ol>
<li><p>查看现有的文件追踪模式：<code>git lfs track</code></p>
</li>
<li><p>添加要管理的大文件的文件类型，比如gz文件</p>
</li>
</ol>
<p>运行命令：<code>git lfs track *.gz</code>添加类型后，查看管理文件.gitattributes，可以发现.gitattributes中新增加一行：<code>*.gz filter=lfs diff=lfs merge=lfs -text</code></p>
<ol start="3">
<li><p>将管理文件.gitattributes提交至仓库. 它保存了文件的追踪记录</p>
</li>
<li><p>获取git lfs管理的所有文件列表：git lfs ls-files </p>
</li>
<li><p>添加大文件到git仓库，和其它添加方式一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add my.gz</span><br><span class="line">git commit -m &quot;add gz file&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
</li>
<li><p>将代码 push 到远程仓库后，LFS 跟踪的文件会以『Git LFS』的形式显示:</p>
</li>
<li><p>clone 时 使用’git clone’ 或 <code>git lfs clone</code>均可</p>
</li>
<li><p>查看Git LFS 的帮助：git lfs help</p>
</li>
<li><p>下载被git lfs管理的文件</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git lfs fetch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lfs checkout</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lfs pull</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li>删除lfs里的文件</li>
</ol>
<p>如果需要删除lfs里的文件，需要在gitee后台操作，先到后台里查看文件的oid</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/13/09-43-36-1e86b868bb36524bef9ae76be9b53dd3-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RkZGQ2NjY2cXE=,size_16,color_FFFFFF,t_70-c7a109.png" alt="删除lfs"></p>
<p>然后在本地通过下面命令判断是否是能删除的文件，然后在后台操作删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --all -p -S 8a9c160e</span></span><br></pre></td></tr></table></figure>

<p><strong>删除文件后本地分支上传时可能的报错</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unable to find source for object a0ee616e6195bcb5f4136fb36b6b803566cec234f4468bda64e42a34a5f76697 (try running git lfs fetch --all)</span><br><span class="line">Uploading LFS objects:   0% (0/20), 0 B | 0 B/s, done.</span><br></pre></td></tr></table></figure>

<p>查了下这个文件是前面我删除的文件，我想要的结果是忽略这个文件接着上传，可以设置下面这个属性</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config lfs.allowincompletepush <span class="literal">true</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>git lfs track *<em>/</em>.zip 任意子目录的zip文件</p>
</blockquote>
<p><strong>参考文档</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/help/articles/4235#article-header0">Git LFS 操作指南</a></li>
</ul>
<h3 id="删除远程lfs大文件"><a href="#删除远程lfs大文件" class="headerlink" title="删除远程lfs大文件"></a>删除远程lfs大文件</h3><p>一些时候由于开发初期经验不足和贪图方便, 会把一些不应该提交到 Git 的文件上传到 Github, 带来一系列安全问题, 更有可能是把一些大文件上传到 GitHub 上, 导致项目非常臃肿, 每次 pull、push 都要花费很多时间.</p>
<p>这时候就可以寻求一些特殊的工具的帮助, <a target="_blank" rel="noopener" href="https://rtyley.github.io/bfg-repo-cleaner/">BFG Repo-Cleaner by rtyley </a>就是这样一款工具, 可以从 Git 项目中彻底删除某一个文件的历史记录.</p>
<p><strong>下载及运行</strong></p>
<p><a target="_blank" rel="noopener" href="https://rtyley.github.io/bfg-repo-cleaner/">BFG Repo-Cleaner </a>是由 Scala (一种JVM语言) 写成, 所以会被编译成 jar 包, 下载非常方便, 下载地址可在官网或直接点击 <a target="_blank" rel="noopener" href="https://search.maven.org/classic/remote_content?g=com.madgag&a=bfg&v=LATEST">bfg 下载地址 </a>.</p>
<p>但因此运行 <code>bfg.jar</code> 就需要 Java 环境, 关于 Java 环境的安装, macOS可以参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/imzhizi/p/macos-jdk-installation-homebrew.html">macOS 的 JDK 安装问题 </a>, 而 Windows 已经有很多人提过, 不做赘述.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用brew安装配置</span></span><br><span class="line">brew cask install oracle-jdk</span><br><span class="line">brew install bfg</span><br></pre></td></tr></table></figure>

<p><strong>让它完全消失</strong></p>
<ol>
<li>首先需要自行从项目中删除不想要的文件并提交, 这样能最大程度避免误删、误操作.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先需要自行从项目中删除不想要的文件</span></span><br><span class="line">rm file-to-delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交改动, 即最新分支是不包含要被删除的文件</span></span><br><span class="line">git commit -m <span class="string">&quot;删除 file-to-delete&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后使用 <code>--mirror</code> 命令裸克隆(clone)整个项目.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --mirror git@github.com:username/some-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据经验, 如果是包含大文件的项目, 使用 ssh 将会克隆的非常缓慢, 可以改用 https</span></span><br><span class="line">git <span class="built_in">clone</span> --mirror https://github.com/username/some-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候, 你的当前目录下就会产生一个名为 some-project.git 的文件夹</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接着开始删除文件历史.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据情况的不同, bfg 可选择根据文件大小删除</span></span><br><span class="line">java -jar bfg.jar --strip-blobs-bigger-than 100M some-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据情况的不同, bfg 可选择直接根据名字删除</span></span><br><span class="line">java -jar bfg.jar --delete-files name-of-file  some-project.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令中java -jar bfg.jar 可以用bfg代替</p>
</blockquote>
<ol start="4">
<li>任选以上命令执行其中一个后, 执行 <code>git gc</code> 真正删除这些文件并提交.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> some-project.git</span><br><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这时候那个文件就会消失了…</p>
<p>参考链接：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://rtyley.github.io/bfg-repo-cleaner/">https://rtyley.github.io/bfg-repo-cleaner/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/removing-sensitive-data-from-a-repository">git filter-branch：</a></p>
</li>
</ul>
<h3 id="git-clone大文件EOF错误"><a href="#git-clone大文件EOF错误" class="headerlink" title="git clone大文件EOF错误"></a>git clone大文件EOF错误</h3><p>我们常用的<code>git clone https://XXX </code>下载大文件时，加上墙的问题。会出现中断</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.com/xhang/gitlab.git</span><br><span class="line"></span><br><span class="line">正克隆到 &#x27;gitlab&#x27;...</span><br><span class="line"></span><br><span class="line">remote: Counting objects: 451995, done.</span><br><span class="line"></span><br><span class="line">remote: Compressing objects: 100% (96627/96627), done.</span><br><span class="line"></span><br><span class="line">fatal: The remote end hung up unexpectedlyB | 34.00 KiB/s</span><br><span class="line"></span><br><span class="line">fatal: 过早的文件结束符（EOF）</span><br><span class="line"></span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<p><strong>解决一：采用ssh方式</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@gitlab.com:xhang/gitlab.git</span><br></pre></td></tr></table></figure>

<p><strong>解决二：加大https缓存（推荐）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br><span class="line">git config http.postBuffer 524288000</span><br></pre></td></tr></table></figure>

<h3 id="如何控制git库的膨胀？"><a href="#如何控制git库的膨胀？" class="headerlink" title="如何控制git库的膨胀？"></a>如何控制git库的膨胀？</h3><p>根据 Git 的数据存储机制，只要通过命令 git add 将文件存储至暂存区，都会对版本库中的每一个文件，不论是图片、视频、源文件还是二进制文件生成相对应的 Blob 对象（即一段二进制数据。可以类比为<strong>url编码，</strong>通过加解码获得内容信息）。</p>
<p>如果你的项目中不小心打包进来了比较大的 word 文档或视频资源，Git 本身又识别不了该类型文件，只能当作二进制文件全量存储。所以，在其他人拉取该 word 文档更新完后再推远程分支的时候，则会使得 .git 下面的 objects 的文件夹大小迅速膨胀。</p>
<p><strong>注：如果是文本或代码等 Git 可以识别的文件，则只会存储有差异的文件。</strong></p>
<p>上面使用场景中表面上少了500M空间，实则增加了一次至少500M的历史提交记录，仓库容量反而变得更臃肿。</p>
<h3 id="如何精简你的-Git-仓库？"><a href="#如何精简你的-Git-仓库？" class="headerlink" title="如何精简你的 Git 仓库？"></a>如何精简你的 Git 仓库？</h3><p><strong>第一种方案：压缩 Git 仓库。</strong></p>
<p>例如，码云项目管理中会提供存储库 GC 功能，用于清理悬空文件，压缩存储库对象，减少存储库磁盘占用。</p>
<p><img src="https://pic1.zhimg.com/v2-fa1b0b20624cd7f8c31f2879e6c2820d_r.jpg?source=1940ef5c" alt="img"></p>
<p><strong>第二种方案（推荐）：删除大文件提交记录。</strong></p>
<p>查看存储库中的大文件：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all | grep -E `git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk &#x27;&#123;print$1&#125;&#x27; | sed &#x27;:a;N;$!ba;s/\n/|/g&#x27;`</span><br></pre></td></tr></table></figure>

<p>改写历史，去除大文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --tree-filter &#x27;rm -f path/to/large/files&#x27; --tag-name-filter cat -- --all</span><br><span class="line">git push origin --tags --force</span><br><span class="line">git push origin --all --force</span><br></pre></td></tr></table></figure>

<p>并告知所有组员，push 代码前需要 pull rebase，而不是 merge，否则会从该组员的本地仓库再次引入到远程库中。</p>
<h3 id="git-add详解"><a href="#git-add详解" class="headerlink" title="git add详解"></a>git add详解</h3><p> 一、前言<br>git add命令主要用于把我们要提交的文件的信息添加到索引库中。当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。</p>
<p>查看git add 内容 git status<br>二、基本<br><code>git add &lt;path&gt;</code>表示 add to index only files created or modified and not those deleted<br>我通常是通过<code>git add &lt;path&gt;</code>的形式把我们<code>&lt;path&gt;</code>添加到索引库中，<code>&lt;path&gt;</code>可以是文件也可以是目录。<br>git不仅能判断出<code>&lt;path&gt;</code>中，修改（不包括已删除）的文件，还能判断出新添的文件，并把它们的信息添加到索引库中。<br>三、<code>git add -u</code><br><code>git add -u </code> 表示 add to index only files modified or deleted and not those created<br><code>git add -u [&lt;path&gt;]</code>: 把<path>中所有tracked文件中被修改过或已删除文件的信息添加到索引库。它不会处理untracted的文件。<br>省略<path>表示.,即当前目录。<br>四、<code>git add -A</code><br><code>git add -A: [&lt;path&gt;]</code>表示把<path>中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。<br>省略<path>表示.,即当前目录。<br>五、<code>git add -i</code><br>我们可以通过<code>git add -i [&lt;path&gt;]命</code>令查看<path>中被所有修改过或已删除文件但没有提交的文件，<br>并通过其revert子命令可以查看<code>&lt;path&gt;</code>中所有untracted的文件，同时进入一个子命令系统。<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br><span class="line">     staged   unstaged path</span><br><span class="line">1:    +0&#x2F;-0   nothing branch&#x2F;t.txt</span><br><span class="line">2:    +0&#x2F;-0   nothing branch&#x2F;t2.txt</span><br><span class="line">3:  unchanged    +1&#x2F;-0 readme.txt</span><br></pre></td></tr></table></figure>

<p><strong>* Commands *</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: [s]tatus   2: [u]pdate   3: [r]evert   4: [a]dd untracked</span><br><span class="line">5: [p]atch   6: [d]iff    7: [q]uit    8: [h]elp</span><br></pre></td></tr></table></figure>
<p>What now&gt;<br>这里的t.txt和t2.txt表示已经被执行了git add，待提交。即已经添加到索引库中。<br>readme.txt表示已经处于tracked下，它被修改了，但是还没有被执行了git add。即还没添加到索引库中。<br>5.1、revert子命令<br>可以通过<code>git add -i</code>的revert子命令（3: <code>[r]evert</code>）把已经添加到索引库中的文件从索引库中剔除。<br>（<code>3: [r]evert</code>）表示通过3或r或revert加回车执行该命令。执行该命令后，git会例出索引库中的文件列表.<br>然后通过数字来选择。输入”1”表示git会例出索引库中的文件列表中的第1个文件。<br>“1-15”表示git会例出索引库中的文件列表中的第1个文件到第15个文件.回车将执行。<br>如果我们不输入任何东西，直接回车，将结束revert子命令，返回git add -i的主命令行。<br>5.2、update子命令<br>可以通过update子命令（2: <code>[u]pdate</code>）把已经tracked的文件添加到索引库中。其操作和revert子命令类似。<br>5.3、add untracked子命令<br>通过add untracked子命令（4: <code>[a]dd untracked</code>）可以把还没被git管理的文件添加到索引库中。其操作和revert子命令类似。<br>5.4、diff子命令<br>可以通过diff子命令（6: <code>[d]iff</code>）可以比较索引库中文件和原版本的差异。其操作和revert子命令类似。<br>5.5、status子命令<br>status子命令(1: <code>[s]tatus</code>)功能上和git add -i相似<br>5.6、quit子命令<br>quit子命令（7: <code>[q]uit</code>）用于退出git add -i命令系统<br>六、帮助<br>我们可以通过<code>git add -h</code>命令来看git add命令的帮助文档。</p>
<h3 id="git移除已经add的文件"><a href="#git移除已经add的文件" class="headerlink" title="git移除已经add的文件"></a>git移除已经add的文件</h3><p>使用 git rm 命令即可，有两种选择,<br>一种是 <code>git rm --cached</code> “文件路径”，不删除物理文件，仅将该文件从缓存中删除；<br>一种是 <code>git rm --f “文件路径”</code>，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。<br><code>[其他] </code>请问 <code>git rm --cache</code> 和 <code>git reset HEAD</code> 的区别到底在哪里呢？<br>如果要删除文件，最好用 <code>git rm file_name</code>，而不应该直接在工作区直接 <code>rm file_name</code>。<br>如果一个文件已经add到暂存区，还没有 commit，此时如果不想要这个文件了，有两种方法：<br>1，用版本库内容清空暂存区，<code>git reset HEAD</code> 但要慎重使用<br>2，只把特定文件从暂存区删除，<code>git rm --cached xxx</code></p>
<h3 id="提交忽略某些文件"><a href="#提交忽略某些文件" class="headerlink" title="提交忽略某些文件"></a>提交忽略某些文件</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mafeng/p/7635228.html">https://www.cnblogs.com/mafeng/p/7635228.html</a></p>
<h4 id="1-设置-gitignore"><a href="#1-设置-gitignore" class="headerlink" title="1.设置.gitignore"></a>1.设置.gitignore</h4><p>常用的规则：<br>1）/mtk/        过滤整个文件夹<br>2）*.zip         过滤所有.zip文件<br>3）/mtk/do.c     过滤某个具体文件</p>
<p>被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。<br>需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：<br>1）!*.zip<br>2）!/mtk/one.txt</p>
<p>唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。<br>为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么我们就需要使用：<br>1）/mtk/<br>2）!/mtk/one.txt<br>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</p>
<p>最后需要强调的一点是，<strong>如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用</strong>，Git仍然会对所有文件进行版本管理。<br>简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。因此一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦。</p>
<h4 id="2-使用命令"><a href="#2-使用命令" class="headerlink" title="2.使用命令"></a>2.使用命令</h4><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<br>正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。<br><code>git update-index --assume-unchanged FILE</code> 在FILE处输入要忽略的文件。<br>如果要还原的话，使用命令：<br><code>git update-index --no-assume-unchanged FILE</code></p>
<h4 id="3-使用-git-info-exclude"><a href="#3-使用-git-info-exclude" class="headerlink" title="3.使用.git/info/exclude"></a>3.使用.git/info/exclude</h4><p>git 还提供了另一种 exclude 的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去。用来保存的是公共的需要排除的文件。而 .git/info/exclude 这里设置的则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。</p>
<h3 id="git-clean清除未跟踪的文件"><a href="#git-clean清除未跟踪的文件" class="headerlink" title="git clean清除未跟踪的文件"></a>git clean清除未跟踪的文件</h3><p>有时做Build会引入很多之前没加入.gitignore的文件。这时你不可能每个目录每个文件地去删。<code>git clean -df </code>可帮你搞定一切。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clean -dn #这个命令可以看看有哪此文件和目录会被删</span><br><span class="line"></span><br><span class="line">git clean -f #只会删文件，不会删目录</span><br></pre></td></tr></table></figure>

<h3 id="git删除指定commit"><a href="#git删除指定commit" class="headerlink" title="git删除指定commit"></a>git删除指定commit</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lwcode6/p/11809973.html">https://www.cnblogs.com/lwcode6/p/11809973.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuluoxingkong/p/9835368.html">https://www.cnblogs.com/yuluoxingkong/p/9835368.html</a></p>
<p>或者采取以下方法</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lwcode6/p/11809973.html">https://www.cnblogs.com/lwcode6/p/11809973.html</a></p>
</blockquote>
<ol>
<li>使用<code>git log </code>命令，查看已提交的记录。例如红色圈出的commit是本次要删除的commit。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182720-2020-12-05-18-27-25.png" alt="学习笔记-20201205182720-2020-12-05-18-27-25"></p>
<ol start="2">
<li><p>先找到此次提交之前的一次提交的commit 1d6b81b138f89735265900b94fcd1ec39375e7b4</p>
</li>
<li><p>执行<code>git rebase -i 1d6b81b138f89735265900b94fcd1ec39375e7b4</code>，弹出如下页面（不包含当前commit）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182904-2020-12-05-18-29-14.png" alt="学习笔记-20201205182904-2020-12-05-18-29-14"></p>
<p>按字母I键进入编辑模式，将需要删除的commit的pick改为drop，然后按esc退出编辑，：wq保存<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183048-2020-12-05-18-30-50.png" alt="学习笔记-20201205183048-2020-12-05-18-30-50"></p>
<ol start="4">
<li>再次执行git log命令，查看已提交记录，之前红色圈出的commit记录已被删除<br> <img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183149-2020-12-05-18-31-52.png" alt="学习笔记-20201205183149-2020-12-05-18-31-52"></li>
</ol>
<h3 id="git删除指定commit-续"><a href="#git删除指定commit-续" class="headerlink" title="git删除指定commit-续"></a>git删除指定commit-续</h3><p><strong>一、删除文件</strong><br>如果需要删除的 commit 是一个或多个文件，可以进行以下操作。</p>
<ol>
<li>被提交到仓库的某个文件需要删除，可以使用 git rm 命令：<br><code>git rm &lt;file&gt; </code>// 从工作区和暂存区删除某个文件2. <code>git commit -m &quot;&quot;</code> // 再次提交到仓库<br>如果只想从暂存区删除文件，本地工作区不做出改变，可以：<br><code>git rm --cached &lt;file&gt;</code><br>如果在工作区不小心删错了某个文件，可以用 git checkout 将暂存区的文件覆盖工作区的文件，从而把误删的文件恢复：<br><code>git checkout -- &lt;file&gt;</code><br>用 <code>git rm </code>删除文件，同时还会将这个删除操作记录下来；<br>用 <code>rm 删除文件</code>，删除的仅仅是本地物理文件，没有将其从 git 的记录中剔除。</li>
<li><code>git add</code> 和 <code>git rm</code> 有相似的功能，<br>但 <code>git add</code> 仅能记录添加、改动的动作，删除的动作需靠 <code>git rm </code>来完成。</li>
</ol>
<p><strong>二、GitHub 删除某次 commit</strong><br>如果需要删除的不只是某个文件，而是交错的代码，那么有以下三种方法可以删除 commit 。</p>
<ul>
<li>git reset</li>
<li>git reset ：回滚到某次提交。</li>
<li>git reset –soft：此次提交之后的修改会被退回到暂存区。</li>
<li>git reset –hard：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的。<br>回滚代码</li>
</ul>
<p>如果需要删除的 commit 是最新的，那么可以通过 <code>git reset </code>命令将代码回滚到之前某次提交的状态，但一定要将现有的代码做好备份，否则回滚之后这些变动都会消失。具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;回滚代码</span><br><span class="line">git log &#x2F;&#x2F; 查询要回滚的 commit_id</span><br><span class="line">git reset --hard commit_id &#x2F;&#x2F; HEAD 就会指向此次的提交记录</span><br><span class="line">git push origin HEAD --force &#x2F;&#x2F; 强制推送到远端</span><br></pre></td></tr></table></figure>
<p>误删恢复</p>
<p>如果回滚代码之后发现复制错了 commit_id，或者误删了某次 commit 记录，也可以通过下方代码恢复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;误删恢复</span><br><span class="line">git relog &#x2F;&#x2F; 复制要恢复操作的前面的 hash 值</span><br><span class="line">git reset --hard hash &#x2F;&#x2F; 将 hash 换成要恢复的历史记录的 hash 值</span><br></pre></td></tr></table></figure>
<p>注意：删除中间某次提交时最好不要用<code> git reset</code> 回退远程库，因为之后其他人提交代码时用<code> git pull</code> 也会把自己的本地仓库回退到之前的版本，容易出现差错进而增加不必要的工作量。</p>
<h3 id="git-rebase-Vs-git-revert"><a href="#git-rebase-Vs-git-revert" class="headerlink" title="git rebase Vs git revert"></a>git rebase Vs git revert</h3><p>git rebase：当两个分支不在一条线上，需要执行 merge 操作时使用该命令。</p>
<p><strong>撤销提交</strong><br>如果中间的某次 commit 需要删除，可以通过 <code>git rebase </code>命令实现，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;撤销提交</span><br><span class="line">git log &#x2F;&#x2F; 1.查找要删除的前一次提交的 commit_id</span><br><span class="line">git rebase -i commit_id &#x2F;&#x2F; 2.将 commit_id 替换成复制的值</span><br><span class="line">&#x2F;&#x2F;3.进入 Vim 编辑模式将要删除的 commit 前面的 &#96;pick&#96; 改成 &#96;drop&#96;</span><br><span class="line">&#x2F;&#x2F;4.保存并退出 Vim</span><br></pre></td></tr></table></figure>
<p>这样就完成了。<br><strong>解决冲突</strong><br>该命令执行时极有可能出现 reabase 冲突，可以通过以下方法解决：</p>
<ol>
<li>git diff // 查看冲突内容</li>
<li>// 手动解决冲突（冲突位置已在文件中标明）</li>
<li>git add <file> 或 git add -A // 添加</li>
<li>git rebase –continu // 继续 rebase</li>
<li>// 若还在 rebase 状态，则重复 2、3、4，直至 rebase 完成出现 applying 字样</li>
<li>git push</li>
</ol>
<p><strong>git revert</strong></p>
<ul>
<li>git revert：放弃某次提交。</li>
<li>git revert 之前的提交仍会保留在 git log 中，而此次撤销会做为一次新的提交。</li>
<li>git revert -m：用于对 merge 节点的操作，-m 指定具体某个提交点。</li>
<li>*撤销提交**<br>要撤销中间某次提交时，使用 <code>git revert</code> 也是一个很好的选择：<ol>
<li>git log // 查找需要撤销的 commit_id</li>
<li>git revert commit_id  // 撤销这次提交<br>撤销 merge 节点提交 如果这次提交是 merge 节点的话，则需要加上 -m 指令：git revert commit_id -m 1 // 第一个提交点</li>
<li>// 手动解决冲突</li>
<li>git add -A</li>
<li>git commit -m “”</li>
<li>git revert commit_id -m 2 // 第二个提交点</li>
<li>// 重复 2，3，4</li>
<li>git push</li>
</ol>
</li>
</ul>
<p>原文链接：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c9f131e22a60">https://www.jianshu.com/p/c9f131e22a60</a></p>
<p><strong>附： git rebase</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41629756/article/details/100731258">https://blog.csdn.net/qq_41629756/article/details/100731258</a></p>
<ol>
<li><p>git log先找到需要变基(rebase)的Hash ID的下一个ID(不是本身Hash值)</p>
</li>
<li><p>git rebase -i (Hash ID) 此时会出现两种情况<br>1）工作区有变更尚未提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i 121f508bc4ac7044c1dda188fc595e7029613f22</span><br><span class="line">不能变基：您有未暂存的变更。</span><br><span class="line">而且您的索引中包含未提交的变更。</span><br><span class="line">请提交或贮藏修改。</span><br></pre></td></tr></table></figure>
<p>遇到这种情况需要将变更缓存，输入git stash 存储变更后再进行第二步操作<br>2）工作区无变更<br>此时直接往下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pick f60514c5 a</span><br><span class="line">pick e52ec2e0 b</span><br><span class="line">pick b2ee5bd4 c</span><br><span class="line">pick 1e3b1ed8 d</span><br><span class="line">pick ac231a7a e</span><br><span class="line">pick 1ddd77c2 f</span><br><span class="line">pick de41e172 g</span><br><span class="line">pick bab63064 h</span><br><span class="line">pick f898eacd i</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 变基 b0279a0c..f898eacd 到 b0279a0c（9 个提交）</span><br><span class="line">#</span><br><span class="line"># 命令:</span><br><span class="line"># p, pick &#x3D; 使用提交</span><br><span class="line"># r, reword &#x3D; 使用提交，但修改提交说明</span><br><span class="line"># e, edit &#x3D; 使用提交，但停止以便进行提交修补</span><br><span class="line"># s, squash &#x3D; 使用提交，但和前一个版本融合</span><br><span class="line"># f, fixup &#x3D; 类似于 &quot;squash&quot;，但丢弃提交说明日志</span><br><span class="line"># x, exec &#x3D; 使用 shell 运行命令（此行剩余部分）</span><br><span class="line"># d, drop &#x3D; 删除提交</span><br><span class="line">#</span><br><span class="line"># 这些行可以被重新排序；它们会被从上至下地执行。</span><br><span class="line">#</span><br><span class="line"># 如果您在这里删除一行，对应的提交将会丢失。</span><br><span class="line">#</span><br><span class="line"># 然而，如果您删除全部内容，变基操作将会终止。</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据提示，将pick改为适应需求的关键词即可</p>
</li>
<li><p>退出保存</p>
</li>
<li><p>输入 git stash pop 释放之前保存的缓存然后正常操作即可</p>
</li>
</ol>
<h3 id="如何删除Git上的远程文件夹"><a href="#如何删除Git上的远程文件夹" class="headerlink" title="如何删除Git上的远程文件夹"></a>如何删除Git上的远程文件夹</h3><p><strong>方法一</strong></p>
<p>这里以删除 test文件夹为案例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached test //--cached不会把本地的test删除</span><br><span class="line">git commit -m &#x27;delete test dir&#x27;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<p>如果误提交的文件夹比较多，方法一也较繁琐<br>直接修改.gitignore文件,将不需要的文件过滤掉，然后执行命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git push  -u origin master</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm -r -n --cached  */dirs/\*      #把dirs里的全部移除</span><br><span class="line"><span class="meta">#</span><span class="bash"> -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span></span><br></pre></td></tr></table></figure>

<h3 id="清空commits历史记录"><a href="#清空commits历史记录" class="headerlink" title="清空commits历史记录"></a>清空commits历史记录</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/magic-wei/p/9919277.html">https://www.cnblogs.com/magic-wei/p/9919277.html</a></p>
<p>git是当前最常见的版本控制工具，但出现以下情况时，往往需要清空commits历史记录：</p>
<ul>
<li>commits记录占用空间过大甚至远远超过版本控制文件本身大小，进行云端代码管理时会受制于空间限制，无法继续更新</li>
<li>历史记录中存在敏感信息，需要清理</li>
</ul>
<p>清理commits历史记录的核心思想是，直接删除本地的.git目录，重新建立git仓库并与远程仓库建立链接，采用强制提交的方式覆盖远程仓库的commits记录。下面是一段示例脚本。</p>
<p>参数说明：</p>
<ul>
<li>$REPO_DIR 表示需要处理的Git仓库本地目录</li>
<li><a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;">&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;</a>:xxxx/$REPO_DIR.git 表示远程仓库地址</li>
</ul>
<p>则可以按照如下步骤处理：</p>
<h4 id="进入本地仓库，删除-git目录"><a href="#进入本地仓库，删除-git目录" class="headerlink" title="进入本地仓库，删除.git目录"></a>进入本地仓库，删除.git目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$REPO_DIR</span></span><br><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure>

<h4 id="重新git初始化并添加commit"><a href="#重新git初始化并添加commit" class="headerlink" title="重新git初始化并添加commit"></a>重新git初始化并添加commit</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add . <span class="comment"># 重新添加所有的文件</span></span><br><span class="line">git commit -m <span class="string">&quot;restart git commit&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加远程仓库链接"><a href="#添加远程仓库链接" class="headerlink" title="添加远程仓库链接"></a>添加远程仓库链接</h4><p>在添加远程仓库时，需要设置远程仓库的代号，本教程记为<strong>origin</strong>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xxxx/<span class="variable">$REPO_DIR</span>.git</span><br></pre></td></tr></table></figure>

<p>此时，可以用<code>git remote -v</code>检查远程仓库的设置。</p>
<h4 id="强制提交，覆盖远程仓库的commits历史记录"><a href="#强制提交，覆盖远程仓库的commits历史记录" class="headerlink" title="强制提交，覆盖远程仓库的commits历史记录"></a>强制提交，覆盖远程仓库的commits历史记录</h4><p>假设提交到远程仓库的master分支，则强制提交脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master <span class="comment"># 或者 git push --force origin master</span></span><br></pre></td></tr></table></figure>

<p>强制提交之后，再看远程仓库master分支的commits记录就变成1了。</p>
<p>如果需要与上游保持同步检测，可以使用指令<code>--set-upstream origin/master</code>，即</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master --set-upstream origin/master <span class="comment"># 如果指向其他分支，可以修改为 origin/$&#123;指定分支名&#125;</span></span><br></pre></td></tr></table></figure>

<p>至此，大功告成～</p>
<h4 id="后续讨论"><a href="#后续讨论" class="headerlink" title="后续讨论"></a>后续讨论</h4><p>细心的朋友可能会发现，上述操作之后，如果你还记得历史记录中某个commit的链接，你仍然可以通过链接访问到该commit下的文件，甚至可以基于这个commit重新创建新分支。为什么会出现这种情况呢？这其实和Git本身的设计机制有关，主要是为了提高容错率，防止你因为一些误操作弄丢了某些commits进而造成无法挽回的结果。</p>
<p>实际上，这些commits并没有马上被清理掉，仅仅是你的所有分支或标签无法访问到它们，这些commits被称为unreachable commits. 它们通常会被缓存一段时间，这个周期默认是30天，你也可以通过git命令行手动修改缓存周期或者手动清理。由于Github也是建立在Git这个版本管理工具上的网站，所以它也有这个机制。虽然它们在缓存期内仍然可以被访问到，但你clone到本地并不会包含它们，也就是说，你并不能在本地删除Github上已经存在的unreachable commits，因为本地根本访问不到它们（<a target="_blank" rel="noopener" href="https://help.github.com/cn/github/committing-changes-to-your-project/commit-exists-on-github-but-not-in-my-local-clone">存在于 GitHub 上但不存在于本地克隆中的提交</a>）。如果不着急的话，你可以等30天之后再试试看是否还能访问这些unreachable commits的链接；但如果你很着急，你可以联系<a target="_blank" rel="noopener" href="https://support.github.com/">Github Support</a>帮你清理这些你不想保留的commits。</p>
<p>所以，如果你只是维护个人的文件仓库的话，不需要担心这个问题，你在新机器上clone下来的仍然是缩减大小之后的仓库，而Github上的unreachable commit会在缓存期后被清理掉。如果是与他人协作的仓库，还是谨慎使用<code>git push --force</code>这种危险的操作吧，确实遇到需要这个操作的场景时，考虑用更安全的<code>git push --force-with-lease</code>. 如果你强制提交之后发现后悔了，找到想恢复的commit的链接并创建新分支就可以找回那个commit所在历史分支之前的内容啦。</p>
<p>感谢@绿静風 发现了这个问题，促使我进一步查阅资料去完善这篇博文，在此表示感谢！</p>
<p>后续讨论的主要参考内容如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Internals-Maintenance-and-Data-Recovery">Git Internals - Maintenance and Data Recovery</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4367977/how-to-remove-a-dangling-commit-from-github">Stackoverflow - How to remove a dangling commit from GitHub?</a></li>
</ul>
<p>如果只是想删除历史记录中曾经存在（但现在并不需要）的大文件，可以参考这个Issue中的讨论：<a target="_blank" rel="noopener" href="https://github.com/18F/C2/issues/439">Consider cleaning up the .git folder to reduce the large repo size</a>git commit和git push的区别</p>
<p>git commit操作的是本地库，git push操作的是远程库。</p>
<ul>
<li>git commit是将本地修改过的文件提交到本地库中。</li>
<li>git push是将本地库中的最新信息发送给远程库。</li>
</ul>
<h3 id="创建分支branch和使用Pull-request"><a href="#创建分支branch和使用Pull-request" class="headerlink" title="创建分支branch和使用Pull request"></a>创建分支branch和使用Pull request</h3><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-03-e0c1cd706c9becd959756c6b89e22b5f-image17-61c157.png">{width=”6.052777777777778in”<br>height=”3.3958333333333335in”}<br>重点看一下base和compare，Pull request将compare的分支的更新发送给base的分支，如上图所示。点击”Create pull request”，然后填写发送Pull request的原因和描述，再点击点击”Create pull request”，完成发送。</p>
<h3 id="GitHub-实现多人协同提交代码并且权限分组管理"><a href="#GitHub-实现多人协同提交代码并且权限分组管理" class="headerlink" title="GitHub 实现多人协同提交代码并且权限分组管理"></a>GitHub 实现多人协同提交代码并且权限分组管理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34044273/article/details/86394095?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control">https://blog.csdn.net/weixin_34044273/article/details/86394095?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control</a></p>
<h3 id="Git多分支平行发展（一个仓库包含多个不同的项目）"><a href="#Git多分支平行发展（一个仓库包含多个不同的项目）" class="headerlink" title="Git多分支平行发展（一个仓库包含多个不同的项目）"></a>Git多分支平行发展（一个仓库包含多个不同的项目）</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015430066">https://segmentfault.com/a/1190000015430066</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015430066">https://segmentfault.com/a/1190000015430066</a></p>
<h3 id="Git中submodule的使用"><a href="#Git中submodule的使用" class="headerlink" title="Git中submodule的使用"></a>Git中submodule的使用</h3><p><strong>背景</strong></p>
<p>面对比较复杂的项目，我们有可能会将代码根据功能拆解成不同的子模块。主项目对子模块有依赖关系，却又并不关心子模块的内部开发流程细节。</p>
<p>这种情况下，通常不会把所有源码都放在同一个 Git 仓库中。</p>
<p>有一种比较简单的方式，是在当前工作目录下，将子模块文件夹加入到 .gitignore 文件内容中，这样主项目就能够无视子项目的存在。这样做有一个弊端就是，使用主项目的人需要有一个先验知识：需要在当前目录下放置一份某版本的子模块代码。</p>
<p>还有另外一种方式可供借鉴，可以使用 Git的 submodule 功能，也是这篇文章的主题。</p>
<p>实际上 Git<br>工具的 submodule 功能就是建立了当前项目与子模块之间的依赖关系：子模块路径、子模块的远程仓库、子模块的版本号。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87053283">https://zhuanlan.zhihu.com/p/87053283</a></p>
<h3 id="git-clone移动本地厂库"><a href="#git-clone移动本地厂库" class="headerlink" title="git clone移动本地厂库"></a>git clone移动本地厂库</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone d:/SourceRepository d:/DestinationRepository</span><br></pre></td></tr></table></figure>
<p>d:/SourceRepository:想克隆的本地仓库路径，<br>d:/DestinationRepository:想克隆去另一个地方的路径</p>
<p>例如 git clone d:/git e:/git11<br>是将d:/git的仓库（即包含隐藏文件.git的目录）克隆到 e:/git11目录下</p>
<p><img src="%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/image18.png">{width=”7.216666666666667in”<br>height=”1.74375in”}</p>
<h3 id="git裸克隆"><a href="#git裸克隆" class="headerlink" title="git裸克隆"></a>git裸克隆</h3><p>myIdea:<strong>尤其是克隆含有超大文件的仓库时，由于工作区含有大文件的缓存，故要用<code>git clone --mirror</code></strong> 以下为–mirror后的：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/19/14-11-24-7826e183aae6d0792ba5986fe94e25ef-image-20201219140957470-2e54dc.png" alt="image-20201219140957470"></p>
<p>用法1：<code>git clone &lt;repository&gt; &lt;directory&gt;</code></p>
<p>将<code>&lt;repository&gt;</code>指向的版本库创建一个克隆到<code>&lt;directory&gt;</code>目录。目录<code>&lt;directory&gt;</code>相当于克隆版本库的工作区，文件都会检出，版本库位于工作区的.git目录中</p>
<p>用法2：<code>git clone --bare &lt;repository&gt; &lt;directory.git&gt;</code></p>
<p>用法3：<code>git clone --mirror &lt;repository&gt; &lt;directory.git&gt;</code></p>
<p>用法2和用法3创建的克隆版本库都不包含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。一般约定俗成裸版本库的目录名以.git做后缀，所以上面示例中将克隆出来的裸版本库目录名写作&lt;directory.git&gt;。区别在于用法3克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用git fetch命令和上游版本库进行持续同步。</p>
<p>不使用–bare或–mirror创建出来的克隆包含工作区，这样就会产生两个包含工作区的版本库，这两个版本库对等。这两个工作区本质上没有区别，往往提交在一个版本A中进行，另一个B作为备份。只能从B执行git pull命令从A中拉回新的提交实现版本库同步，而不能从版本库A向版本库B执行git push推送操作</p>
<p>还可以通过git init的方式创建裸版本库，需要加–bare参数。</p>
<p>当执行git push命令时，如果没有设定推送的分支，而且当前分支也没有注册到远程的某个分支，将检查远程分支是否有和本地相同的分支名（如master），如果有，则推送，否则报错。</p>
<h3 id="git-pull和git-fetch的区别"><a href="#git-pull和git-fetch的区别" class="headerlink" title="git pull和git fetch的区别"></a>git pull和git fetch的区别</h3><p><strong>前言</strong></p>
<p>在我们使用git的时候用的更新代码是git fetch，git<br>pull这两条指令。但是有没有小伙伴去思考过这两者的区别呢？有经验的人总是说最好用git<br>fetch+git merge，不建议用git pull。也有人说git pull=git fetch+git<br>merge，真的是这样吗？为什么呢？既然如此为什么git还要提供这两种方式呢？</p>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41975655/article/details/82887273">https://blog.csdn.net/weixin_41975655/article/details/82887273</a></li>
</ul>
<h3 id="fatal-does-not-appear-to-a-git-repository"><a href="#fatal-does-not-appear-to-a-git-repository" class="headerlink" title="fatal: does not appear to a git repository"></a>fatal: does not appear to a git repository</h3><p>几周没用git，今天一来托管就报错，下面记录一下解决办法。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git push <span class="literal">-u</span> origin master</span><br><span class="line">fatal: <span class="string">&#x27;git@github.com/zejun_web&#x27;</span> does not appear to be a git repository</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<p>这是报错信息，建立了文件夹用了</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>后，也remote了，结果就是push不上去。</p>
<p>后面检查了一下remote内容</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git remote <span class="literal">-v</span></span><br><span class="line">origin  git@github.com/zejun_web (fetch)</span><br><span class="line">origin  git@github.com/zejun_web (push)</span><br></pre></td></tr></table></figure>
<p>敢情是remote命令就错了，里面少了git账号:git-ze,应该是：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:git<span class="literal">-ze</span>/zejun_web.git</span><br></pre></td></tr></table></figure>

<p>这样就知道怎么解决了，<br>先remove掉添加在远程的origin</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></table></figure>

<p>此时再用</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>就会发现没有origin了</p>
<p>再正确输入</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:git<span class="literal">-ze</span>/xxxx.git</span><br></pre></td></tr></table></figure>

<p>就可以了。</p>
<p>然后</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git push <span class="literal">-u</span> origin master</span><br><span class="line">Enumerating objects: <span class="number">7</span>, done.</span><br><span class="line">Counting objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up to 8 threads</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), <span class="number">545</span> bytes | <span class="number">272.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">7</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: Resolving deltas: <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), done.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">&#x27;master&#x27;</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/git<span class="literal">-ze</span>/zejun_web/pull/new/master</span><br><span class="line">remote:</span><br><span class="line">To github.com:git<span class="literal">-ze</span>/zejun_web.git</span><br><span class="line"> * [<span class="type">new</span> <span class="type">branch</span>]      master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里就成功啦。<br>网上查了一下还有的说要重新配置邮箱和姓名等信息的。。如果没有添加公钥的话确实还是要先在GitHub上添加公钥，如果已经添加过了，可以先用git remote<br>-v命令来检查一下添加的origin是不是代码写错了，写少了。</p>
<p>如果错了就先 git remote rm origin<br>然后最后就可以push了。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-23-2e2011e3bb51a81ccbaa15e5a905487e-image19-b07eeb.png">{width=”7.141666666666667in”<br>height=”2.248611111111111in”}</p>
<blockquote>
<p>要注意的就是第一次push的话，要加上 -u<br>在语句里，把本地master分支和远程库的master分支关联起来。</p>
</blockquote>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/python_neophyte/article/details/83381936">https://blog.csdn.net/python_neophyte/article/details/83381936</a></li>
</ul>
<h3 id="git-fork与clone有什么区别及使用场景"><a href="#git-fork与clone有什么区别及使用场景" class="headerlink" title="git fork与clone有什么区别及使用场景"></a>git fork与clone有什么区别及使用场景</h3><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><p>git clone xx 是我们比较熟悉的操作,它类似于Download功能，可以理解为将云端代码下载到我们自己电脑的本地。</p>
<p>正常的话需要我们本机安装了git，然后使用git clone [仓库地址]<br>即可将制定仓库地址代码下载到我们本机。</p>
<h4 id="git-fork"><a href="#git-fork" class="headerlink" title="git fork"></a>git fork</h4><p>我们在github上打开别人的项目，右上角会有一个fork及fork的人数。如下图：</p>
<ul>
<li><p>watch</p>
<p>就类似于关注，后续项目有任何更新都会通知你，如果设置了邮件还会邮件通知。觉得比较好的项目可以通过star进行收藏，并且收藏的同时也点了一个赞，在github中，star越多的项目肯定是越牛逼的项目了。这个也是很多面试官比较在意的，你有没有github开源项目？star多少？就是指这个了</p>
</li>
<li><p>fork<br>就是我们要讲的，我们将开源项目存储到我们自己的云端作为一个分支，我们可以进行一些bug修复或功能修改然后git pull到开源项目，如果开源项目认可，可以将你的修改合并到他们的分支。</p>
</li>
</ul>
<p>根据上面的描述大约可以知道fork的作用了。我们fork完之后，代码存储到了云端并没有下载到本地。</p>
<p>fork之后我们可以通过github账号的repositories 里找到</p>
<p><strong>两者适用场景</strong></p>
<p>Git可以多人协作完成项目，或者我写完一个项目可以开源到GitHub上，看到的小伙伴fork我的代码之后发现有BUG或者有一个地方有更好的算法可以解决，他可以在他自己的仓库里面修改源码，修改好之后他可以pull request，这样我就可以看到什么地方修改了，如果我觉得他的算法可行就可以把他的代码Merge到我的项目里面，简单说就帮我修复bug了，不用我自己动手。</p>
<p>git clone 就是他们clone到本地进行修改，然后他可以提交到clone的源码中。</p>
<h3 id="git-推送本地分支到远程分支-git-push-origin"><a href="#git-推送本地分支到远程分支-git-push-origin" class="headerlink" title="git 推送本地分支到远程分支 git push origin"></a>git 推送本地分支到远程分支 git push origin</h3><p>推送本地分支local_branch到远程分支 remote_branch并建立关联关系</p>
<p>a.远程已有remote_branch分支并且已经关联本地分支local_branch且本地已经切换到local_branch</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<p> b.远程已有remote_branch分支但未关联本地分支local_branch且本地已经切换到local_branch</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="literal">-u</span> origin/remote_branch</span><br></pre></td></tr></table></figure>
<p>c.远程没有remote_branch分支并，本地已经切换到local_branch</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin local_branch:remote_branch</span><br></pre></td></tr></table></figure>

<h3 id="git-remote关联了两个或多个仓库"><a href="#git-remote关联了两个或多个仓库" class="headerlink" title="git remote关联了两个或多个仓库"></a>git remote关联了两个或多个仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看远程仓库的数量（简单信息）</span></span><br><span class="line">git remote -v</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个远程仓库的具体信息，以origin为例：</span></span><br><span class="line">git remote show origin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如关联两个仓库: github 和码云</span></span><br><span class="line"> </span><br><span class="line">git remote add origin github-url</span><br><span class="line"> </span><br><span class="line">git remote add gitee gitee-url</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支有两个：master ，test-branch</span></span><br></pre></td></tr></table></figure>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41287260/article/details/89743120">https://blog.csdn.net/weixin_41287260/article/details/89743120</a></li>
</ul>
<h3 id="git-add外部文件"><a href="#git-add外部文件" class="headerlink" title="git add外部文件"></a>git add外部文件</h3><p>需要把外部文件复制到仓库目录下：<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-44-729f65c734788aa782d054c4bded528d-image20-dee2cb.png">{width=”8.770833333333334in”<br>height=”2.45625in”}</p>
<h3 id="git-add-文件"><a href="#git-add-文件" class="headerlink" title="git add 文件"></a>git add 文件</h3><p>方法一 git add 添加多个文件，文件之间以空格隔开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add file1 file2 file3</span><br></pre></td></tr></table></figure>

<p>方法二 多次git add</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add file1</span><br><span class="line"></span><br><span class="line">git add file2</span><br><span class="line"></span><br><span class="line">git add file2</span><br></pre></td></tr></table></figure>

<p>方法三 添加指定目录下的文件<br>config目录下及子目录下所有文件，home目录下的所有.php文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config/*</span><br><span class="line"></span><br><span class="line">git home/*.php</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法四 git add . 添加所有的文件， 或者 git add --all 添加所有的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git add --all</span><br></pre></td></tr></table></figure>
<p>方法五 添加所有子目录(**/)下的所有.zip文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add **/*.zip </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="git-commit-提交到版本库"><a href="#git-commit-提交到版本库" class="headerlink" title="git commit 提交到版本库"></a>git commit 提交到版本库</h3><p>git add 目的是将修改文件由工作区提交到暂存区，可以多次提交<br>然后commit操作，将文件从暂存区提交到版本库</p>
<p>git commit -m &quot;add new file&quot;</p>
<h2 id="git-廖雪峰学习文档"><a href="#git-廖雪峰学习文档" class="headerlink" title="git 廖雪峰学习文档"></a>git 廖雪峰学习文档</h2><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p>先来看名词解释。</p>
<h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：<img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-30-06-2012268feac886848fd1c027c8329c5d--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-f0ea7f.png" alt="working-dir"></p>
<h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p>![fix-dir/picgo/2020/12/05/15-31-02-2e3cb2afdce6d50a15657719069c4490–Users-foo-Library-Application Support-picgo-20201205153102-c90487](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/05/15-31-02-2e3cb2afdce6d50a15657719069c4490--Users-foo-Library-Application">https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/05/15-31-02-2e3cb2afdce6d50a15657719069c4490--Users-foo-Library-Application</a> Support-picgo-20201205153102-c90487.png)</p>
<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure>

<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>
<p>先用<code>git status</code>查看一下状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   LICENSE</span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>现在，暂存区的状态就变成这样了：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-07-3140921b12cc7d9a949076b2bb80d637--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-ec896c.jpeg" alt="git-stage"></p>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;understand how stage works&quot;</span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>

<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-41-f6ddf40f921f9953b6f84d107a11f689--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-20201205153241447-d86c8b.jpeg" alt="git-stage-after-commit"></p>
<p>git-stage视频：</p>
<p><video id="video" controls="" preload="none" poster="http://media.w3.org/2010/05/sintel/poster.png">   <source id="mp4" src="https://www.bilibili.com/video/av51227250?zw " type="video/mp4"> </video></p>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576">https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576</a></li>
</ul>
<blockquote>
<p>他人整理如下： <a target="_blank" rel="noopener" href="https://blog.csdn.net/u014734886/article/details/79527710">https://blog.csdn.net/u014734886/article/details/79527710</a></p>
</blockquote>
<h2 id="一、git初始化本地仓库和配置"><a href="#一、git初始化本地仓库和配置" class="headerlink" title="一、git初始化本地仓库和配置"></a>一、git初始化本地仓库和配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;想输入到文件的内容，一般为# 库名字&quot; &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>如果没有配置需要配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;abc@bupt.edu.cn&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;xy&quot;</span><br><span class="line"></span><br><span class="line">git config --list</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以配置git显示颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置别名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status 使用git st 代替 git status</span><br><span class="line"></span><br><span class="line">git config --global alias.co checkout 使用git co 代替 git checkout</span><br><span class="line"></span><br><span class="line">git config --global alias.ci commit 使用git ci 代替 git commit</span><br><span class="line"></span><br><span class="line">git config --global alias.br branch 使用git br 代替 git branch</span><br></pre></td></tr></table></figure>

<p>有人丧心病狂地把lg配置成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph</span><br><span class="line">--pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)</span><br><span class="line">%C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二、提交文件"><a href="#二、提交文件" class="headerlink" title="二、提交文件"></a>二、提交文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git status  查看当前仓库的状态</span><br><span class="line"></span><br><span class="line">git diff file_name</span><br><span class="line"></span><br><span class="line">git add file2.txt file3.txt 想添加所有的文件git add .</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git commit -m &quot;提交记录文字&quot;</span><br><span class="line"></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Fixes bug&quot;</span><br></pre></td></tr></table></figure>

<p>如果发现commit信息写错了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &quot;Fixes bug #42&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三、回退"><a href="#三、回退" class="headerlink" title="三、回退"></a>三、回退</h2><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205155858-2020-12-05-15-58-59.png" alt="学习笔记-20201205155858-2020-12-05-15-58-59"></p>
<h3 id="1-查看commit信息和命令信息"><a href="#1-查看commit信息和命令信息" class="headerlink" title="1.查看commit信息和命令信息"></a>1.查看commit信息和命令信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log（查看当前状态下的commit信息，不能查看以后的信息）</span><br><span class="line"></span><br><span class="line">git reflog（查看所有的命令信息）</span><br><span class="line"></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">git log -p --graph</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/98c473fb0ee2">https://www.jianshu.com/p/98c473fb0ee2</a></p>
<p>通过 git pull更新后，会显示别人修改了哪些文件。此时你想要查看某个文件的具体修改的内容，可通过下面的命令去查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log -p   + 文件名 （可查看该文件以前每一次push的修改内容）</span><br><span class="line">git log - p -1   + 文件名 （只查看该文件当前这一次的push内容）</span><br><span class="line"></span><br><span class="line">git log --graph 看到分支合并图</span><br><span class="line"></span><br><span class="line">git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-回退"><a href="#2-回退" class="headerlink" title="2.回退"></a>2.回退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id </span><br></pre></td></tr></table></figure>
<p>除了–hard参数外，还有–soft，–mixed。</p>
<p><strong>下面详细介绍这三个参数：</strong></p>
<ul>
<li><p>add表示add操作之后的结果</p>
</li>
<li><p>commit表示commit之后的结果</p>
</li>
<li><p>push:表示进行push操作之后的结果</p>
</li>
<li><p>(stash)表示在add前可能存在stash操作（即暂存工作区的操作）</p>
</li>
</ul>
<p>假设某次提交过程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init--(stash1)--add1--commit1--push1--(stash2)--add2--commit2--push2--(stash3)--add3--commit3--push3</span><br></pre></td></tr></table></figure>
<p>举例</p>
<ul>
<li><p>–hard<br>回退到某个版本commit之前的状态，进行1，2，3操作。如现在在commit2，或者add2，可以回到commit3或者commit1</p>
</li>
<li><p>–soft<br>回退到某次commit前的stage状态（即处于暂存状态），进行1操作。如现在在commit2，可以回到add1，或者add3</p>
</li>
<li><p>–mixed<br>回退到add前的状态（即处于工作区，如果有stash，需通过stash pop之后才能真的回到暂存的状态），执行1，2操作。<br>如现在在commit2，可以回退到init–(stash1)，或者commit1-push1–(stash2)，或者</p>
</li>
</ul>
<h3 id="3-HEAD介绍"><a href="#3-HEAD介绍" class="headerlink" title="3.HEAD介绍"></a>3.HEAD介绍</h3><p>HEAD指向的版本就是当前版本，<code>HEAD^</code>,前一个版本，<code>HEAD^^</code>前两个，<code>HEAD~100</code>，前100个版本</p>
<h3 id="4-查看远程log"><a href="#4-查看远程log" class="headerlink" title="4.查看远程log"></a>4.查看远程log</h3><p><code>git fetch --all </code>可以把远程的commit信息拉到本地更新到本部版本库的master<br>HEAD指针上，然后利用<code>git log</code>和<code>git reflog</code>进行查看操作</p>
<p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本，也可以用git reflog。</p>
<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<p>建议都用<code>git reflog</code></p>
<h2 id="四、切换暂存区、工作区"><a href="#四、切换暂存区、工作区" class="headerlink" title="四、切换暂存区、工作区"></a>四、切换暂存区、工作区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git stash   #暂存工作现场</span><br><span class="line"></span><br><span class="line">git stash list #会出现stash@&#123;0&#125;: WIP on dev: 6224937 add mergegit</span><br><span class="line"></span><br><span class="line">git stash pop #将暂存区的环境恢复到工作区</span><br><span class="line"></span><br><span class="line">git stash list  #此时暂存区已经没有数据了</span><br><span class="line"></span><br><span class="line">git diff HEAD -- readme.txt 查看工作区和版本库里面最新版本的区别</span><br><span class="line"></span><br><span class="line">git checkout -- readme.txt</span><br><span class="line">把工作区的修改全部撤销,其中--不能省，否则就变成切换分支了。</span><br><span class="line"></span><br><span class="line">git reset HEAD file_name</span><br><span class="line">可以把暂存区的修改撤销掉（unstage），重新放回工作区</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于git checkout可以看一下这篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuyuecs/p/7111749.html">https://www.cnblogs.com/kuyuecs/p/7111749.html</a></p>
</blockquote>
<p><strong>checkout命令用法如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">git checkout [-q] [&lt;commit&gt;] [--] &lt;paths&gt; ...</span><br><span class="line">#2</span><br><span class="line">git checkout [&lt;branch&gt;]</span><br><span class="line">#3</span><br><span class="line">git checkout [-m] [ [-b | -- orphan ] &lt;new_branch&gt;]</span><br><span class="line"> [start_point] </span><br></pre></td></tr></table></figure>
<p>用法2比用法1的区别在于，用法1包含了路径。为了避免路径和引用（或提交ID）同名而发生冲突，可以在&lt;paths&gt;前用两个连续的连字符作为分隔。用法1的&lt;commit&gt;是可选项，如果省略，则相当于从暂存区进行检出。</p>
<h2 id="五、删除文件"><a href="#五、删除文件" class="headerlink" title="五、删除文件"></a>五、删除文件</h2><h3 id="1-删除本地文件"><a href="#1-删除本地文件" class="headerlink" title="1.删除本地文件"></a>1.删除本地文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file_name</span><br><span class="line"></span><br><span class="line">git commit -m &quot;删除信息&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2，误删"><a href="#2，误删" class="headerlink" title="2，误删"></a>2，误删</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure>
<p>用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。</p>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<ul>
<li><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
</li>
<li><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
</li>
</ul>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<h3 id="3-删除远端文"><a href="#3-删除远端文" class="headerlink" title="3.删除远端文"></a>3.删除远端文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached --force .idea&#x2F; </span><br></pre></td></tr></table></figure>
<p>删除文件不需要加-r，删除文件夹需要-r， 该文件夹路径为本地文件夹所在路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;delete .idea&#x2F;&quot; 提交记录</span><br><span class="line">git push origin master  推到远端</span><br></pre></td></tr></table></figure>


<h2 id="六、本地分支和远程分支"><a href="#六、本地分支和远程分支" class="headerlink" title="六、本地分支和远程分支"></a>六、本地分支和远程分支</h2><h3 id="1-查看本地分支，带星号的表示当前所在本地分支"><a href="#1-查看本地分支，带星号的表示当前所在本地分支" class="headerlink" title="1.查看本地分支，带星号的表示当前所在本地分支"></a>1.查看本地分支，带星号的表示当前所在本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>查看远程和本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p>如果没有成功，先<code>git fetch origin</code>，然后我们在<code>git branch -a</code></p>
<h3 id="2-创建本地分支"><a href="#2-创建本地分支" class="headerlink" title="2.创建本地分支"></a>2.创建本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch dev #创建分支dev</span><br><span class="line"></span><br><span class="line">git checkout dev #切换分支（不要随意切分支，</span><br><span class="line">#如果你在某个分支上面修改了一些东西，但没有stash，那么你切换分支后修改的东西就没有任何保存了，如果想切，请先git stash，然后git checkout dev) stash后没有stash pop，然后reset --hard</span><br><span class="line"></span><br><span class="line">git checkout -b dev #创建并切换分支也可以用于切换已有分支</span><br></pre></td></tr></table></figure>
<h3 id="3-创建远程分支"><a href="#3-创建远程分支" class="headerlink" title="3.创建远程分支"></a>3.创建远程分支</h3><p> 如果想把本地的test分支提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#提本地test支作为远程的master分支</span><br><span class="line">git push origin test:master</span><br><span class="line"></span><br><span class="line">#提交本地test分支作为远程的test分支</span><br><span class="line">git push origin test:test</span><br></pre></td></tr></table></figure>
<p>也可以在github网站直接创建</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage22.png-2020-12-05-16-32-09.png" alt="学习笔记-学习笔记mediaimage22.png-2020-12-05-16-32-09"></p>
<h3 id="4-合并本地分支"><a href="#4-合并本地分支" class="headerlink" title="4.合并本地分支"></a>4.合并本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>
<p>合并当前分支，一般先切换到需要被合并的分支，如切换到master，该命令在master分支上输入会将dev分支合并到master分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>
<p>–no-ff参数，表示禁用Fast<br>forward，用普通模式合并，合并后的历史有分支，能看出来曾经做过合并。</p>
<p>merge和rebase的区别:<a target="_blank" rel="noopener" href="https://blog.csdn.net/wh_19910525/article/details/7554489">https://blog.csdn.net/wh_19910525/article/details/7554489</a></p>
<p>git merge b # 将b分支合并到当前分支</p>
<p>git rebase b，也是把 b分支合并到当前分支</p>
<p>假设目前分支：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image23-2020-12-05-16-34-27.jpeg" alt="学习笔记-image23-2020-12-05-16-34-27"></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image24-2020-12-05-16-34-46.jpeg" alt="学习笔记-image24-2020-12-05-16-34-46"></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image25-2020-12-05-16-35-01.jpeg" alt="学习笔记-image25-2020-12-05-16-35-01"></p>
<h3 id="5-origin"><a href="#5-origin" class="headerlink" title="5.origin"></a>5.origin</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tyyking/article/details/82909099">https://blog.csdn.net/tyyking/article/details/82909099</a></p>
<p>git的服务器端(remote)端包含多个repository，每个repository可以理解为一个项目。而每个repository下有多个branch。”origin”就是指向某一个repository的指针。服务器端的”master”（强调服务器端是因为本地端也有master）就是指向某个repository的一个branch的指针。</p>
<p>这是服务器端(remote)的情况：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image26-2020-12-05-16-35-44.png" alt="学习笔记-image26-2020-12-05-16-35-44"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:JasonDu1993&#x2F;learngit.git</span><br></pre></td></tr></table></figure>
<p>关联远程库，相当于让origin等于后面这个地址</p>
<h3 id="6-git-fetch-更新远程代码到本地仓库"><a href="#6-git-fetch-更新远程代码到本地仓库" class="headerlink" title="6.git fetch 更新远程代码到本地仓库"></a>6.git fetch 更新远程代码到本地仓库</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenlogin/p/6592228.html">https://www.cnblogs.com/chenlogin/p/6592228.html</a></p>
<p>理解 fetch 的关键, 是理解 FETCH_HEAD，FETCH_HEAD指的是:<br>某个branch在服务器上的最新状态</p>
<p>当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支.</p>
<p>一般来说, 存在两种情况:</p>
<p>1）如果没有显式的指定远程分支, 则远程分支的master将作为默认的FETCH_HEAD.</p>
<p>2）如果指定了远程分支, 就将这个远程分支作为FETCH_HEAD.</p>
<p>命令1：<code>git fetch origin branch1</code></p>
<p>设定当前分支的 FETCH_HEAD’ 为远程服务器的branch1分支。这个操作是<code>git pull origin branch1</code>的第一步,<br>而对应的pull操作,并不会在本地创建新的branch。</p>
<p>同时这个命令还可以用来测试远程主机的远程分支branch1是否存在, 如果存在,<br>返回0, 如果不存在, 返回128, 抛出一个异常.</p>
<p>命令2：<code>git fetch origin branch1:branch2</code></p>
<p>使用远程branch1分支在本地创建branch2(但不会切换到该分支),如果本地不存在branch2分支,<br>则会自动创建一个新的branch2分支,</p>
<p>如果本地存在branch2分支, 并且是<code>fast forward</code>, 则自动合并两个分支,<br>否则, 会阻止以上操作.</p>
<h3 id="7-fetch更新本地仓库两种方式"><a href="#7-fetch更新本地仓库两种方式" class="headerlink" title="7.fetch更新本地仓库两种方式"></a>7.fetch更新本地仓库两种方式</h3><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">&#x2F;&#x2F;从远程的origin仓库的master分支下载代码到本地的master分支</span><br><span class="line"></span><br><span class="line">git log -p master origin&#x2F;master &#x2F;&#x2F;比较本地的仓库和远程仓库的区别</span><br><span class="line"></span><br><span class="line">git merge origin&#x2F;master</span><br><span class="line">&#x2F;&#x2F;把远程下载下来的代码合并到本地仓库，远程的和本地的合并</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:temp</span><br><span class="line">&#x2F;&#x2F;从远程的origin仓库的master分支下载到本地并新建一个分支temp</span><br><span class="line"></span><br><span class="line">git diff temp &#x2F;&#x2F;比较本地master分支和本地temp分支的不同</span><br><span class="line"></span><br><span class="line">git merge temp &#x2F;&#x2F;合并本地temp分支到本地master分支</span><br><span class="line"></span><br><span class="line">git branch -d temp &#x2F;&#x2F;删除本地temp分支</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-合并远程分支"><a href="#8-合并远程分支" class="headerlink" title="8.合并远程分支"></a>8.合并远程分支</h3><p>假设这两个分支是a和b，那么fetch a和b，checkout a，将b<br>merge(rebase)到a，push<br>a到远端。这样做，将b和a合到了一起，并且更新了本地和远端的a。如果b不需要了，可以删除远程b和本地b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin a:a #将远程a分支拉到本地a(冒号后面的a表示本地分支a)</span><br><span class="line"></span><br><span class="line">git fetch origin b:b #将远程b分支拉到本地b(冒号后面的b表示本地分支b)</span><br><span class="line"></span><br><span class="line">git checkout a #切到本地a分支</span><br><span class="line"></span><br><span class="line">git merge b   #将本地b分支合并到本地a分支上</span><br><span class="line"></span><br><span class="line">git push origin a #将本地a分支推到远程a分支</span><br><span class="line"></span><br><span class="line">git branch -d b  #删除本地分支</span><br><span class="line"></span><br><span class="line">git push origin --delete b   #删除远程b分支</span><br></pre></td></tr></table></figure>

<h3 id="9-删除本地分支"><a href="#9-删除本地分支" class="headerlink" title="9.删除本地分支"></a>9.删除本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev #删除分支</span><br></pre></td></tr></table></figure>

<h3 id="10-删除远程分支"><a href="#10-删除远程分支" class="headerlink" title="10.删除远程分支"></a>10.删除远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete dev</span><br></pre></td></tr></table></figure>
<h3 id="11-创建本地新分支并将新分支和远程某个分支相关联"><a href="#11-创建本地新分支并将新分支和远程某个分支相关联" class="headerlink" title="11.创建本地新分支并将新分支和远程某个分支相关联"></a>11.创建本地新分支并将新分支和远程某个分支相关联</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -a #查看本地和远程所有分支</span><br><span class="line"></span><br><span class="line">git checkout -b dev &#x2F;origin&#x2F;dev  #创建本地分支dev并和远程dev分支相关联同时切换到本地dev分支</span><br></pre></td></tr></table></figure>

<h3 id="12-修改commit信息"><a href="#12-修改commit信息" class="headerlink" title="12.修改commit信息"></a>12.修改commit信息</h3><p><strong>(1)没有push到远端，修改本地分支commit信息</strong></p>
<p>a. 未执行git push<br>之前可以使用如下的命令进行操作(只能撤销最近一次的commit)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git  reset --soft commit_id # (commit_id可以git reflog查看)</span><br><span class="line"></span><br><span class="line">git commit -m &quot;fix commit&quot;  #重新提交信息</span><br></pre></td></tr></table></figure>

<p>b. 如果要修改前面多出提交的历史信息，可以采用(2)里面的方法，只是不需要执行git push</p>
<p>命令总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line">git rebase -i HEAD~5</span><br></pre></td></tr></table></figure>

<p>把需要修改的commit信息前的pick改成edit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>多次重复执行前面两个命令直到更新</p>
<p><strong>(2) 已经push到远端 ，修改本地分支commit信息和远程分支commit信息</strong></p>
<p>命令总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev  #(切换到dev分支)</span><br><span class="line"></span><br><span class="line">git rebase -i HEAD~5  #(对最近5个提交记录进行rebase操作)</span><br></pre></td></tr></table></figure>

<p>把需要修改的commit信息前的pick改成edit <br>(linux下一般通过vim进行操作，即输入i进入编辑模式，修改对应内容，然后esc，接着输入:wq保存退出)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend  #(输入i进入修改模式，修改commit信息，修改完后使用esc退出修改模式，接着输入:wq保存修改)</span><br><span class="line"></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>多次重复执行前面两个命令直到更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev -f</span><br></pre></td></tr></table></figure>

<p><strong>下面是详细介绍如何修改已经push 的commit 的信息</strong><br>原文链接：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39956074/article/details/83992286">https://blog.csdn.net/qq_39956074/article/details/83992286</a> </p>
<p><strong>如何修改已经push 的commit 的信息</strong><br>A. <code>git rebase -i HEAD~5</code><br>最新提交的版本为倒数第一个版本，5表示倒数第5个版本，这个数字可以修改，如改成2</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage27.png-2020-12-05-16-49-50.png" alt="学习笔记-学习笔记mediaimage27.png-2020-12-05-16-49-50"></p>
<p>前5行即为<code>HEAD～5</code>所提交的信息，第一行为倒数第五个版本的commit信息，第五行为倒数第一个版本commit信息，每行开头是pick，然后是commit id， 然后是commit信息</p>
<p>B.输入i进入修改模式，将需要修改的commit信息前的pick改成edit，修改完后使用esc退出修改模式，接着输入:wq保存修改。</p>
<p>C.命令行输入 <code>git commit --amend</code>，输入i进入修改模式，修改commit信息，修改完后使用esc退出修改模式，接着输入:wq保存修改。</p>
<p>【注】保存之后 <code>git rebase --continue</code>还没有使用之前还可以使用<code>git commit --amend</code>继续修改这条commit信息，但如果提交了就只能从头再来了，即使用<code>git rebase -i HEAD~5 </code>把pick改成edit保存退出，然后<code>git commit --amend</code>，保存修改信息之后屏幕输出以下内容</p>
<p>保存修改后命令行会输出以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[detached HEAD fbe9591] 20190716c, bs 16, lr 0.001, maxiter 60000, steps &quot;(50000, 55000)&quot;, 8000</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Date: Mon Jul 15 18:11:43 2019 +0800</span><br><span class="line"> </span><br><span class="line">1 file changed, 3 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>D.命令行输入<code>git rebase --continue</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git rebase --continue</span><br><span class="line"> </span><br><span class="line">Stopped at 896acbdf7545b0e42ff761376a2cdbca899b445d... 20190715c, bs 8, lr 0.0025, maxiter 60000, steps &quot;(50000, 55000)&quot;, 8000</span><br><span class="line"> </span><br><span class="line">You can amend the commit now, with</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">git commit --amend</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">git rebase --continue</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出这些信息是因为我们把多个pick改成了edit，因此继续修改commit信息直到全部修改完成，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git commit --amend</span><br><span class="line"> </span><br><span class="line">[detached HEAD 70929e1] 20190715e, bs 8, lr 0.0025, maxiter 60000, steps &quot;(50000, 55000)&quot;, 8000</span><br><span class="line"> </span><br><span class="line">Date: Mon Jul 15 18:19:56 2019 +0800</span><br><span class="line"> </span><br><span class="line">1 file changed, 4 insertions(+), 4 deletions(-)</span><br><span class="line"> </span><br><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git rebase --continue</span><br><span class="line"> </span><br><span class="line">Successfully rebased and updated refs&#x2F;heads&#x2F;jason.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>E.<code>git push origin dev -f</code><br>将本地更新推送到远程分支上，必须加上-f，否则我们edit的commit会添加到commit后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git push origin dev -f</span><br><span class="line"> </span><br><span class="line">Password for &#39;http:&#x2F;&#x2F;jason@git.sankuai.com&#39;: 输入密码</span><br><span class="line"> </span><br><span class="line">Counting objects: 40, done.</span><br><span class="line"> </span><br><span class="line">Delta compression using up to 12 threads.</span><br><span class="line"> </span><br><span class="line">Compressing objects: 100% (40&#x2F;40), done.</span><br><span class="line"> </span><br><span class="line">Writing objects: 100% (40&#x2F;40), 7.75 KiB | 0 bytes&#x2F;s, done.</span><br><span class="line"> </span><br><span class="line">Total 40 (delta 31), reused 0 (delta 0)</span><br><span class="line"> </span><br><span class="line">remote:</span><br><span class="line"> </span><br><span class="line">remote: Create pull request for jason:</span><br><span class="line"> </span><br><span class="line">remote: http:&#x2F;&#x2F;git.sankuai.com&#x2F;users&#x2F;lvtingxun&#x2F;repos&#x2F;mask-detection&#x2F;compare&#x2F;commits?sourceBranch&#x3D;refs&#x2F;heads&#x2F;dev</span><br><span class="line"> </span><br><span class="line">remote:</span><br><span class="line"> </span><br><span class="line">To http:&#x2F;&#x2F;jason@***.git</span><br><span class="line"> </span><br><span class="line">+ b26a84a...70929e1 dev -&gt; dev (forced update)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-删除commit信息"><a href="#13-删除commit信息" class="headerlink" title="13.删除commit信息"></a>13.删除commit信息</h3><p>git 删除远程分支上的某次提交原文：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/QQxiaoqiang1573/article/details/68074847">https://blog.csdn.net/QQxiaoqiang1573/article/details/68074847</a> </p>
<p><strong>(1) 没有push到远端，删除本地commit信息</strong></p>
<p>A.删除最后一次提交记录</p>
<p>git reflog能查看所有历史操作记录，如果只想看commit信息，可以使用git<br>log，两者都能查到commit id</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-24-7d7b962a0e07f5d49418c4268577902f-image28-614ef5.png" alt="IMG_257">{width=”5.854166666666667in”<br>height=”1.21875in”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> git revert HEAD </span><br></pre></td></tr></table></figure>
<p>将回到倒数第二次提交后的版本，但本次操作会生成commit信息进行提交（输入i进入编辑状态，编辑完信息后按ESC，接着输入:wq保存退出）</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-49-1d7bb19fe4188d6de19a5120f330096e-image29-5332f5.png" alt="IMG_258">{width=”5.822916666666667in”<br>height=”3.53125in”}</p>
<p>保存退出后输出如下，此时已经回退到倒数第二次提交的时候：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-20-1deb9320af5a425d8e1e02ca5c9184e8-image30-40c5b0.png" alt="IMG_259">{width=”5.09375in”<br>height=”0.6354166666666666in”}</p>
<p>通过git<br>log查看提交的记录，发现会生成一次新的commit信息，但是内容已经更新到之前的了</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-33-3d49d3ec358fcd726421df18e3439ff2-image31-e7bed9.png" alt="IMG_260">{width=”5.875in”<br>height=”3.5208333333333335in”}</p>
<p>或者<br><code>git reset --hard HEAD^ </code>注意后面有个^表示将回到倒数第二次提交后的版本</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-47-fc603198cc94a93c22b3c1a4cf86ae01-image32-05ae14.png" alt="IMG_261">{width=”3.3125in”<br>height=”0.3854166666666667in”}</p>
<p>操作前的提交记录</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-55-db53e89c0d0421c1afd2dc1c9e257bec-image33-a0649c.png" alt="IMG_262">{width=”5.802083333333333in”<br>height=”3.4583333333333335in”}</p>
<p>操作后的提交记录</p>
<p><code>git log</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-06-7192d4ded3c4a88a0a438d4c4ae50a64-image34-e57f36.png" alt="IMG_263">{width=”5.84375in”<br>height=”3.5104166666666665in”}</p>
<p>[注] revert会生成一次新的提交，之前commit的信息还在，reset<br>则不会保留之前的提交记录信息</p>
<p>B.删除历史提交中的某次或者多次提交记录</p>
<p>例子：删除最后一次和倒数第三次提交记录</p>
<ol>
<li><code>git log</code> 找到你要删除的最远的<code>commit id</code>，本次测试选择了红色框的commit信息进行删除，也可以通过<code>git reflog</code>查看<code>commit id</code></li>
</ol>
<p><code>git log</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-16-7805d35ac338422bfca0392abf72374d-image35-79c71e.png" alt="IMG_264">{width=”5.854166666666667in”<br>height=”4.5in”}</p>
<p>2)<code> git rebase -i HEAD~5</code><br>最新提交的版本为倒数第一个版本，5表示倒数第5个版本，这个数字可以修改，如改成3进入下面的编辑页面，或者git<br>rebase -i “commit id”^   注意后面有个^符号，加不加””都可以，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3 </span><br></pre></td></tr></table></figure>
<p>(输入i进入编辑状态，删除第一行的内容，编辑完信息后按ESC，接着输入:wq保存退出)</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-29-3787014405122b6bab510595d1f67c8f-image36-58d7e9.png" alt="IMG_265">{width=”5.8125in”<br>height=”3.1979166666666665in”}</p>
<p>删除第一行内容和第三行内容，即删除倒数第三次提交和最后一次提交的内容</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-46-907a7552e60ade951ac68fefd0ae0475-image37-5a4873.png" alt="IMG_266">{width=”4.864583333333333in”<br>height=”1.2083333333333333in”}</p>
<p>保存退出后输出如下，此时回到删除改提交之前的那次提交后的状态，即commit信息为”删除commit信息2”</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-54-7861202049bf28c4e0b02a0e0cfb9646-image38-d2549a.png" alt="IMG_267">{width=”5.854166666666667in”<br>height=”1.6041666666666667in”}</p>
<p>此时<code>git log</code>，回到了要删除commit信息前一次提交的状态</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-01-5f3dd4037789e1471433f7b4c6471dd8-image39-3701ae.png" alt="IMG_268">{width=”5.822916666666667in”<br>height=”3.3541666666666665in”}</p>
<p>但有冲突，需要解决，冲突的文件内容如下所示</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-14-79701861ba33c16dd061af7ab8d9fdb2-image40-3604cf.png" alt="IMG_269">{width=”5.875in”<br>height=”0.9270833333333334in”}</p>
<p>a)，解决冲突文件后内容如下</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-27-8d95fbbaac75e564a6e381a823963be1-image41-b9f423.png" alt="IMG_270">{width=”3.1354166666666665in”<br>height=”0.3541666666666667in”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git rebase --continue  #（直接退出文件，通过:q退出）</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-34-f3588fbd8ff4cc8f57fd7b52145b133d-image42-d1b4a6.png" alt="IMG_271">{width=”5.84375in”<br>height=”2.15625in”}</p>
<p>如果没有使用<code>git add . </code>而直接使用<code>git rebase --continue</code>会提示下面的信息</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-45-0117a0f019fd2f1c5b58c3d84d94fa01-image43-0c7c1c.png" alt="IMG_272">{width=”3.2083333333333335in”<br>height=”0.6979166666666666in”}</p>
<p>此时输出如下：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-52-5e1c6ec87cd49947634dde35b1dbca61-image44-25d6d0.png" alt="IMG_273">{width=”4.020833333333333in”<br>height=”0.6458333333333334in”}</p>
<p><code>git log</code>发现第三次和第五次提交的commit信息已经删除了</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-58-1f3bf58e1d2102553824b87ab13bbd30-image45-3c423b.png" alt="IMG_274">{width=”5.854166666666667in”<br>height=”4.385416666666667in”}</p>
<p>b) 不解决冲突，通过<code>git rebase --skip</code><br>跳过解决冲突，直接回退到第三次提交后的状态。类似于使用git reset回退</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-14-1867d75af9c5dc305130349b6adcbd8f-image46-2d79c2.png" alt="IMG_275">{width=”3.7604166666666665in”<br>height=”0.375in”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-06-ca6d1ccb0acf2b7980d2193ccd72ddc7-image47-6c2615.png" alt="IMG_276">{width=”5.854166666666667in”<br>height=”2.65625in”}</p>
<p>文件中的内容:</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-06-b5ddd5f3cf54db08d07746d951b5039f-image48-9450fb.png" alt="IMG_277">{width=”5.885416666666667in”<br>height=”0.4895833333333333in”}</p>
<p>c)，不解决冲突，通过<code>git rebase --abort</code>回到最新提交的状态，所有东西都回到rebase前，因此此时并没有删除commit信息，要想删除就得解决冲突。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-44-83545c1a9844f53a24e53f3b2bca1aa6-image49-eea995.png" alt="IMG_278">{width=”4.1875in”<br>height=”0.375in”}</p>
<p><code>git log</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-20-53-4c5865f227274bbf92353bbd22b50d65-image50-2cb8e9.png" alt="IMG_279">{width=”5.8125in”<br>height=”4.197916666666667in”}</p>
<p><strong>(2) 已经push到远端，删除本地commit信息和远程commit信息</strong></p>
<p>在(1)完成的基础上，只需要加上<code>git push orgin master -f</code><br>即可将master分支上的commit信息删除</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-23-f398f7bb150853bc40db13154a57314a-image51-93b6f3.png" alt="IMG_280">{width=”5.145833333333333in”<br>height=”1.5104166666666667in”}</p>
<p><code>git push orgin master -f</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-30-80bdcc06dbf6463f2baf0a7387760fb5-image52-dea17a.png" alt="IMG_281">{width=”6.802083333333333in”<br>height=”2.5416666666666665in”}</p>
<p>远程最新的文档内容：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-37-aebe80c876b2d1692544da5a0b26cf4c-image53-1fecda.png" alt="IMG_282">{width=”6.697916666666667in”<br>height=”2.9270833333333335in”}</p>
<h2 id="七、分支策略"><a href="#七、分支策略" class="headerlink" title="七、分支策略"></a>七、分支策略</h2><p><strong>1.在实际开发中，我们应该按照几个基本原则进行分支管理：</strong></p>
<ol>
<li><p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
</li>
<li><p>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
</li>
<li><p>每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了</p>
</li>
</ol>
<p><strong>2.分支是否推送到远程</strong></p>
<ol>
<li><p>master分支是主分支，因此要时刻与远程同步；</p>
</li>
<li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
</li>
<li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
</li>
<li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
</li>
</ol>
<p> </p>
<h2 id="八、bug分支和暂存工作现场"><a href="#八、bug分支和暂存工作现场" class="headerlink" title="八、bug分支和暂存工作现场"></a>八、bug分支和暂存工作现场</h2><h3 id="1-bug分支的用途"><a href="#1-bug分支的用途" class="headerlink" title="1.bug分支的用途"></a>1.bug分支的用途</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成又不想commit时，先把工作现场暂存，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<p> </p>
<h3 id="2-创建bug分支的流程"><a href="#2-创建bug分支的流程" class="headerlink" title="2.创建bug分支的流程"></a>2.创建bug分支的流程</h3><p>假设暂存现场在dev分支，总体流程如下：</p>
<ol>
<li><p>git stash  # 暂存工作现场（去修bug，假设bug在master分支上）</p>
</li>
<li><p>git checkout master</p>
</li>
<li><p>修改bug</p>
</li>
<li><p>git add .</p>
</li>
<li><p>git commit -m “fix bug on master”</p>
</li>
<li><p>git push origin master</p>
</li>
<li><p>git checkout dev  切到dev分支</p>
</li>
<li><p>git stash list 会出现stash@{0}: WIP on dev: 6224937 add mergegit</p>
</li>
<li><p>git stash pop 将之前本地dev分支暂存的环境恢复出来</p>
</li>
<li><p>(还可以通过 git stash apply stash@{0}进行恢复，再删除stask内容git stash drop)</p>
</li>
<li><p>git stash list  再次查看还有暂存现场没有</p>
</li>
</ol>
<p> </p>
<h2 id="九、feature分支"><a href="#九、feature分支" class="headerlink" title="九、feature分支"></a>九、feature分支</h2><p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，用<code>git branch -d &lt;name&gt;</code>，若要强行删除使用-D</p>
<p> </p>
<h2 id="十、github远程仓库"><a href="#十、github远程仓库" class="headerlink" title="十、github远程仓库"></a>十、github远程仓库</h2><h3 id="1-使用ssh创建key"><a href="#1-使用ssh创建key" class="headerlink" title="1.使用ssh创建key"></a>1.使用ssh创建key</h3><p>为了和远程库相关联需要添加key，如果不加好像每次需要输密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;***@qq.com&quot; # 后面的邮箱根据自己的情况修改</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该命令用于<br>创建id_rsa文件和id_rsa.pub文件，id_rsa是私钥，id_rsa.pub是公钥用于添加到github的ssh<br>key里面。文件位于用户目录下的.ssh文件里面</p>
<h3 id="2-本地仓库和远程仓库关联"><a href="#2-本地仓库和远程仓库关联" class="headerlink" title="2.本地仓库和远程仓库关联"></a>2.本地仓库和远程仓库关联</h3><p><strong>第一种情况：远程只有仓库没有内容时，将本地已经写好的代码关联到远程：</strong></p>
<ol>
<li><p>git init</p>
</li>
<li><p>git add .</p>
</li>
<li><p>git commit -m “first commit”</p>
</li>
<li><p>git remote add origin <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#103;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a>:JasonDu1993/learngit.git</p>
</li>
<li><p>关联远程库，相当于让origin等于后面这串地址</p>
</li>
<li><p>git push -u origin master</p>
</li>
<li><p>-u只在第一次推送分支时使用，将本地master推到远程master分支上</p>
</li>
<li><p>关联完之后就可以切分支或者创建其他分支了</p>
</li>
<li><p>git checkout master</p>
</li>
<li><p>git push origin master  将到本地master分支内容推到远程master分支上</p>
</li>
<li><p>git checkout -b dev  创建本地dev分支并切换到本地dev分支</p>
</li>
<li><p>git push origin dev  将本地dev分支推到远程dev分支</p>
</li>
</ol>
<p>一般master分支和dev分支都会推到远程</p>
<p><strong>第二种情况：远程仓库有内容，直接克隆到本地</strong></p>
<ol>
<li><p>git clone <a href="mailto:&#103;&#105;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#x6d;">&#103;&#105;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#x6d;</a>:JasonDu1993/gitskills.git</p>
</li>
<li><p>git branch -a 查看本地分支和远程分支</p>
</li>
<li><p>git checkout -b dev origin/dev  如果本地没有dev分支将会报错</p>
</li>
<li><p>git add file_name</p>
</li>
<li><p>git commit -m “记录提交信息”</p>
</li>
<li><p>git push origin dev</p>
</li>
</ol>
<p>在GitHub上，可以任意Fork开源仓库，这样拥有fork后的仓库的读写权限，你就可以push到你fork之后的这个仓库了，当然也可以推送pull<br>request给官方仓库来贡献代码。</p>
<p> </p>
<h3 id="3-关联仓库出现问题解决办法"><a href="#3-关联仓库出现问题解决办法" class="headerlink" title="3.关联仓库出现问题解决办法"></a>3.关联仓库出现问题解决办法</h3><p>1）如果<code>git checkout -b dev origin/dev</code>迁出分支出现问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal: Cannot update paths and switch to branch &#39;dev&#39; at the same time.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Did you intend to checkout &#39;orgin&#x2F;dev&#39; which can not be resolved as</span><br><span class="line">commit?</span><br></pre></td></tr></table></figure>
<p>解决办法是先<code>git fetch</code>，再<code>git checkout -b dev origin/dev</code></p>
<p> </p>
<p>2）如果<code>git push</code>失败，先<code>git pull</code></p>
<p>如果<code>git pull</code>失败，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p>
<p><code>git branch --set-upstream dev origin/dev</code>，（现在好像改成<code>git branch --set-upstream-to=origin/dev dev</code>）</p>
<p>然后在<code>git pull</code>，<code>git push origin master</code></p>
<p> </p>
<p>3） <code>git error: RPC failed; result=22, HTTP code = 411</code><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/love_rongrong/article/details/12557347">https://blog.csdn.net/love_rongrong/article/details/12557347</a></p>
<p>解决办法：改一下git的传输字节限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config http.postBuffer  524288000</span><br></pre></td></tr></table></figure>

<p>4）<code>error: RPC failed; result=22, HTTP code = 413</code></p>
<p>fatal: The remote end hung up unexpectedly </p>
<p>fatal: The remote end hung up unexpectedly</p>
<p>Everything up-to-date</p>
<p>这两个错误看上去相似，一个是411，一个是413</p>
<p>下面这个错误添加一下密钥就可以了</p>
<p>首先<code>ssh-keygen -t rsa -C &quot;abc@bupt.edu.cn&quot;</code>生成密钥</p>
<p> </p>
<h3 id="4-有时候不想解决冲突-建议还是解决冲突好）"><a href="#4-有时候不想解决冲突-建议还是解决冲突好）" class="headerlink" title="4.有时候不想解决冲突(建议还是解决冲突好）"></a>4.有时候不想解决冲突(建议还是解决冲突好）</h3><ol>
<li>从远处拉取最新的东西到本地（不想解决冲突直接接受远程仓库内容）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &#x2F;&#x2F;至少下载到本地不进行合并</span><br><span class="line"></span><br><span class="line">git reset --hard origin&#x2F;dev</span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>2)，将本地更新强制推到远程，不想解决和远程的冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin dev 或者git push -f origin dev</span><br></pre></td></tr></table></figure>


<h3 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5.删除分支"></a>5.删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#删除远程分支</span><br><span class="line">git push origin --delete dev</span><br><span class="line"></span><br><span class="line">#删除本地分支</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>

<h3 id="6-创建远程分支"><a href="#6-创建远程分支" class="headerlink" title="6.创建远程分支"></a>6.创建远程分支</h3><p> 如果想把本地的test分支提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin test:master   #提交本地test分支作为远程的master分支</span><br><span class="line"></span><br><span class="line">git push origin test:test  #提交本地test分支作为远程的test分支</span><br></pre></td></tr></table></figure>
<h3 id="7-查看远程分支commit信息用于回退到远程分支的某个版本"><a href="#7-查看远程分支commit信息用于回退到远程分支的某个版本" class="headerlink" title="7.查看远程分支commit信息用于回退到远程分支的某个版本"></a>7.查看远程分支commit信息用于回退到远程分支的某个版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>


<h3 id="8-修改远程仓库名称"><a href="#8-修改远程仓库名称" class="headerlink" title="8.修改远程仓库名称"></a>8.修改远程仓库名称</h3><p>1) 在本地仓库删除远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin 1</span><br></pre></td></tr></table></figure>

<p>2 )修改Github仓库名称： </p>
<p>在Github页面中，进入要修改的仓库，在页面上方选择”Settings”，即可重命名远程仓库。</p>
<ol start="3">
<li>添加新的远程仓库：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;JasonDu1993&#x2F;gitskill.git</span><br></pre></td></tr></table></figure>

<h3 id="9-fork别人的仓库后如何同原仓库保持同步更新"><a href="#9-fork别人的仓库后如何同原仓库保持同步更新" class="headerlink" title="9. fork别人的仓库后如何同原仓库保持同步更新"></a>9. fork别人的仓库后如何同原仓库保持同步更新</h3><p>Github进行fork后如何与原仓库同步l原文链接：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/matrix_google/article/details/80676034">https://blog.csdn.net/matrix_google/article/details/80676034</a> </p>
<p>1）git remote -v #查看远程目录地址</p>
<p>2）git branch -a  #查看所有分支情况</p>
<p>3）git remote add upstream 你fork之前的源仓库地址 #该操作将源仓库和上游代码库upstream相关联（重要1）</p>
<p>4）git remote -v #再次查看远程目录的地址</p>
<p>5）git stash  #暂存自己的工作状态（不是必须的，如果改了代码没有push则需要）</p>
<p>6）git fetch upstream  #抓取源仓库的修改文件（重要2）</p>
<p>7）git branch -a  #再次查看所有分支情况</p>
<p>8）git checkout master #切换到master分支</p>
<p>9）git merge upstream/master #将本地代码和源代码保持同步（最重要3）</p>
<p>10）git stash pop #将暂存区的环境恢复到工作区上传到远程仓库</p>
<p>11）git add .</p>
<p>12）git commit -m “update forked repository at 2019.06.05”</p>
<p>13）git push origin master #上传新的代码到自己的远程master分支</p>
<h3 id="10-git-pull-can’t-update"><a href="#10-git-pull-can’t-update" class="headerlink" title="10. git pull can’t update"></a>10. git pull can’t update</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No tracked branch configured for branch dev or the branch doesn&#39;t</span><br><span class="line">exist. To make your branch track a remote branch call, for example, git</span><br><span class="line">branch --set-upstream-to origin&#x2F;dev dev</span><br></pre></td></tr></table></figure>

<h2 id="十一、多人合作流程"><a href="#十一、多人合作流程" class="headerlink" title="十一、多人合作流程"></a>十一、多人合作流程</h2><p>因此，多人协作的工作模式通常是这样：</p>
<p>首先，可以试图用git push origin branch-name推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p>
<p>如果git pull提示”no tracking<br>information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p> </p>
<h2 id="十二、版本标签"><a href="#十二、版本标签" class="headerlink" title="十二、版本标签"></a>十二、版本标签</h2><p>标签用于发布版本时使用，相当于给某次commit取个名字</p>
<p><strong>1，添加标签</strong></p>
<ul>
<li><p><code>git tag &lt;name&gt; </code>用于新建一个标签一般取名name为v0.1等，默认为HEAD，也可以指定一个<code>commit id</code></p>
</li>
<li><p><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; </code>可以指定标签信息</p>
</li>
<li><p><code>git tag </code>可以查看所有标签</p>
</li>
</ul>
<p> </p>
<p><strong>2，删除标签</strong></p>
<ul>
<li><p><code>git tag -d &lt;tagname&gt; </code>删除一个本地标签</p>
</li>
<li><p><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除一个远程标签</p>
</li>
<li><p><code>git push origin &lt;tagname&gt; </code>推送一个本地标签</p>
</li>
<li><p><code>git push origin --tags</code> 推送全部未推送过的本地标签</p>
</li>
</ul>
<p> </p>
<h2 id="十三，忽略特特殊文件"><a href="#十三，忽略特特殊文件" class="headerlink" title="十三，忽略特特殊文件"></a>十三，忽略特特殊文件</h2><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件，同时提交这个文件到Git。</p>
<p> </p>
<p>例子如下，.gitignore文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Windows:</span><br><span class="line"></span><br><span class="line">Thumbs.db</span><br><span class="line"></span><br><span class="line">ehthumbs.db</span><br><span class="line"></span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line"></span><br><span class="line">*.py[cod]</span><br><span class="line"></span><br><span class="line">*.so</span><br><span class="line"></span><br><span class="line">*.egg</span><br><span class="line"></span><br><span class="line">*.egg-info</span><br><span class="line"></span><br><span class="line">dist</span><br><span class="line"></span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># iead</span><br><span class="line"></span><br><span class="line">.idea</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line"></span><br><span class="line">db.ini</span><br><span class="line"></span><br><span class="line">deploy_key_rsa</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>忽略文件的原则是：</p>
<ol>
<li><p>忽略操作系统自动生成的文件，比如缩略图等；</p>
</li>
<li><p>忽略编译生成的中间文件、可执行文件等，比如Java编译产生的.class文件；</p>
</li>
<li><p>忽略敏感信息的配置文件，比如存放口令的配置文件。</p>
</li>
</ol>
<p> </p>
<h2 id="十四、自定义Git服务器"><a href="#十四、自定义Git服务器" class="headerlink" title="十四、自定义Git服务器"></a>十四、自定义Git服务器</h2><p>假设你已经有sudo权限的用户账号并且该教程是在ubuntu下介绍的</p>
<ol>
<li>安装git：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></li>
<li>创建一个git用户，用来运行git服务：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建证书登录：<br>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</li>
<li>初始化Git仓库：</li>
</ol>
<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在/srv目录下输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git init --bare sample.git</span><br></pre></td></tr></table></figure>

<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>禁用shell登录：</li>
</ol>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p>
<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash </code><br>改为：</p>
<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code></p>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<ol start="6">
<li>克隆远程仓库：</li>
</ol>
<p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone git@server:&#x2F;srv&#x2F;sample.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cloning into &#39;sample&#39;...</span><br><span class="line"></span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>管理公钥</strong></p>
<p>如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。</p>
<p><strong>管理权限</strong></p>
<p>使用<strong>Gitolite</strong>就是这个工具管理权限</p>
<h2 id="十五、git常见错误及解决办法"><a href="#十五、git常见错误及解决办法" class="headerlink" title="十五、git常见错误及解决办法"></a>十五、git常见错误及解决办法</h2><p><strong>1.git缓存太小下载不下来大文件</strong></p>
<p>解决：<code>git config --global http.postBuffer 524288000</code></p>
<p><strong>2.有图片文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#39;survivors&#39;...</span><br><span class="line"></span><br><span class="line">remote: Counting objects: 124, done.</span><br><span class="line"></span><br><span class="line">remote: Compressing objects: 100% (120&#x2F;120), done.</span><br><span class="line"></span><br><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data</span><br><span class="line">remaining</span><br><span class="line"></span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line"></span><br><span class="line">fatal: early EOF</span><br><span class="line"></span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<p>解决：<code>git clone http://github.com/large-repository --depth 1</code></p>
<p><strong>3.更完美的解决下载不下来方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data</span><br><span class="line">remaining</span><br><span class="line"></span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line"></span><br><span class="line">fatal: early EOF</span><br><span class="line"></span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>方法一：<code>git config --global http.postBuffer 524288000</code></p>
<p>如果不行</p>
<p>方法二：<code>git clone http://github.com/large-repository --depth 1</code></p>
<p>如果还不行</p>
<p>方法三：一般clone http方式的容易产生此问题，改成SSH的方式也有效，即https://改为git://</p>
<p><strong>4.git remote: HTTP Basic: Access denied 错误解决办法</strong></p>
<p>来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lydiawork/p/10287797.html">https://www.cnblogs.com/lydiawork/p/10287797.html</a></p>
<p>问题描述：<br>git push 报 HTTP Basic: Access denied 错误</p>
<p>原因：本地git配置的用户名、密码与gitlabs上注册的用户名、密码不一致。<br><strong>解决方案：</strong></p>
<ol>
<li>如果账号密码有变动 用这个命令 <code>git config --system --unset credential.helper</code> 重新输入账号密码 应该就能解决了</li>
<li>如果用了第一个命令 还不能解决问题那么 用这个命令：<br><code>  git config --global http.emptyAuth true</code></li>
<li>如果以上两个方法不起作用，那么采用以下方法：</li>
</ol>
<p>进入控制面板》用户账号》凭据管理器？windows凭据》普通凭据，在里面找到git，点开编辑密码，更新为最新密码之后就可以正常操作了。</p>
<h1 id="Window-终端配置"><a href="#Window-终端配置" class="headerlink" title="Window 终端配置"></a>Window 终端配置</h1><h2 id="Scoop配置"><a href="#Scoop配置" class="headerlink" title="Scoop配置"></a>Scoop配置</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luoyooi/article/details/102990113">Windows下Scoop安装、配置与使用_luoyooi的博客-CSDN博客_scoop</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在PowerShell中运行以下命令，将scoop安装到其默认位置(<code>C:\Users\&lt;user&gt;\scoop</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object</span><br><span class="line">System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;get.scoop.sh&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="或"><a href="#或" class="headerlink" title="或"></a>或</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iwr -useb get.scoop.sh | iex</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装完成后，输入scoop<br>help验证是否成功（常见的命令可以通过此方法来查看）。<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-36-41-62de41087818c40969de93e5b28b34c1-image54-ed2cca.png" alt="在这里插入图片描述">{width=”5.768055555555556in”<br>height=”5.084722222222222in”}<br>用户安装的程序和scoop本身位于C:Users&lt;user&gt;scoop。全局安装的程序（–global）位于C:\ProgramData\scoop。可以通过环境变量更改这些设置。具体步骤如下：</p>
<h3 id="将Scoop安装到自定义目录-命令行方式"><a href="#将Scoop安装到自定义目录-命令行方式" class="headerlink" title="将Scoop安装到自定义目录(命令行方式)"></a>将Scoop安装到自定义目录(命令行方式)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$env:SCOOP&#x3D;&#39;D:Applications\Scoop&#39;</span><br><span class="line"></span><br><span class="line">[Environment]::SetEnvironmentVariable(&#39;SCOOP&#39;, $env:SCOOP,&#39;User&#39;)</span><br></pre></td></tr></table></figure>


<h3 id="将Scoop配置为将全局程序安装到自定义目录-SCOOP-GLOBAL-命令行方式"><a href="#将Scoop配置为将全局程序安装到自定义目录-SCOOP-GLOBAL-命令行方式" class="headerlink" title="将Scoop配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)"></a>将Scoop配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$env:SCOOP_GLOBAL&#x3D;&#39;F:\GlobalScoopApps&#39;</span><br><span class="line"></span><br><span class="line">[Environment]::SetEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;,</span><br><span class="line">$env:SCOOP_GLOBAL, &#39;Machine&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="上面两句运行的结果-环境变量"><a href="#上面两句运行的结果-环境变量" class="headerlink" title="上面两句运行的结果(环境变量)"></a>上面两句运行的结果(环境变量)</h3><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-38-45-69d072a8079102da338071daa6fa4c10-image55-d2410c.png" alt="在这里插入图片描述">{width=”5.768055555555556in”<br>height=”4.741666666666666in”}<br>如果不想运行命令行，直接添加环境变量也可。设置完安装位置后，建议将默认目录下的所有文件复制到新目录（<strong>不是剪切！！</strong>）</p>
<p>参考链接：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/50993df76b1c">scoop——强大的Windows命令行包管理工具 - 简书(jianshu.com)</a></p>
</li>
<li><p>配色 如何保存更改 ：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cum44153/article/details/109043040">zsh自定义命令提示符_如何使用Microsoft的ColorTool自定义命令提示符的配色方案_cum44153的博客-CSDN博客</a></p>
</li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4b2b7074d9e2">像MAC一样使用win10的Terminal - 简书(jianshu.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43455581/article/details/105565970">使用Oh-My-Posh美化FluentTerminal_罗伯特祥的博客-CSDN博客</a></li>
</ul>
<h2 id="shell工具安装"><a href="#shell工具安装" class="headerlink" title="shell工具安装"></a>shell工具安装</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scoop install grep<span class="comment"># grep</span></span><br><span class="line"></span><br><span class="line">scoop install gawk <span class="comment"># awk</span></span><br><span class="line"></span><br><span class="line">scoop install sed <span class="comment"># sed</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>若下载不了，则开启VPN</p>
</blockquote>
<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35078688/article/details/83240661">https://blog.csdn.net/qq_35078688/article/details/83240661</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lixiansheng/p/8942370.html">https://www.cnblogs.com/lixiansheng/p/8942370.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Little_Fire/article/details/80605233?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf">https://blog.csdn.net/Little_Fire/article/details/80605233?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf</a></p>
<h2 id="MapReduce工作流程"><a href="#MapReduce工作流程" class="headerlink" title="MapReduce工作流程"></a>MapReduce工作流程</h2><p>　　1) 工作流程概述</p>
<p>　　<img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-41-23-7f4e8338e960623aa43e3d6d484a0b70-image56-912ad6.png" alt="IMG_256">{width=”6.649305555555555in”<br>height=”3.286111111111111in”}</p>
<p>不同的Map任务之间不会进行通信</p>
<p>不同的Reduce任务之间也不会发生任何信息交换</p>
<p>用户不能显式地从一台机器向另一台机器发送消息</p>
<p>所有的数据交换都是通过MapReduce框架自身去实现的</p>
<p>如果想统计下过去10年计算机论文出现最多的几个单词，看看大家都在研究些什么，那收集好论文后，该怎么办呢？ </p>
<p>方法一：可以写一个小程序，把所有论文按顺序遍历一遍，统计每一个遇到的单词的出现次数，最后就可以知道哪几个单词最热门了。<br>这种方法在数据集比较小时，是非常有效的，而且实现最简单，用来解决这个问题很合适。 </p>
<p>方法二：写一个多线程程序，并发遍历论文。<br>这个问题理论上是可以高度并发的，因为统计一个文件时不会影响统计另一个文件。当我们的机器是多核或者多处理器，方法二肯定比方法一高效。但是写一个多线程程序要比方法一困难多了，我们必须自己同步共享数据，比如要防止两个线程重复统计文件。 </p>
<p>方法三：把作业交给多个计算机去完成。<br>我们可以使用方法一的程序，部署到N台机器上去，然后把论文集分成N份，一台机器跑一个作业。这个方法跑得足够快，但是部署起来很麻烦，我们要人工把程序copy到别的机器，要人工把论文集分开，最痛苦的是还要把N个运行结果进行整合（当然我们也可以再写一个程序）。 </p>
<p>方法四：让MapReduce来帮帮我们吧！MapReduce本质上就是方法三，但是如何拆分文件集，如何copy程序，如何整合结果这些都是框架定义好的。我们只要定义好这个任务（用户程序），其它都交给MapReduce。</p>
<p>map函数和reduce函数：map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。</p>
<p>**map函数：接受一个键值对（key-value<br>pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。 **</p>
<p>**reduce函数：接受一个键key，以及相关的一组值（value<br>list），将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。 **</p>
<p>统计词频的MapReduce函数的核心代码非常简短，主要就是实现这两个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; key: document name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; value: document contents </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for each word w in value: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                EmitIntermediate(w, &quot;1&quot;); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values): </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; key: a word </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; values: a list of counts </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     int result &#x3D; 0; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     for each v in values:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         result +&#x3D; ParseInt(v); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     Emit(AsString(result)); </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>　　在统计词频的例子里，map函数接受的键（key）是文件名，值（value）是文件的内容，map逐个遍历单词，每遇到一个单词word就产生一个中间键值对&lt;w,<br>“1”&gt;（表示单词w咱又找到了一个）；MapReduce将键相同（都是单词w）的键值对传给reduce函数，这样reduce函数接受的键就是单词w，值是一串”1”（最基本的实现是这样，但可以优化），个数等于键为w的键值对的个数，然后将这些”1”累加就得到单词w的出现次数。最后这些单词的出现次数会被写到用户定义的位置，存储在底层的分布式存储系统（GFS或HDFS）。 </p>
<p>【MapReduce工作原理】</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-43-36-30ae050b2c58b91225b65b8f0be254f0-image57-1b4ae6.png" alt="IMG_256">{width=”7.1875in”<br>height=”5.395833333333333in”}</p>
<p>上图是论文里给出的MapReduce流程图。一切都是从最上方的user<br>program开始的，user<br>program链接了MapReduce库，实现了最基本的Map函数和Reduce函数。图中执行的顺序都用数字标记了。</p>
<p>（1）MapReduce库先把user<br>program的输入文件划分为M份（M为用户定义），每一份通常有16MB到64MB，如图左方所示分成了split0~split4；然后使用fork将用户进程拷贝到集群内其它机器上。</p>
<p>（2）user<br>program的副本中有一个称为master，其余称为worker，master是负责调度的，为空闲worker分配作业（Map作业或者Reduce作业），worker的数量也是可以由用户指定的。 </p>
<p>（3）被分配了Map作业的worker，开始读取对应分片的输入数据，Map作业数量是由M决定的，和split一一对应；Map作业从输入数据中抽取出键值对，每一个键值对都作为参数传递给map函数，map函数产生的中间键值对被缓存在内存中（环形缓冲区kvBuffer）。</p>
<p>（4）缓存的中间键值对会被定期写入本地磁盘（spill），而且被分为R个区，R的大小是由用户定义的，将来每个区会对应一个Reduce作业；这些中间键值对的位置会被通报给master，master负责将信息转发给Reduce<br>worker。 </p>
<p>（5）master通知分配了Reduce作业的worker它负责的分区在什么位置（肯定不止一个地方，每个Map作业产生的中间键值对都可能映射到所有R个不同分区），当Reduce<br>worker把所有它负责的中间键值对都读过来后，先对它们进行排序，使得相同键的键值对聚集在一起。因为不同的键可能会映射到同一个分区也就是同一个Reduce作业，所以排序是必须的。 </p>
<p>（6）reduce<br>worker遍历排序后的中间键值对，对于每个唯一的键，都将键与关联的值传递给reduce函数，reduce函数产生的输出会添加到这个分区的输出文件中。</p>
<p>（7）当所有的Map和Reduce作业都完成了，master唤醒正版的user<br>program，MapReduce函数调用返回user program的代码。 </p>
<p>所有执行完毕后，MapReduce输出放在了R个分区的输出文件中（分别对应一个Reduce作业）。用户通常并不需要合并这R个文件，而是将其作为输入交给另一个MapReduce程序处理。整个过程中，输入数据来自底层分布式文件系统（hdfs），中间数据是放在本地文件系统的，最终输出数据是写入hdfs的。注意Map/Reduce作业和map/reduce函数的区别：Map作业处理一个输入数据的分片，可能需要调用多次map函数来处理每个输入键值对；Reduce作业处理一个分区的中间键值对，期间要对每个不同的键调用一次reduce函数，Reduce作业最终也对应一个输出文件。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mysql@5.7 </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peiminer/p/9442047.html">https://www.cnblogs.com/peiminer/p/9442047.html</a></p>
<p><strong>python mac install MySQLdb ModuleNotFoundError No module named ‘ConfigParser’</strong></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/3730932/blog/4314720">https://my.oschina.net/u/3730932/blog/4314720</a></p>
<p>环境<br>    python3.7 macOS 10.15.5<br>原因：<br>在 Python 3.x 版本后，ConfigParser.py 已经更名为 configparser.py 所以出错！<br>解决办法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/Cellar/python/3.7.7/Frameworks/Python.framework/Versions/3.7/lib/python3.7/configparser.py /usr/local/Cellar/python/3.7.7/Frameworks/Python.framework/Versions/3.7/lib/python3.7/ConfigParser.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果上述方法仍不能解决 原因2：<br>python3中已经取消了MYSQLdb<br>第一步安装：<br>pip install pymysql<br>第二部在项目同名文件中添加：<br>import pymysql</p>
<p>pymysql.install_as_MySQLdb()</p>
<p>一、MySQL 连接本地数据库，用户名为“root”，密码“123”（注意：“-p”和“123” 之间不能有空格）<br>C:&gt;mysql -h localhost -u root -p123<br>二、MySQL 连接远程数据库（192.168.0.201），端口“3306”，用户名为“root”，密码“123”<br>C:&gt;mysql -h 172.16.16.45 -P 3306 -u root -p123<br>三、MySQL 连接本地数据库，用户名为“root”，隐藏密码<br>C:&gt;mysql -h localhost -u root -p</p>
<p>Enter password:<br>四、MySQL 连接本地数据库，用户名为“root”，指定所连接的数据库为“test”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;mysql -h localhost -u root -p123 -D test</span><br><span class="line"></span><br><span class="line">mysql&gt;select database();</span><br><span class="line"></span><br><span class="line">查看版本 </span><br><span class="line">mysql&gt;status;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看列名</span><br><span class="line">SELECT column_name FROM information_schema.columns  where table_schema&#x3D;&#39;statistic&#39; and table_name&#x3D;&#39;monitor_material_check_daily_backup_10281700&#39;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务启动。。。</span><br><span class="line">Mysql.server start stop restart status</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看指定数据库的大小 :比如说 数据库mydb1</span><br><span class="line">select concat(round(sum(DATA_LENGTH&#x2F;1024&#x2F;1024),2), &#39;MB&#39;) as data from information_schema.TABLES where information_schema.TABLES.TABLE_SCHEMA&#x3D;&#39;mydb1&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看指定数据库的表的大小 : 比如说 数据库mydb1中b1表</span><br><span class="line">select concat(round(sum(DATA_LENGTH&#x2F;1024&#x2F;1024),2), &#39;MB&#39;) as data from information_schema.TABLES where information_schema.TABLES.TABLE_SCHEMA&#x3D;&#39;mydb1&#39; and TABLE_NAME&#x3D;&#39;b1&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Select 。。Into outfile “filename”</span><br><span class="line">SELECT redis_id, adspot_id , app_id,channel_id,iurl,text,pic_text,status FROM monitor_material_check_daily where operator is not null and operator !&#x3D; &#39;system&#39; and timestamp&gt;1590940800 and timestamp&lt;1593532800 into outfile &quot;2020-06-01_2020-07-01.csv&quot;;</span><br></pre></td></tr></table></figure>


<p><strong>报错：</strong><br>ERROR 1290 (HY000): The MySQL server is running with the –secure-file-priv option so it cannot execute this statement</p>
<p>报错原因：<br>mysql文件的导入和导出路径有默认的设置，即 secure-file-priv,当传入的csv文件路径与默认的路径冲突时就会报错。<br>secure-file-priv的值有三种情况：<br>secure_file_prive=null ––限制mysqld 不允许导入导出<br>secure_file_priv=/path/ – –限制mysqld的导入导出只能发生在默认的/path/目录下<br>secure_file_priv=’’ – –不对mysqld 的导入 导出做限制<br>打开本地mysql连接又<br>ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2)　</p>
<p>方案： </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chmldch/article/details/89710371">https://blog.csdn.net/chmldch/article/details/89710371</a></p>
<p>尝试连接本地<br>ERROR 1045 (28000): Access denied for user ‘foo’@’localhost’<br>远程导出mysql的数据为csv格式的文件<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33991418/article/details/92236234">https://blog.csdn.net/weixin_33991418/article/details/92236234</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-X  导出xml ，默认xml</span><br></pre></td></tr></table></figure>

<p>从mysql 导出的csv 是“假csv”，分隔符是”\t”，经awk -F ‘\t’ ‘{printf(“%s,%s,%s,%s,%s,%s,%s,%s\n”,$1,$2,$3,$4,$5,$6,$7,$8)}’ 转换后，发现 打开 格式混乱错误。经查证，从远程导出csv无法指定分隔符，只有从本地导出才可以。<br>解决方法a.在远程服务器 上直接进行操作，后下载到本地。b.将远程导出的”csv“另存为tsv，之后用wps打开后，另存为csv<br>目前执行方法b<br>方法b参考<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/clevercode/article/details/46965115">https://blog.csdn.net/clevercode/article/details/46965115</a></p>
<p>执行方法b太慢，且无法 使用screen 在服务端执行<br>解决：采取方法b，使用screen，且 优化sql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT redis_id, adspot_id , app_id,channel_id,iurl,text,pic_text,status FROM monitor_material_check_daily_backup_10281700 where timestamp&gt;1590940800 and timestamp&lt;&#x3D;1593532800 and operator is not null and operator !&#x3D; &#39;system&#39; into outfile &#39;&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;2020-06-01_2020-07-01.csv&#39; fields terminated by &#39;,&#39; ;</span><br></pre></td></tr></table></figure>

<p>总结：使用索引的where条件（timestamp&gt;1590940800 and timestamp&lt;=1593532800） 要放在前面，不要放在后面，否则会执行很慢</p>
<blockquote>
<p>csv格式不整齐，需再次过滤 <code>awk -F  &#39;,&#39;  &#39;$8==2&#123;print $0&#125;$8==1&#123;print $0&#125;&#39;</code></p>
<p>或者 加上  FIELDS OPTIONALLY ENCLOSED BY ‘字符’：设置字符来括住CHAR、VARCHAR和TEXT等字符型字段。括住含’，‘的文本后显示就正常了。默认情况下不使用任何符号。</p>
</blockquote>
<h2 id="on-duplicate-key-update"><a href="#on-duplicate-key-update" class="headerlink" title="on duplicate key update"></a>on duplicate key update</h2><p>如果在insert语句后面带上ON DUPLICATE KEY<br>UPDATE 子句，而要插入的行与表中现有记录的惟一索引或主键中产生重复值，那么就会发生旧行的更新；如果插入的行数据与现有表中记录的唯一索引或者主键不重复，则执行新纪录插入操作。</p>
<p>本案例：使用unique索引结合ON DUPLICATE KEY<br>UPDATE语句实现，添加数据确保数据的唯一性，不重复，有则修改，没有则新添加。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011066470/article/details/88723394?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf">https://blog.csdn.net/u011066470/article/details/88723394?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32737755/article/details/84661506?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf">https://blog.csdn.net/qq_32737755/article/details/84661506?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf</a></p>
<h2 id="数据库查询优化"><a href="#数据库查询优化" class="headerlink" title="数据库查询优化"></a>数据库查询优化</h2><p>参考文档：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanglijun/p/10879314.html">https://www.cnblogs.com/wanglijun/p/10879314.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhang_xiaomeng/article/details/55105451">https://blog.csdn.net/zhang_xiaomeng/article/details/55105451</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arxive/p/10597002.html">https://www.cnblogs.com/arxive/p/10597002.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yunfeifei/p/3850440.html">https://www.cnblogs.com/yunfeifei/p/3850440.html</a></p>
</li>
</ul>
<h3 id="1-1使用索引"><a href="#1-1使用索引" class="headerlink" title="1.1使用索引"></a>1.1使用索引</h3><p>应尽量避免全表扫描，首先考虑在where 以及 order by  ,group  by<br>涉及的列上建立索引</p>
<h3 id="1-2优化SQL语句"><a href="#1-2优化SQL语句" class="headerlink" title="1.2优化SQL语句"></a>1.2优化SQL语句</h3><ol>
<li>通过explain(查询优化神器)用来查看SQL语句的执行效果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。通常我们可以对比较复杂的尤其是涉及到多表的SELECT语句，把关键字explain加到前面，查看执行计划，例如：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> news;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>任何地方都不要使用select * from <br>用具体的字段列表代替”*”，不要返回用不到的任何字段。</p>
</li>
<li><p>不在索引列做运算或者使用函数。</p>
</li>
<li><p>查询尽可能使用limit 减少返回的行数，减少数据传输时间和带宽浪费。</p>
</li>
</ol>
<h3 id="1-3-优化数据库对象"><a href="#1-3-优化数据库对象" class="headerlink" title="1.3 优化数据库对象"></a>1.3 优化数据库对象</h3><ol>
<li>优化表的数据库类型</li>
</ol>
<p>使用procedure <br>analyse()函数对表进行分析，该函数可以对表中列的数据类型提出优化建议。能小就用小。表数据类型第一个原则是：使用能正确的表示和储存数据的最短类型。这样可以减少对磁盘空间，内存，cpu缓存的使用。</p>
<p>使用方法：<code>select * from  表名  procedure  analyse();</code></p>
<ol start="2">
<li>对表进行拆分</li>
</ol>
<p>第一种：垂直拆分</p>
<p>把主键和一些列放在一个表中，然后把主键和另外的列放到另一个表中。如果一个表中某些列常用，而另外一些列不常用，则可以用垂直拆分。</p>
<p>第二种：水平拆分</p>
<p>根据一列或者多列数据的值把数据行放到第二个独立的表中</p>
<ol start="3">
<li>使用中间表来提高查询速度</li>
</ol>
<p>创建中间表，表结构和原表结构完全相同，转移要统计的数据到中间表，然后在中间表上进行统计，得出想要的结果</p>
<h2 id="MySQL-索引知识点总结"><a href="#MySQL-索引知识点总结" class="headerlink" title="MySQL 索引知识点总结"></a>MySQL 索引知识点总结</h2><blockquote>
<p>知其然知其所以然！本文介绍索引的数据结构、查找算法、常见的索引概念和索引失效场景。</p>
</blockquote>
<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a><strong>什么是索引？</strong></h3><p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。（百度百科）</p>
<p>索引的目的是提高查找效率，对数据表的值集合进行了排序，并按照一定数据结构进行了存储。</p>
<p>本文将从一个案例开始，从索引的数据结构、分类、关键概念及如何使用索引提高查找效率等方面对索引知识进行总结。</p>
<h3 id="从一个案例开始"><a href="#从一个案例开始" class="headerlink" title="从一个案例开始"></a><strong>从一个案例开始</strong></h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>业务中有个既存的历史 SQL 语句在运行时会导致 DB 服务器过载，进而导致相关服务阻塞无法及时完成。CPU 监控曲线如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPx9FqYNKfgUian0EKdca922a8cuU9ias8ArtftZibX3mWQU522F3eaCr2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPOVPLf0eWZkV4LFvwKNf8yw0H5z5E5PSCm4oIZPtFy2ut6JXRw7tVeQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">图1-优化前的CPU使用率</p>
<p>从 DB 的 CPU 使用率曲线可以看到业务运行一直处于“亚健康”状态（1），随着业务的增长随时都可能出现问题。这种问题（2）在 11 月 11 日凌晨出现，当时 DB CPU 一直处于 100%高负荷状态，且存在大量的慢查询语句。最终以杀死进程降低 DB 负载、减少业务进程（3）的方式恢复业务。</p>
<p>在 11 月 11 日下午，对该业务的 SQL 语句进行了优化，优化的效果如下。业务运行时的 CPU 使用率峰值有很大的降低（对比图 2 的 1，2，3 可见）；慢查询语句几乎在监控曲线上也无法明显观察到（对比图 3 的 1，2，3 可见）。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPHic5bC1371koNCsDUTibdjDGQCYRqPYoXCp9bIbI5ZDkYqTRL2P6WIuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">图2-优化前后的CPU使用率</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPNm3BUIjzbIHHdDOYTh4zn8g5ANnghchS3ZN2aITCLfyicknBaCjw5Cw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">图3-优化前后的慢查询数量</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>表结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE T_Mch******Stat (&#96;FStatDate&#96; int unsigned NOT NULL DEFAULT 19700101 COMMENT &#39;统计日期&#39;,</span><br><span class="line">&#96;FMerchantId&#96; bigint unsigned NOT NULL DEFAULT 0 COMMENT &#39;商户ID&#39;,</span><br><span class="line">&#96;FVersion&#96; int unsigned NOT NULL DEFAULT 0 COMMENT &#39;数据版本号&#39;,</span><br><span class="line">&#96;FBatch&#96; bigint unsigned NOT NULL DEFAULT 0 COMMENT &#39;统计批次&#39;,</span><br><span class="line">&#96;FTradeAmount&#96; bigint NOT NULL DEFAULT 0 COMMENT &#39;交易金额&#39;</span><br><span class="line">PRIMARY KEY (&#96;FStatDate&#96;,&#96;FMerchantId&#96;,&#96;FVersion&#96;),</span><br><span class="line">INDEX i_FStatDate_FVersion (&#96;FStatDate&#96;,&#96;FVersion&#96;))</span><br><span class="line">DEFAULT CHARSET &#x3D; utf8 ENGINE &#x3D; InnoDB;</span><br></pre></td></tr></table></figure>

<p>从建表语句可以知道该表有两个索引：</p>
<ol>
<li>主键索引，是一个组合索引，由字段 FStateDate、FMerchantId 和 FVersion 组成；</li>
<li>普通索引，是一个组合索引，由字段 FStateDate 和 FVersion 组成；</li>
</ol>
<p>优化前的 SQL 语句（做了部分裁剪）A：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_CALC_FOUND_ROWS FStatDate,</span><br><span class="line">    FMerchantId,</span><br><span class="line">    FVersion,</span><br><span class="line">    FBatch,</span><br><span class="line">    FTradeAmount,</span><br><span class="line">    FTradeCount</span><br><span class="line">FROM T_Mch******Stat_1020</span><br><span class="line">WHERE FStatDate &#x3D; 20201020</span><br><span class="line">    AND FVersion &#x3D; 0</span><br><span class="line">    AND FMerchantId &gt; 0</span><br><span class="line">ORDER BY FMerchantId ASC LIMIT 0, 8000</span><br></pre></td></tr></table></figure>

<p>对该 SQL 进行 explain 得到如下结果，Extra 字段的值为 using where，说明并没有使用到索引。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-17-7ef69757a13bfe2536d6f65b32bf84f8-640-20201214180517107-b444a2.png" alt="图片"></p>
<p>优化后的 SQL 语句（做了部分裁剪）B：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_CALC_FOUND_ROWS a1.FStatDate,</span><br><span class="line">    a1.FMerchantId,</span><br><span class="line">    a1.FVersion,</span><br><span class="line">    FBatch,</span><br><span class="line">    FTradeAmount,</span><br><span class="line">    FTradeCount</span><br><span class="line">FROM T_Mch******Stat_1020 a1, (</span><br><span class="line">    SELECT FStatDate, FMerchantId, FVersion</span><br><span class="line">    FROM T_Mch******Stat_1020</span><br><span class="line">    WHERE FStatDate &#x3D; 20201020</span><br><span class="line">        AND FVersion &#x3D; 0</span><br><span class="line">        AND FMerchantId &gt; 0</span><br><span class="line">        ORDER BY FMerchantId ASC LIMIT 0, 8000 ) a2</span><br><span class="line">where a1.FStatDate &#x3D; a2.FStatDate</span><br><span class="line">    and a1.FVersion &#x3D; a2.FVersion</span><br><span class="line">    and a1.FMerchantId &#x3D; a2.FMerchantId;</span><br></pre></td></tr></table></figure>

<p>优化关键步骤为：</p>
<ul>
<li>新增一个子查询，select 字段只有主键字段；</li>
</ul>
<p>该 SQL 的 explain 结果如下，子查询语句使用了索引，而最终在线上运行结果也证明了优化效果显著。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-21-3d206f4a4f74e4e797681f8293543bd2-640-20201214180521647-e4d94b.png" alt="图片"></p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>优化后的 SQL 语句 B 比原来的 SQL 语句 A 复杂的多（子查询，临时表关联等），怎么效率会提升，违反直觉？有三个疑问：</p>
<ol>
<li>SQL 语句 A 的查询条件字段都在主键中，主键索引用到了没？</li>
<li>SQL 语句 B 的子查询为什么能够用到索引？</li>
<li>前后两条语句执行流程的差异是什么？</li>
</ol>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a><strong>索引的数据结构</strong></h3><p>在 MySQL 中，索引是在存储引擎层实现的，而不同的存储引擎根据其业务场景特点会有不同的实现方式。这里会先介绍我们常见的有序数组、Hash 和搜索树，最后看下 Innodb 的引擎支持的 B+树。</p>
<h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><p>数组是在任何一本数据结构和算法的书籍都会介绍到的一种重要的数据结构。有序数组如其字面意思，以 Key 的递增顺序保存数据在数组中。非常适合等值查询和范围查询。</p>
<table>
<thead>
<tr>
<th align="left">ID：1</th>
<th align="left">ID：2</th>
<th align="left">……</th>
<th align="left">ID:N</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name2</td>
<td align="left">name2</td>
<td align="left">……</td>
<td align="left">nameN</td>
</tr>
</tbody></table>
<p>在 ID 值没有重复的情况下，上述数组按照 ID 的递增顺序进行保存。这个时候如果需要查询特定 ID 值的 name，用二分法就可以快速得到，时间复杂度是 O(logn)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 二分查找递归实现方式</span><br><span class="line">int binary_search(const int arr[], int start, int end, int key)</span><br><span class="line">&#123;</span><br><span class="line">    if (start &gt; end)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int mid &#x3D; start + (end - start) &#x2F; 2;</span><br><span class="line">    if (arr[mid] &gt; key)</span><br><span class="line">        return binary_search(arr, start, mid - 1, key);</span><br><span class="line">    else if (arr[mid] &lt; key)</span><br><span class="line">        return binary_search(arr, mid + 1, end, key);</span><br><span class="line">    else</span><br><span class="line">        return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有序数组的优点很明显，同样其缺点也很明显。其只适合静态数据，如遇到有数据新增插入，则就会需要数据移动（新申请空间、拷贝数据和释放空间等动作），这将非常消耗资源。</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希表是一种以键-值（K-V）存储数据的结构，我们只需要输入键 K，就可以找到对应的值 V。哈希的思路是用特定的哈希函数将 K 换算到数组中的位置，然后将值 V 放到数组的这个位置。如果遇到不同的 K 计算出相同的位置，则在这个位置拉出一个链表依次存放。哈希表适用于等值查询的场景，对应范围查询则无能为力。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-26-165843d8f8591097a8d21c14081cd3a7-640-20201214180526352-592182.png" alt="图片"></p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树，也称为二叉查找树、有序二叉树或排序二叉树，是指一颗空树或者具有以下性质的二叉树：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-29-0dcf8375faf69beafc18f80d85e9279e-640-20201214180529295-0fa918.png" alt="图片"></p>
<p>二叉搜索树相比于其它数据结构的优势在于查找、插入的时间复杂度较低，为 O(logn)。为了维持 O(logn)的查询复杂度，需要保持这棵树是平衡二叉树。</p>
<p>二叉搜索树的查找算法：</p>
<ol>
<li>若 b 是空树，则搜索失败，否则：</li>
<li>若 x 等于 b 的根节点的值，则查找成功；否则：</li>
<li>若 x 小于 b 的根节点的值，则搜索左子树；否则：</li>
<li>查找右子树。</li>
</ol>
<p>相对于有序数组和 Hash，二叉搜索树在查找和插入两端的表现都非常不错。后续基于此不断的优化，发展出 N 叉树等。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>Innodb 存储引擎支持 B+树索引、全文索引和哈希索引。其中 Innodb 存储引擎支持的哈希索引是自适应的，Innodb 存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预。B+树索引是关系型数据库中最常见的一种索引，也将是本文的主角。</p>
<p><strong>数据结构</strong></p>
<p>在前文简单介绍了有序数组和二叉搜索树，对二分查找法和二叉树有了基本了解。B+树的定义相对复杂，在理解索引工作机制上无须深入、只需理解数据组织形式和查找算法即可。我们可以简单的认为 B+树是一种 N 叉树和有序数组的结合体。</p>
<p>例如：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-05-38-e8ce65f0cf8b05be3f041e7a1e9ba33b-640-20201214180538497-36cea5.png" alt="图片"></p>
<p>B+树的 3 个优点:</p>
<ol>
<li>层级更低，IO 次数更少</li>
<li>每次都需要查询到叶子节点，查询性能稳定</li>
<li>叶子节点形成有序链表，范围查询方便</li>
</ol>
<p><strong>操作算法</strong></p>
<ul>
<li>查找</li>
</ul>
<p>由根节点自顶向下遍历树，根据分离值在要查找的一边的指针；在节点内使用二分查找来确定位置。</p>
<ul>
<li>插入</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/14/18-13-25-d5dcfa68b40d86c2dcce8e2a53634e72-image-20201214181320489-597f03.png" alt="image-20201214181320489"></p>
<ul>
<li>删除</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/14/18-13-52-d457231776eadea559ff54df9817e238-image-20201214181350669-0117c6.png" alt="image-20201214181350669"></p>
<p>注：插入和删除两个表格内容来自《MySQL 技术内幕-InnoDB 存储引擎》</p>
<p>填充因子（innodb_fill_factor）：索引构建期间填充的每个 B-tree 页面上的空间百分比，其余空间保留给未来索引增长。从插入和删除操作中可以看到填充因子的值会影响到数据页的 split 和 merge 的频率。将值设置小些，可以减少 split 和 merge 的频率，但是索引相对会占用更多的磁盘空间；反之，则会增加 split 和 merge 的频率，但是可以减少占用磁盘空间。Innodb 对于聚集索引默认会预留 1/16 的空间保证后续的插入和升级索引。</p>
<h3 id="Innodb-B-树索引"><a href="#Innodb-B-树索引" class="headerlink" title="Innodb B+树索引"></a><strong>Innodb B+树索引</strong></h3><p>前文介绍了索引的基本数据结构，现在开始我们从 Innodb 的角度了解如何使用 B+树构建索引，索引如何工作和如何使用索引提升查找效率。</p>
<h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><p>数据库中的 B+树索引可以分为聚集索引和非聚集索引。聚集索引和非聚集索引的不同点在于叶子节点是否是完整行数据。</p>
<p>Innodb 存储引擎表是索引组织表，即表中的数据按照主键顺序存放。聚集索引就是按照每张表的主键构造一棵 B+树，叶子节点存放的是表的完整行记录。非聚集索引的叶子节点不包含行记录的全部数据。Innodb 存储引擎的非聚集索引的叶子节点的内容为主键索引值。</p>
<p>若数据表没有主键聚集索引是怎么建立的？在没有主键时 Innodb 会给数据表的每条记录生成一个 6 个字节长度的 RowId 字段，会以此建立聚集索引。</p>
<h4 id="Select-语句查找记录的过程"><a href="#Select-语句查找记录的过程" class="headerlink" title="Select 语句查找记录的过程"></a>Select 语句查找记录的过程</h4><p>下面例子将展示索引数据的组织形式及 Select 语句查询数据的过程。</p>
<ul>
<li>建表语句：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    s <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="keyword">index</span> k(k)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>, <span class="number">2</span>, <span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>, <span class="number">3</span>, <span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>, <span class="number">5</span>, <span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>索引结构示意</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>左边是以主键 ID 建立起的聚集索引，其叶子节点存储了完整的表记录信息；右边是以普通字段 K 建立的普通索引，其叶子节点的值是主键 ID。</p>
<ul>
<li>Select 语句执行过程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>执行流程如下：</p>
<ol>
<li>在 K 索引树上找到 k=3 的记录，取得 ID=300；</li>
<li>再到 ID 索引树上查找 ID=300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k=5，取得 ID=500；</li>
<li>再回到 ID 索引树查到 ID=500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li>
</ol>
<p>上述查找记录的过程中引入了一个重要的概念：<strong>回表</strong>，即回到主键索引树搜索的过程。避免回表操作是提升 SQL 查询效率的常规思路及重要方法。那么如何避免回表？</p>
<p>注：该例子来自《MySQL 实战 45 讲》</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>MySQL 5.7,建表语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`employees`</span> (</span><br><span class="line">  <span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`birth_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`first_name`</span> <span class="built_in">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`last_name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`gender`</span> enum(<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;F&#x27;</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`hire_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`i_first_name`</span> (<span class="string">`first_name`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`i_hire_date`</span> (<span class="string">`hire_date`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li>SQL 语句 A</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date &gt; <span class="string">&#x27;1990-01-14&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>explain 结果：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-40-076866c9e6006d8a200e132ab0667394-640-20201214181540882-1b0e90.png" alt="图片"></p>
<ul>
<li>SQL 语句 B</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select emp_no from employees where hire_date &gt; &#39;1990-01-14&#39;;</span><br></pre></td></tr></table></figure>

<p>explain 结果：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-44-79bf2e53e6a6fc82cb6645b3ee455b85-640-20201214181544517-9b8012.png" alt="图片"></p>
<ul>
<li>分析</li>
</ul>
<p>从前后两次 explain 的结果可以看到 SQL 语句 A 的 extra 为 using where，SQL 语句 B 的 extra 为 using where;using index。这说明 A 没有使用索引，而 B 使用了索引。</p>
<p>索引 K 中包含了查询语句所需要的字段 ID 的值，无需再次回到主键索引树查找，也就是“覆盖”了我们的查询需求，我们称之为覆盖索引。覆盖索引可以减少树的搜索次数，显著提升查询性能。</p>
<h4 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h4><ul>
<li>SQL 语句 A</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date &gt; <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;%Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<ul>
<li>SQL 语句 B</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date &gt; <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<ul>
<li>分析</li>
</ul>
<p>在上述测试的 SQL 语句 A 使用了极端方式: first_name like ‘%Hi%’，前后都增加模糊匹配使得 SQL 语句无法使用到索引；当去掉最左边的‘%’后，SQL 语句 B 就使用了索引。最左匹配可以是字符串索引的最左 N 个字符，也可以是联合索引的最左 M 的字段。合理规划、使用最左匹配可以减少索引，从而节约磁盘空间。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>何为索引下推？我们先从下面这组对比测试开始，将在 MySQL5.5 版本和 MySQL5.7 版本中执行同一条 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date &gt; <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 MySQL 5.5 执行 explain，extra 字段的值显示没有使用索引</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>执行查询花费时间为 0.12s</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<ul>
<li>在 MySQL 5.7 执行 explain，extra 字段的值显示使用了索引下推</li>
</ul>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-27-a5759803b903116dc0de724780a01cec-640-20201214181527890-3e2947.png" alt="图片"></p>
<p>执行查询花费时间为 0.02s</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-23-4652ece19222eb0b9e1ec6bb3caad7f8-640-20201214181523340-5c5f18.png" alt="图片"></p>
<ul>
<li>索引下推</li>
</ul>
<p>explain 结果中的 extra 字段值包含 using index condition，则说明使用了索引下推。索引下推功能是从 5.6 版本开始支持的。在 5.6 版本之前，i_first_name 索引是没有使用上的，需要每次去主键索引表取完整的记录值进行比较。从 5.6 版本开始，由于索引 i_first_name 的存在，可以直接取索引的 first_name 值进行过滤，这样不符合”first_name like ‘Hi%’”条件的记录就不再需要回表操作。</p>
<h4 id="MRR-优化"><a href="#MRR-优化" class="headerlink" title="MRR 优化"></a>MRR 优化</h4><p>MySQL 5.6 版本开始支持 Multi-Range Read(MRR)优化，MRR 优化的目的是为减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，对于 IO-bound 类型的 SQL 查询语句可带来性能极大提升。我们先看下对比测试，以下测试语句在同一个 MySQL 实例下执行，执行前均进行 mysql 服务重启，以保证缓存此没被预热。</p>
<ul>
<li>关闭 MRR</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@optimizer_switch=<span class="string">&#x27;mrr=off&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date &gt; <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>执行耗时未 0.90s</p>
<ul>
<li>开启 MRR</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@optimizer_switch=<span class="string">&#x27;mrr=on,mrr_cost_based=off&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date &gt; <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析</li>
</ul>
<p>从测试结果可以发现在 mrr 从关闭到开启，耗时从 0.90s 减少到 0.03s，查询速率达到 30 倍的提升。</p>
<h3 id="常见的索引失效场景"><a href="#常见的索引失效场景" class="headerlink" title="常见的索引失效场景"></a><strong>常见的索引失效场景</strong></h3><p>在 MySQL 表中建立了索引，SQL 查询语句就会一定使用到索引么？不一定，存在着索引失效的场景。我们给 employees 表增一个组合索引，后续例子均基于此表进行分析、测试。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employees <span class="keyword">add</span> <span class="keyword">index</span> i_b_f_l(birth_date, first_name, last_name)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employees <span class="keyword">add</span> <span class="keyword">index</span> i_h(hire_date);</span><br></pre></td></tr></table></figure>

<h4 id="失效场景"><a href="#失效场景" class="headerlink" title="失效场景"></a>失效场景</h4><ul>
<li>范围查询（&gt;,&lt;,&lt;&gt;）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date &gt; <span class="string">&#x27;1989-06-02&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询条件类型不一致</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employees <span class="keyword">add</span> <span class="keyword">index</span> i_first_name (first_name);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> first_name = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>查询条件使用了函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> <span class="keyword">CHAR_LENGTH</span>(hire_date) = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-16-21916b94f2e0fb561a501b60b239e291-640-20201214181516539-0807b2.png" alt="图片"></p>
<ul>
<li>模糊查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from employees where hire_date  like  &#39;%1995&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-15-12-6af618885fe831714e7fb3bba923d7f4-640-20201214181512139-afb9fe.png" alt="图片"></p>
<ul>
<li>不使用组合索引的首个字段当条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from employees where last_name &#x3D; &#39;Kalloufi&#39; and first_name &#x3D; &#39;Saniya&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-16-12-1eb6119b8512ac69ac870d987948018c-640-20201214181612487-606ae1.png" alt="图片"></p>
<h4 id="为什么会失效？"><a href="#为什么会失效？" class="headerlink" title="为什么会失效？"></a>为什么会失效？</h4><ul>
<li><p>顺序读比离散读性能要好</p>
<p>范围查询一定会导致索引失效么？</p>
<p>并不会！稍微更改下查询条件看下 explain 的对比结果，可以看到新语句用到索引下推，说明索引并未失效。为什么？</p>
<p>在不使用覆盖索引的情况下，优化器只有在数据量小的时候才会选择使用非聚集索引。受制于传统的机械磁盘特性，通过聚集索引顺序读数据行的性能会比通过非聚集索引离散读数据行要好。所以，优化器在即使有非聚集索引、但是访问数据量可能达到送记录数的 20%时会选择聚集索引。当然也可以用 Force index 强制使用索引。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date &gt; <span class="string">&#x27;1999-06-02&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<ul>
<li><p>无法使用 B+索引快速查找</p>
<p>B+树索引支持快速查询的基本要素是因为其索引键值是有序存储的，从左到右由小到大，这样就可以在每个层级的节点中快速查并进入下一层级，最终在叶子节点找到对应的值。</p>
<p>使用函数会使得 MySQL 无法使用索引进行快速查询，因为对索引字段做函数操作会破坏索引值的有序性，所以优化器选择不使用索引。而查询条件类型不一致其实也是同样的情况，因为其使用了隐式类型转换*。</p>
</li>
</ul>
<p>模糊匹配和不使用组合索引的首字段作为查询条件均是无法快速定位索引位置从而导致无法使用索引。模糊匹配当查询条件是 lwhere A ike ‘a%’，a 是 A 的最左前缀时是可能用上索引的（最左匹配），是否用上最终还是依赖优化器对查询数据量的评估。</p>
<h3 id="回到初始的案例"><a href="#回到初始的案例" class="headerlink" title="回到初始的案例"></a><strong>回到初始的案例</strong></h3><p>让我们回到文章初的案例，尝试回答下当时提出的 3 个问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A语句</span></span><br><span class="line"><span class="keyword">SELECT</span> FStatDate, FMerchantId, FVersion, FBatch, FTradeAmount, FTradeCount <span class="keyword">FROM</span> T_Mch******Stat_1020 <span class="keyword">WHERE</span> FStatDate = <span class="number">20201020</span>     <span class="keyword">AND</span> FVersion = <span class="number">0</span>     <span class="keyword">AND</span> FMerchantId &gt; <span class="number">0</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> FMerchantId <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- B语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SQL_CALC_FOUND_ROWS</span> a1.FStatDate,</span><br><span class="line">    a1.FMerchantId,</span><br><span class="line">    a1.FVersion,</span><br><span class="line">    FBatch,</span><br><span class="line">    FTradeAmount,</span><br><span class="line">    FTradeCount</span><br><span class="line"><span class="keyword">FROM</span> T_Mch******Stat_1020 a1, (</span><br><span class="line">    <span class="keyword">SELECT</span> FStatDate, FMerchantId, FVersion</span><br><span class="line">    <span class="keyword">FROM</span> T_Mch******Stat_1020</span><br><span class="line">    <span class="keyword">WHERE</span> FStatDate = <span class="number">20201020</span></span><br><span class="line">        <span class="keyword">AND</span> FVersion = <span class="number">0</span></span><br><span class="line">        <span class="keyword">AND</span> FMerchantId &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> FMerchantId <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">8000</span> ) a2</span><br><span class="line"><span class="keyword">where</span> a1.FStatDate = a2.FStatDate</span><br><span class="line">    <span class="keyword">and</span> a1.FVersion = a2.FVersion</span><br><span class="line">    <span class="keyword">and</span> a1.FMerchantId = a2.FMerchantId;</span><br></pre></td></tr></table></figure>

<p><strong>SQL 语句 A 的查询条件字段都在主键中，主键索引用到了没？</strong></p>
<p>主键索引其实是有被使用的：索引的范围查询，只是其需要逐条读取和解析所有记录才导致慢查询。</p>
<p><strong>SQL 语句 B 的子查询为什么能够用到索引？</strong></p>
<ol>
<li>前文中我们介绍了聚集索引，其索引键值就是主键。</li>
<li>两条 SQL 语句的不同之处在于 B 语句的子查询语句的 Select 字段都包含在主键字段中，而 A 语句还有其它字段（例如 FBatch 和 FTradeAmount 等）。这种情况下只凭主键索引的键值就能满足 B 语句的字段要求；A 语句则需要逐条取整行记录进行解析。</li>
</ol>
<p><strong>前后两条语句执行流程的差异是什么？</strong></p>
<ul>
<li>SQL 语句 A 的执行过程：</li>
</ul>
<ol>
<li>逐条扫描索引表并比较查询条件</li>
<li>遇到符合查询条件的则读取整行数据返回</li>
<li>回到 a 步骤，直至完成所有索引记录的比较</li>
<li>对返回的所有符合条件的记录（完整的记录）进行排序</li>
<li>选取前 8000 条数据返回</li>
</ol>
<ul>
<li>SQL 语句 B 的执行过程：</li>
</ul>
<ol>
<li>逐条扫描索引表并比较查询条件</li>
<li>遇到符合查询条件的则从索引键中取相关字段值返回</li>
<li>回到 a 步骤，直至完成所有索引记录的比较</li>
<li>对返回的所有符合条件的记录（每条记录只有 3 个主键）进行排序</li>
<li>选取前 8000 条数据返回形成临时表</li>
<li>关联临时表与主表，使用主键相等比较查询 8000 条数据</li>
</ol>
<ul>
<li>对比两个 SQL 语句的执行过程，可以发现差异点集中在步骤 2 和步骤 4。在步骤 2 中 SQL 语句 A 需要随机读取整行数据并解析非常耗资源；步骤 4 涉及 MySQL 的排序算法，这里也会对执行效率有影响，排序效果上看 SQL 语句 B 比 SQL 语句 A 好。</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a><strong>名词解释</strong></h3><ul>
<li>主键索引</li>
</ul>
<p>顾名思义该类索引由表的主键组成，从左到右由小到大排序。一个 Innodb 存储表只有一张主键索引表（聚集索引）。</p>
<ul>
<li>普通索引</li>
</ul>
<p>最为平常的一种索引，没有特别限制。</p>
<ul>
<li>唯一索引</li>
</ul>
<p>该索引的字段不能有相同值，但允许有空值。</p>
<ul>
<li>组合索引</li>
</ul>
<p>由多列字段组合而成的索引，往往是为了提升查询效率而设置。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>在文章开始时介绍了常见的几种索引数据结构，适合静态数据的有序数组、适合 KV 结构的哈希索引及兼顾查询及插入性能的搜索二叉树；然后介绍了 Innodb 的常见索引实现方式 B+树及 Select 语句使用 B+树索引查找记录的执行过程，在这个部分我们了解了几个关键的概念，回表、覆盖索引、最左匹配、索引下推和 MMR；之后还总结了索引的失效场景及背后的原因。最后，我们回到最初的案例，分析出优化前后 SQL 语句在使用索引的差异，进而导致执行效率的差异。</p>
<p>本文介绍了索引的一些粗浅知识，希望能够对读者有些许帮助。作为阶段性学习的一个总结，文章对 MySQL 索引的相关知识基本上是浅藏辄止，日后还需多多使用和深入学习。</p>
<p>何以解忧？唯有学习。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/14/18-16-19-df0402440bafe66c5d211906718d0133-640-20201214181619169-120505.png" alt="图片"></p>
<p><strong>参考书目和资料</strong></p>
<ul>
<li>《MySQL 技术内幕-InnoDB 存储引擎》第二版，作者：姜承尧</li>
<li>《MySQL 实战 45 讲》，作者：林晓斌</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/">https://dev.mysql.com/doc/refman/8.0/en/</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/6844903613915987975">重温数据结构：理解 B 树、B+ 树特点及使用场景 - Android</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zhangyachen/zhangyachen.github.io/issues/117">https://github.com/zhangyachen/zhangyachen.github.io/issues/117</a></li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="命令行登录"><a href="#命令行登录" class="headerlink" title="命令行登录"></a>命令行登录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ps -ef |grep redis</span><br><span class="line"></span><br><span class="line">redis-cli -p 6379</span><br><span class="line"></span><br><span class="line">auth yourpassword</span><br><span class="line"></span><br><span class="line">Info</span><br><span class="line"></span><br><span class="line">select 0 #db0</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-46-55-050d1acb38f4212d33bb1ffc4e707801-image58-59716b.png">{width=”5.60625in”<br>height=”2.6743055555555557in”}</p>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><h4 id="homebrew-安装"><a href="#homebrew-安装" class="headerlink" title="homebrew 安装"></a>homebrew 安装</h4><ol>
<li>install</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> foo@localhost:~$ brew install redis</span><br><span class="line"> .....</span><br><span class="line"> To have launchd start redis now and restart at login:</span><br><span class="line">  brew services start redis</span><br><span class="line">Or, if you don&#x27;t want/need a background service you can just run:</span><br><span class="line">  redis-server /usr/local/etc/redis.conf</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置</li>
</ol>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moon521/p/5301895.html">https://www.cnblogs.com/moon521/p/5301895.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongfangzan/p/5976567.html">https://www.cnblogs.com/dongfangzan/p/5976567.html</a></p>
<p>密码：<a target="_blank" rel="noopener" href="https://blog.csdn.net/TonyJand/article/details/104950489">https://blog.csdn.net/TonyJand/article/details/104950489</a></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/08/11-19-59-4e26d867f4adf689a4423f28e1b23f5e-image-20201208111950637-f55c89.png" alt="image-20201208111950637"></p>
<ol start="3">
<li><p>操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo@localhost:~$ cd /usr/local/bin</span><br><span class="line">foo@localhost:~$ sudo ./redis-cli -h xxx.xxx.xx.xxx -p 6379 -a password</span><br></pre></td></tr></table></figure>

<h2 id="疑难-1"><a href="#疑难-1" class="headerlink" title="疑难"></a>疑难</h2><h3 id="set设置过期时间"><a href="#set设置过期时间" class="headerlink" title="set设置过期时间"></a>set设置过期时间</h3><p>语法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(method) set: (name: _Key, value: _Value, ex: int | timedelta | None = ..., px: int | timedelta | None = ..., nx: bool = ..., xx: bool = ..., keepttl: bool = ...) -&gt; bool | None</span><br></pre></td></tr></table></figure>

<p>Set the value at key <code>name</code> to <code>value</code></p>
<ul>
<li><p><code>ex</code> sets an expire flag on key <code>name</code> for <code>ex</code> seconds.</p>
</li>
<li><p><code>px</code> sets an expire flag on key <code>name</code> for <code>px</code> milliseconds.</p>
</li>
<li><p><code>nx</code> if set to True, set the value at key <code>name</code> to <code>value</code> only if it does not exist.</p>
</li>
<li><p><code>xx</code> if set to True, set the value at key <code>name</code> to <code>value</code> only if it already exists.</p>
</li>
<li><p><code>keepttl</code> if True, retain the time to live associated with the key. (Available since Redis 6.0)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ttl=r_block_outcome.ttl(block_redis_cr_md5)<span class="comment">#current expire time</span></span><br><span class="line"></span><br><span class="line">r_block_outcome.set(block_redis_cr_md5,outcome,ex=ttl)<span class="comment">#不包含ex字段会默认初始化ttl为-1，即不过期</span></span><br></pre></td></tr></table></figure>

<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p><a target="_blank" rel="noopener" href="http://redisdoc.com/list/rpush.html">http://redisdoc.com/list/rpush.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dangsh_/article/details/79221328">https://blog.csdn.net/dangsh_/article/details/79221328</a></p>
<p><strong>②lpush(key , value)</strong><br>将一个或多个值 value 插入到列表 key 的表头<br>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头<br>如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作<br>当 key 存在但不是列表类型时，返回一个错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">r = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span> , port=<span class="string">&#x27;6379&#x27;</span> , db=<span class="number">6</span> ,decode_responses=<span class="literal">True</span>)</span><br><span class="line">r.lpush(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>) </span><br><span class="line">print(r.lrange(<span class="string">&quot;1&quot;</span> , <span class="number">0</span> , <span class="number">-1</span>)) <span class="comment">#打印列表&quot;1&quot;的全部内容 ,不能用get</span></span><br><span class="line">r.lpush(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(r.lrange(<span class="string">&quot;1&quot;</span> , <span class="number">0</span> , <span class="number">-1</span>))</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whz_zb/article/details/7425152?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf">https://blog.csdn.net/whz_zb/article/details/7425152?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dongrixinyu/article/details/78747384">https://blog.csdn.net/dongrixinyu/article/details/78747384</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xushiyu1996818/article/details/84936832?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf">https://blog.csdn.net/xushiyu1996818/article/details/84936832?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf</a></p>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Brew-安装报错"><a href="#Brew-安装报错" class="headerlink" title="Brew 安装报错"></a>Brew 安装报错</h2><p>当我们用Homebrew安装应用时，会出现此问题，显示Homebrew无法访问这些位置并添加在OS<br>X上为您安装软件所需的文件</p>
<p>对于上面问题，我们应尝试回收权限，解决方案如下：<br>首先打开终端，然后输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R `whoami`:admin /usr/local/bin</span><br></pre></td></tr></table></figure>

<p>接着系统会提醒你输入密码,输入密码回车之后接着输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R `whoami`:admin /usr/local/share</span><br></pre></td></tr></table></figure>

<p>之后就能在终端中用brew install 安装文件了</p>
<h2 id="利用Hexo在多台电脑上提交和更新github-pages博客"><a href="#利用Hexo在多台电脑上提交和更新github-pages博客" class="headerlink" title="利用Hexo在多台电脑上提交和更新github pages博客"></a>利用Hexo在多台电脑上提交和更新github pages博客</h2><p><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration.html">https://hexo.io/zh-cn/docs/configuration.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0b1fccce74e0?tdsourcetag=s_pcqq_aiomsg">[https://www.jianshu.com/p/0b1fccce74e0?tdsourcetag=s_pcqq_aiomsg]{.ul}</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4bcf2848b3fc">[https://www.jianshu.com/p/4bcf2848b3fc]{.ul}</a></p>
<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44815733/article/details/88786480">[https://blog.csdn.net/weixin_44815733/article/details/88786480]{.ul}</a></p>
<h1 id="Markdown插件"><a href="#Markdown插件" class="headerlink" title="Markdown插件"></a>Markdown插件</h1><p><strong>1.markdown-all-in-one—-基础功能+快捷键。<br>2.markdown toc—生成目录<br>3.markdown+math–编辑公式<br>4.Markdown PDF–转为PDF和其他格式<br>5.Markdown Preview Enhanced—–所以这款是增强显示的。<br>6.Markdown Shortcuts—–解决复制表格的问题。</strong></p>
<h2 id="一键将-Word-转换为-Markdown"><a href="#一键将-Word-转换为-Markdown" class="headerlink" title="一键将 Word 转换为 Markdown"></a>一键将 Word 转换为 Markdown</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/df6a136d06d8">https://www.jianshu.com/p/df6a136d06d8</a></p>
<h3 id="方法一：Writage-Pandoc-–-双剑合璧！"><a href="#方法一：Writage-Pandoc-–-双剑合璧！" class="headerlink" title="方法一：Writage + Pandoc – 双剑合璧！"></a>方法一：Writage + Pandoc – 双剑合璧！</h3><ol>
<li><p>下载并安装 Writage，下载地址：<a target="_blank" rel="noopener" href="http://www.writage.com/">http://www.writage.com/</a></p>
<p>打开 Writage网页，点击Download，再点击Download Now完成下载<br>运行安装程序，一般按照默认选项安装就好啦</p>
</li>
<li><p>安装后重启电脑，新建或打开任一 Word 文档，在 文件 菜单栏下选 另存为，查看 <strong>【保存类型】</strong> 中是否有 Markdown 格式。</p>
<blockquote>
<p>如果插件安装成功，就会自动出现Markdown选项；否则，重新安装一遍吧~）</p>
</blockquote>
</li>
</ol>
<h4 id="更加快捷（有时略坑）的方法二：Word-to-Markdown-Converter在线转换网页！"><a href="#更加快捷（有时略坑）的方法二：Word-to-Markdown-Converter在线转换网页！" class="headerlink" title="更加快捷（有时略坑）的方法二：Word to Markdown Converter在线转换网页！"></a>更加快捷（有时略坑）的方法二：Word to Markdown Converter在线转换网页！</h4><ol>
<li><strong>设置word文档中的标准样式，如一级、二级标题，项目符号或编号等，如此才能与markdown的格式对应</strong></li>
</ol>
<p>（稍微有点繁琐的前期准备，如果文档一开始就是按照标准样式排版，就没有这个烦恼啦）</p>
<p>设置</p>
<ol>
<li><p>打开网页Word to Markdown</p>
<blockquote>
<p>Converter：<a target="_blank" rel="noopener" href="https://word-to-markdown.herokuapp.com/">https://word-to-markdown.herokuapp.com/</a></p>
</blockquote>
</li>
<li><p>选择需要转换的Word文件,点击Convert</p>
</li>
<li><p>大功告成啦！<br>页面左边显示的是Markdown文档的内容，右边显示的是预览出来的样子</p>
</li>
</ol>
<p><strong>那么坑在哪里呢？</strong> 我们会发现，表格转换出来是这样子的 :disappointed:</p>
<p><strong>因此还需要进一步手动编辑整理完善表格</strong></p>
<p>（如果，Word文档本身不包括表格，Word to Markdown<br>Converter使用体验可谓相当便捷稳妥啦！）</p>
<h4 id="图片的下载与存储"><a href="#图片的下载与存储" class="headerlink" title="图片的下载与存储"></a>图片的下载与存储</h4><p>除了标准格式设置与表格调整问题，<br><strong>图片的下载与存储</strong>也会是我们可能会遇到的问题</p>
<ul>
<li><p><strong>Markdown转换为Word</strong><br>在Markdown文档中，图片以网络超链接的形式保存,如果markdown文档中有这一类图片，那么需要在网络连接的情况下，才能正常输出有图片的word文档。否则，图片处显示空白</p>
</li>
<li><p><strong>Word转换为Markdown</strong><br>Word转换为Markdown文档之后，文档中的图片输出到本地文件夹下，将该文件夹与输出的Markdown文档在同一目录下，在Markdown文档中图片引用本地相对路径，也就是说，必须保证Markdown文档与存放图片的本地文件夹在一起，才能完整的在markdown编辑器中显示图片</p>
</li>
</ul>
<h2 id="在线版word2markdown"><a href="#在线版word2markdown" class="headerlink" title="在线版word2markdown"></a>在线版word2markdown</h2><p><a target="_blank" rel="noopener" href="https://word2md.com/">https://word2md.com/</a></p>
<h2 id="Ulysses-mac支持-纯文本-Markdown2Word-，但付费"><a href="#Ulysses-mac支持-纯文本-Markdown2Word-，但付费" class="headerlink" title="Ulysses mac支持 纯文本 Markdown2Word ，但付费"></a>Ulysses mac支持 纯文本 Markdown2Word ，但付费</h2><p>目前只研究了Mac下的方案：</p>
<ol>
<li>word-to-markdown，google用word to</li>
</ol>
<p>markdown搜出来第一个，看来这个名字起得好。用这个的话得装个LibreOffice</p>
<ol>
<li><p>pandoc，这个就比较大名鼎鼎了</p>
</li>
<li><p>unoconv，介绍</p>
</li>
</ol>
<p>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b0be43b03015">https://www.jianshu.com/p/b0be43b03015</a></p>
<h2 id="方法1-markdown-image"><a href="#方法1-markdown-image" class="headerlink" title="方法1 markdown-image"></a>方法1 markdown-image</h2><p>配置</p>
<ol>
<li><p>申请七牛云做免费图床</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/335783774/answer/756830851">https://www.zhihu.com/question/335783774/answer/756830851</a></p>
</li>
</ol>
<p>存储空间名称markdown-source-of-bayes</p>
<ol start="2">
<li><p>配置插件</p>
<p><a target="_blank" rel="noopener" href="https://www.codingyang.com/2020/03/getQiniu.html#%E8%8E%B7%E5%8F%96%E5%AF%86%E9%92%A5">https://www.codingyang.com/2020/03/getQiniu.html#%E8%8E%B7%E5%8F%96%E5%AF%86%E9%92%A5</a></p>
</li>
</ol>
<p>Sm_ms,picGo</p>
<h2 id="方法2-pandoc"><a href="#方法2-pandoc" class="headerlink" title="方法2 pandoc"></a>方法2 pandoc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc -s $infile -t markdown -o $outfile --extract-media&#x3D;$filename#导出图片到目录下</span><br></pre></td></tr></table></figure>

<p>pandoc是文档转换利器。在将docx文档转为md文档过程中，如果直接输入<code>pandoc -o f.md f.docx</code>,会丢失word文档中的图片。输入<code>pandoc -o f.md f.docx ---extract-media=f </code>则不会丢失图片。</p>
<p>pandoc语法<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fd761fc43753">https://www.jianshu.com/p/fd761fc43753</a></p>
<h2 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h2><p>draw.io 绘图可以导出成 HTML，而 markdown 是支持直接嵌入 HTML 的</p>
<p>点击图形中的全屏按钮，再点击编辑，居然还可以直接修改原图的副本。厉害了！</p>
<p>具体插入的方法是，打开 draw.io 导出的 HTML<br>文件，将其中的 <body> 中的内容复制出来即可（不包含<code> &lt;body&gt;</code>标签）。<strong>github不支持解析</strong></p>
<h2 id="方法4-picGo-GitHub-上传图片"><a href="#方法4-picGo-GitHub-上传图片" class="headerlink" title="方法4 picGo+GitHub 上传图片"></a>方法4 picGo+GitHub 上传图片</h2><p>Typora批量上传图片</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zenglintao/p/12876725.html">https://www.cnblogs.com/zenglintao/p/12876725.html</a></p>
<p>图床配置</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43367829/article/details/104882071">https://blog.csdn.net/qq_43367829/article/details/104882071</a></p>
<p>注意 创建的GitHub图床默认分支为main,没有master分支，</p>
<h1 id="开发养成"><a href="#开发养成" class="headerlink" title="开发养成"></a>开发养成</h1><p>编程中最难的事：如何优雅地为程序中的变量和函数命名<br>命名不一致解决思路：<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/395223359">https://www.zhihu.com/question/395223359</a><br><a target="_blank" rel="noopener" href="https://www.douban.com/note/571297448/">https://www.douban.com/note/571297448/</a><br>(创建中间层，添加注解@)<br>工具<br><a target="_blank" rel="noopener" href="https://graphql.org/%EF%BC%8CTypeScrip">https://graphql.org/，TypeScrip</a></p>
<p>python – 解析一个.py文件,读取AST,修改它,然后回写修改后的源代码<a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-mvtnzhha-bsk.html">http://www.voidcn.com/article/p-mvtnzhha-bsk.html</a></p>
<p>统一纠正变量名<br>读取各项目ast，对每个变量计算编辑距离，编辑距离为0~len(word) 为一类<br>批量更正变量并写回去</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="电脑维护"><a href="#电脑维护" class="headerlink" title="电脑维护"></a>电脑维护</h2><p>CCleaner</p>
<p>SpaceSniffer</p>
<p>Geek</p>
<p>Snipaste</p>
<h2 id="论文工具"><a href="#论文工具" class="headerlink" title="论文工具"></a>论文工具</h2><p>LaTeX新手入门以及TeXlive和TeXstudio的安装使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/zywhehe/article/details/83113214">https://blog.csdn.net/zywhehe/article/details/83113214</a><br>TeX Live 下载及安装说明(mac 和window)<br><a target="_blank" rel="noopener" href="https://www.latexstudio.net/archives/10208.html">https://www.latexstudio.net/archives/10208.html</a><br><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/">https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/</a></p>
<p>VS Code + LaTeX<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144729565">https://zhuanlan.zhihu.com/p/144729565</a></p>
<p>一般来讲，LaTeX装好后默认的编译方式是pdflatex，但是这种方式不能编译中文源码。对于中文源码，采用的是xelatex的编译方式。对于编译中文文档有两种方式，第一种：在中文源文件首行添加：% !TEX program = xelatex，如果有参考文献，可以再添加% !BIB options = “%DOCFILE%”。显然，这个操作不够智能，因此，我们第一步是，添加xelatex的编译方式(2.3节)。</p>
<p>Mendeley－一款免费好用的文献管理软件<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28762628">https://zhuanlan.zhihu.com/p/28762628</a><br>自动插入参考文献，史上最简Endnote教程！！#论文写作+Endnote X8安装文件<a target="_blank" rel="noopener" href="http://www.xszydq.com/17326.html">http://www.xszydq.com/17326.html</a></p>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="课程-amp-资料"><a href="#课程-amp-资料" class="headerlink" title="课程&amp;资料"></a>课程&amp;资料</h2><p>【链接】最值得看的十大机器学习公开课<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yushupan/article/details/78582630">https://blog.csdn.net/yushupan/article/details/78582630</a></p>
<p>【链接】计算机视觉有哪些比较好的公开课？补充计<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/35831904">https://www.zhihu.com/question/35831904</a></p>
<p>机器学习与生成对抗网络<a target="_blank" rel="noopener" href="https://my.oschina.net/u/4579551/blog/4350931">https://my.oschina.net/u/4579551/blog/4350931</a></p>
<p>分类机器学习中，某一标签占比太大（标签稀疏），如何学习？<a target="_blank" rel="noopener" href="https://my.oschina.net/u/4579551/blog/4750226">https://my.oschina.net/u/4579551/blog/4750226</a></p>
<p>使用深度学习的图像分类-Koko.PDF<br><a target="_blank" rel="noopener" href="https://max.book118.com/html/2018/1016/7123041051001153.shtm">https://max.book118.com/html/2018/1016/7123041051001153.shtm</a></p>
<p>pandas官方中文文档-草鸡详细！！！！<a target="_blank" rel="noopener" href="https://www.pypandas.cn/deep/basics/image_classification.html#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D">https://www.pypandas.cn/deep/basics/image_classification.html#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D</a></p>
<p>汇总】CV 图像分类常见的 36 个模型<br><a target="_blank" rel="noopener" href="https://my.oschina.net/u/4579551/blog/4701954">https://my.oschina.net/u/4579551/blog/4701954</a></p>
<p>超详细！！！<br><a target="_blank" rel="noopener" href="http://www.feiguyunai.com/">http://www.feiguyunai.com/</a></p>
<p>Jupyter Notebook介绍、安装及使用教程<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/91365f343585">https://www.jianshu.com/p/91365f343585</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013709332/article/details/105029123/">https://blog.csdn.net/u013709332/article/details/105029123/</a></p>
<p>Python深度学习 基于TensorFlow 在线版<br><a target="_blank" rel="noopener" href="http://www.feiguyunai.com/index.php/2018/05/26/python-ml-tf-01/">http://www.feiguyunai.com/index.php/2018/05/26/python-ml-tf-01/</a></p>
<p>机器学习 几百篇文章<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/GarfieldEr007/category_5619819.html">https://blog.csdn.net/GarfieldEr007/category_5619819.html</a></p>
<p>零基础学习-深度学习核心-梯度下降与最优化<br><a target="_blank" rel="noopener" href="http://www.feiguyunai.com/index.php/2017/11/08/pythonai-dl-grade01/">http://www.feiguyunai.com/index.php/2017/11/08/pythonai-dl-grade01/</a></p>
<h1 id="C-入门教程，全套C-基础教程（已更新完毕）"><a href="#C-入门教程，全套C-基础教程（已更新完毕）" class="headerlink" title="C++入门教程，全套C++基础教程（已更新完毕）"></a>C++入门教程，全套C++基础教程（已更新完毕）</h1><p><a target="_blank" rel="noopener" href="http://www.weixueyuan.net/cpp/rumen//">http://www.weixueyuan.net/cpp/rumen//</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>小邝
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kuangyl-max.github.io/2020/12/19/learnNotes/" title="命令及工具">https://kuangyl-max.github.io/2020/12/19/learnNotes/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/24/youdao/" rel="prev" title="有道API调用">
      <i class="fa fa-chevron-left"></i> 有道API调用
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
<div>
    
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------ 本文结束------</div>
    
</div>
    
 </div>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">Linux学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.</span> <span class="nav-text">命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#scp"><span class="nav-number">1.1.1.</span> <span class="nav-text">scp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scp%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%B8%A6%E5%AF%86%E7%A0%81%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">scp在命令行中带密码远程下载文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#screen"><span class="nav-number">1.1.2.</span> <span class="nav-text">screen</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8screen%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">常用screen命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wc-%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text">wc 统计行数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.1.4.</span> <span class="nav-text">crontab定时任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#crontab%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.5.</span> <span class="nav-text">crontab命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#du-%E6%9F%A5%E7%9C%8B%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.6.</span> <span class="nav-text">du 查看占用空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">附录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#history-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.7.</span> <span class="nav-text">history 查看历史命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#coscmd%E6%96%87%E6%A1%A3v1-8-3-0"><span class="nav-number">1.1.8.</span> <span class="nav-text">coscmd文档v1.8.3.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usr-bin-expect"><span class="nav-number">1.1.9.</span> <span class="nav-text">&#x2F;usr&#x2F;bin&#x2F;expect</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">1.1.9.0.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sh%E8%84%9A%E6%9C%AC%E8%B0%83%E7%94%A8expect"><span class="nav-number">1.1.9.0.2.</span> <span class="nav-text">sh脚本调用expect</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rm"><span class="nav-number">1.1.10.</span> <span class="nav-text">rm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#source%E3%80%81sh%E3%80%81bash%E3%80%81-%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.11.</span> <span class="nav-text">source、sh、bash、.&#x2F;执行脚本的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dirname"><span class="nav-number">1.1.12.</span> <span class="nav-text">dirname</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%81-n%EF%BC%BD%E5%92%8C%EF%BC%BB%EF%BC%81-d%EF%BC%BD"><span class="nav-number">1.1.13.</span> <span class="nav-text">[ ！-n］和［！-d］</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="nav-number">1.1.14.</span> <span class="nav-text">文件测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%94%A8%E6%B3%95"><span class="nav-number">1.1.15.</span> <span class="nav-text">$参数用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#amp-%E5%92%8Cwait%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.1.16.</span> <span class="nav-text">&amp;和wait并行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.16.1.</span> <span class="nav-text">概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort"><span class="nav-number">1.1.17.</span> <span class="nav-text">sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9Asort-%E9%80%89%E9%A1%B9-%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.17.1.</span> <span class="nav-text">语法：sort(选项)(参数)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uniq-%E6%B3%A8%E6%84%8F"><span class="nav-number">1.1.18.</span> <span class="nav-text">uniq 注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iconv"><span class="nav-number">1.1.19.</span> <span class="nav-text">iconv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B9%B6%E3%80%81%E4%BA%A4%E3%80%81%E5%B7%AE"><span class="nav-number">1.1.20.</span> <span class="nav-text">文件并、交、差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#split"><span class="nav-number">1.1.21.</span> <span class="nav-text">split</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">1.1.21.1.</span> <span class="nav-text">语法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grep"><span class="nav-number">1.1.22.</span> <span class="nav-text">grep</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80"><span class="nav-number">1.1.22.1.</span> <span class="nav-text">获取ip地址</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9Aifconfig-a"><span class="nav-number">1.1.22.1.1.</span> <span class="nav-text">方法一：ifconfig -a</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E2-gt-amp-1%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.1.23.</span> <span class="nav-text">关于2&gt;&amp;1的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.24.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#declare"><span class="nav-number">1.1.24.1.</span> <span class="nav-text">declare</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">1.2.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bash%E8%B0%83%E8%AF%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">bash调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%87%BA%E5%81%A5%E5%A3%AE%E7%9A%84-Bash-%E8%84%9A%E6%9C%AC"><span class="nav-number">1.3.</span> <span class="nav-text">写出健壮的 Bash 脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8set-u"><span class="nav-number">1.3.1.</span> <span class="nav-text">使用set -u</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8set-e"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用set -e</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E9%98%B2%E5%BE%A1-%E8%80%83%E8%99%91%E6%84%8F%E6%96%99%E4%B9%8B%E5%A4%96%E7%9A%84%E4%BA%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">程序防御 - 考虑意料之外的事</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%A5%BD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC"><span class="nav-number">1.3.4.</span> <span class="nav-text">准备好处理文件名中的空格</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python%E5%AD%A6%E4%B9%A0"><span class="nav-number">2.</span> <span class="nav-text">Python学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-path-append-%E7%94%A8%E6%B3%95"><span class="nav-number">2.1.1.</span> <span class="nav-text">sys.path.append()用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-stdout%E3%80%81sys-stdin"><span class="nav-number">2.1.2.</span> <span class="nav-text">sys.stdout、sys.stdin</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E9%AA%8C"><span class="nav-number">2.2.</span> <span class="nav-text">经验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.1.</span> <span class="nav-text">Python执行路径问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#name-%E2%80%98reload%E2%80%99-is-not-defined%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">name ‘reload’ is not defined解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#configparser"><span class="nav-number">2.2.3.</span> <span class="nav-text">configparser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#urllib%E6%A8%A1%E5%9D%97%E7%9A%84urlopen-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.2.4.</span> <span class="nav-text">urllib模块的urlopen()的使用方法及实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.5.</span> <span class="nav-text">分块读取文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#logging"><span class="nav-number">2.2.6.</span> <span class="nav-text">logging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python%EF%BC%8D%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%92%8C%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0"><span class="nav-number">2.2.7.</span> <span class="nav-text">python－读取文件和计算文件行数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Groupby"><span class="nav-number">2.2.8.</span> <span class="nav-text">Groupby</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Druid"><span class="nav-number">2.2.9.</span> <span class="nav-text">Druid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OLAP%E4%B9%8BDruid%E4%B9%8B%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.10.</span> <span class="nav-text">OLAP之Druid之查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">2.2.10.1.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TopN"><span class="nav-number">2.2.10.2.</span> <span class="nav-text">TopN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap%E6%A8%A1%E5%9D%97"><span class="nav-number">2.2.11.</span> <span class="nav-text">mmap模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.2.12.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#python%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPoolExecutor-%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%AE%9E%E6%88%98"><span class="nav-number">2.2.12.1.</span> <span class="nav-text">python线程池 ThreadPoolExecutor 的用法及实战</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">2.2.12.1.1.</span> <span class="nav-text">前言</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pandas-read-csv"><span class="nav-number">2.2.13.</span> <span class="nav-text">Pandas-read_csv</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#read-csv%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.13.1.</span> <span class="nav-text">read_csv函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pycallgraph-%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%89"><span class="nav-number">2.2.14.</span> <span class="nav-text">pycallgraph 生成流程图(函数调用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AutoCode-Python-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">2.2.15.</span> <span class="nav-text">AutoCode-Python 绘制流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Crystal-FLOW"><span class="nav-number">2.2.16.</span> <span class="nav-text">Crystal FLOW </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E6%AC%BE%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%BD%AF%E4%BB%B6"><span class="nav-number">2.2.17.</span> <span class="nav-text">几款代码转流程图软件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%91%E7%9A%84TensorFlow-GPU-2-0%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF"><span class="nav-number">2.2.18.</span> <span class="nav-text">我的TensorFlow-GPU 2.0升级之路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1%E7%8E%AF%E5%A2%83%E5%88%86%E6%9E%90"><span class="nav-number">2.2.18.1.</span> <span class="nav-text">1.1环境分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">2.2.18.2.</span> <span class="nav-text">1.2参考资料</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E5%AE%89%E8%A3%85%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.2.18.3.</span> <span class="nav-text">1.3 安装的准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E5%8D%87%E7%BA%A7GPU%E9%A9%B1%E5%8A%A8"><span class="nav-number">2.2.18.4.</span> <span class="nav-text">1.4 升级GPU驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5%E5%AE%89%E8%A3%85Python3-7"><span class="nav-number">2.2.18.5.</span> <span class="nav-text">1.5安装Python3.7</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6%E5%AE%89%E8%A3%85TensorFlow-GPU-2-0"><span class="nav-number">2.2.18.6.</span> <span class="nav-text">1.6安装TensorFlow-GPU 2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-1-%E7%94%A8conda%E5%AE%89%E8%A3%85"><span class="nav-number">2.2.18.6.1.</span> <span class="nav-text">1.6.1 用conda安装</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2%E7%94%A8pip%E5%AE%89%E8%A3%85"><span class="nav-number">2.2.18.7.</span> <span class="nav-text">1.6.2用pip安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-Jupyter-notebook%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.18.8.</span> <span class="nav-text">1.7 Jupyter notebook的配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-%E5%AE%89%E8%A3%85%E9%AA%8C%E8%AF%81"><span class="nav-number">2.2.18.9.</span> <span class="nav-text">1.8 安装验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-TensorFlow%E4%B8%80%E8%88%AC%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.2.18.10.</span> <span class="nav-text">1.9 TensorFlow一般方式处理实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-1%E5%AF%BC%E5%85%A5%E9%9C%80%E8%A6%81%E7%9A%84%E5%BA%93"><span class="nav-number">2.2.18.10.1.</span> <span class="nav-text">1.9.1导入需要的库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-2%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">2.2.18.10.2.</span> <span class="nav-text">1.9.2导入数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-3%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">2.2.18.10.3.</span> <span class="nav-text">1.9.3数据预处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-4%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.18.10.4.</span> <span class="nav-text">1.9.4构建模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-5%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.18.10.5.</span> <span class="nav-text">1.9.5编译模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-6%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.18.10.6.</span> <span class="nav-text">1.9.6训练模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-7-GPU%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-number">2.2.18.10.7.</span> <span class="nav-text">1.9.7 GPU的使用情况</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-TensorFlow%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.2.18.11.</span> <span class="nav-text">1.10 TensorFlow分布式处理实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-1%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.18.11.1.</span> <span class="nav-text">1.10.1概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-2%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E5%8F%91%E5%8F%98%E9%87%8F%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%9A%84%E9%95%9C%E5%83%8F%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.18.11.2.</span> <span class="nav-text">1.10.2创建一个分发变量和图形的镜像策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-3%E5%AE%9A%E4%B9%89%E6%89%B9%E5%A4%84%E7%90%86%E7%AD%89%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.18.11.3.</span> <span class="nav-text">1.10.3定义批处理等变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-4%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8F%91"><span class="nav-number">2.2.18.11.4.</span> <span class="nav-text">1.10.4创建数据集并进行分发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-5%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.18.11.5.</span> <span class="nav-text">1.10.5创建模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-6%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="nav-number">2.2.18.11.6.</span> <span class="nav-text">1.10.6创建存储检查点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-7%E5%AE%9A%E4%B9%89%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.18.11.7.</span> <span class="nav-text">1.10.7定义损失函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-8%E5%AE%9A%E4%B9%89%E6%80%A7%E8%83%BD%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87"><span class="nav-number">2.2.18.11.8.</span> <span class="nav-text">1.10.8定义性能衡量指标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-9%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.18.11.9.</span> <span class="nav-text">1.10.9训练模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-10-GPU%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-number">2.2.18.11.10.</span> <span class="nav-text">1.10.10 GPU使用情况</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8conda%E5%AE%89%E8%A3%85TensorFlow"><span class="nav-number">2.2.18.12.</span> <span class="nav-text">1.11 建议使用conda安装TensorFlow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-%E5%AE%89%E8%A3%85PyTorch"><span class="nav-number">2.2.18.13.</span> <span class="nav-text">1.12 安装PyTorch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-%E4%BF%AE%E6%94%B9%E5%AE%89%E8%A3%85%E6%BA%90"><span class="nav-number">2.2.18.14.</span> <span class="nav-text">1.13 修改安装源</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Git"><span class="nav-number">3.</span> <span class="nav-text">Git</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#git%E5%91%BD%E4%BB%A4%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AD%A6%E4%B9%A0"><span class="nav-number">3.1.</span> <span class="nav-text">git命令交互式学习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-ssh-%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">Git ssh 配置：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%96%91%E9%9A%BE"><span class="nav-number">3.3.</span> <span class="nav-text">疑难</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Github%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E8%B6%85%E8%BF%87100M%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.1.</span> <span class="nav-text">Github如何上传超过100M的大文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-lfs%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.2.</span> <span class="nav-text">git lfs的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFgit-lfs"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">1.什么是git lfs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">2.优点是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">3.怎么安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">4.怎么使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8Blfs%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.3.</span> <span class="nav-text">删除远程lfs大文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-clone%E5%A4%A7%E6%96%87%E4%BB%B6EOF%E9%94%99%E8%AF%AF"><span class="nav-number">3.3.4.</span> <span class="nav-text">git clone大文件EOF错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6git%E5%BA%93%E7%9A%84%E8%86%A8%E8%83%80%EF%BC%9F"><span class="nav-number">3.3.5.</span> <span class="nav-text">如何控制git库的膨胀？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%B2%BE%E7%AE%80%E4%BD%A0%E7%9A%84-Git-%E4%BB%93%E5%BA%93%EF%BC%9F"><span class="nav-number">3.3.6.</span> <span class="nav-text">如何精简你的 Git 仓库？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-add%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.3.7.</span> <span class="nav-text">git add详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E7%A7%BB%E9%99%A4%E5%B7%B2%E7%BB%8Fadd%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.8.</span> <span class="nav-text">git移除已经add的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.9.</span> <span class="nav-text">提交忽略某些文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AE%BE%E7%BD%AE-gitignore"><span class="nav-number">3.3.9.1.</span> <span class="nav-text">1.设置.gitignore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">3.3.9.2.</span> <span class="nav-text">2.使用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8-git-info-exclude"><span class="nav-number">3.3.9.3.</span> <span class="nav-text">3.使用.git&#x2F;info&#x2F;exclude</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-clean%E6%B8%85%E9%99%A4%E6%9C%AA%E8%B7%9F%E8%B8%AA%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.10.</span> <span class="nav-text">git clean清除未跟踪的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9Acommit"><span class="nav-number">3.3.11.</span> <span class="nav-text">git删除指定commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9Acommit-%E7%BB%AD"><span class="nav-number">3.3.12.</span> <span class="nav-text">git删除指定commit-续</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-rebase-Vs-git-revert"><span class="nav-number">3.3.13.</span> <span class="nav-text">git rebase Vs git revert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Git%E4%B8%8A%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">3.3.14.</span> <span class="nav-text">如何删除Git上的远程文件夹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%A9%BAcommits%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95"><span class="nav-number">3.3.15.</span> <span class="nav-text">清空commits历史记录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%EF%BC%8C%E5%88%A0%E9%99%A4-git%E7%9B%AE%E5%BD%95"><span class="nav-number">3.3.15.1.</span> <span class="nav-text">进入本地仓库，删除.git目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%96%B0git%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B9%B6%E6%B7%BB%E5%8A%A0commit"><span class="nav-number">3.3.15.2.</span> <span class="nav-text">重新git初始化并添加commit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%93%BE%E6%8E%A5"><span class="nav-number">3.3.15.3.</span> <span class="nav-text">添加远程仓库链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E6%8F%90%E4%BA%A4%EF%BC%8C%E8%A6%86%E7%9B%96%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84commits%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95"><span class="nav-number">3.3.15.4.</span> <span class="nav-text">强制提交，覆盖远程仓库的commits历史记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD%E8%AE%A8%E8%AE%BA"><span class="nav-number">3.3.15.5.</span> <span class="nav-text">后续讨论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AFbranch%E5%92%8C%E4%BD%BF%E7%94%A8Pull-request"><span class="nav-number">3.3.16.</span> <span class="nav-text">创建分支branch和使用Pull request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GitHub-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%B9%B6%E4%B8%94%E6%9D%83%E9%99%90%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.17.</span> <span class="nav-text">GitHub 实现多人协同提交代码并且权限分组管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git%E5%A4%9A%E5%88%86%E6%94%AF%E5%B9%B3%E8%A1%8C%E5%8F%91%E5%B1%95%EF%BC%88%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%89"><span class="nav-number">3.3.18.</span> <span class="nav-text">Git多分支平行发展（一个仓库包含多个不同的项目）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git%E4%B8%ADsubmodule%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.19.</span> <span class="nav-text">Git中submodule的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-clone%E7%A7%BB%E5%8A%A8%E6%9C%AC%E5%9C%B0%E5%8E%82%E5%BA%93"><span class="nav-number">3.3.20.</span> <span class="nav-text">git clone移动本地厂库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E8%A3%B8%E5%85%8B%E9%9A%86"><span class="nav-number">3.3.21.</span> <span class="nav-text">git裸克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-pull%E5%92%8Cgit-fetch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.22.</span> <span class="nav-text">git pull和git fetch的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fatal-does-not-appear-to-a-git-repository"><span class="nav-number">3.3.23.</span> <span class="nav-text">fatal: does not appear to a git repository</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-fork%E4%B8%8Eclone%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.3.24.</span> <span class="nav-text">git fork与clone有什么区别及使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#git-clone"><span class="nav-number">3.3.24.1.</span> <span class="nav-text">git clone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#git-fork"><span class="nav-number">3.3.24.2.</span> <span class="nav-text">git fork</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF-git-push-origin"><span class="nav-number">3.3.25.</span> <span class="nav-text">git 推送本地分支到远程分支 git push origin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-remote%E5%85%B3%E8%81%94%E4%BA%86%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E4%BB%93%E5%BA%93"><span class="nav-number">3.3.26.</span> <span class="nav-text">git remote关联了两个或多个仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-add%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.27.</span> <span class="nav-text">git add外部文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-add-%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.28.</span> <span class="nav-text">git add 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-commit-%E6%8F%90%E4%BA%A4%E5%88%B0%E7%89%88%E6%9C%AC%E5%BA%93"><span class="nav-number">3.3.29.</span> <span class="nav-text">git commit 提交到版本库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git-%E5%BB%96%E9%9B%AA%E5%B3%B0%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3"><span class="nav-number">3.4.</span> <span class="nav-text">git 廖雪峰学习文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA"><span class="nav-number">3.4.1.</span> <span class="nav-text">工作区和暂存区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%EF%BC%88Working-Directory%EF%BC%89"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">工作区（Working Directory）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%BA%93%EF%BC%88Repository%EF%BC%89"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">版本库（Repository）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81git%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="nav-number">3.5.</span> <span class="nav-text">一、git初始化本地仓库和配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6"><span class="nav-number">3.6.</span> <span class="nav-text">二、提交文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%9B%9E%E9%80%80"><span class="nav-number">3.7.</span> <span class="nav-text">三、回退</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9F%A5%E7%9C%8Bcommit%E4%BF%A1%E6%81%AF%E5%92%8C%E5%91%BD%E4%BB%A4%E4%BF%A1%E6%81%AF"><span class="nav-number">3.7.1.</span> <span class="nav-text">1.查看commit信息和命令信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9B%9E%E9%80%80"><span class="nav-number">3.7.2.</span> <span class="nav-text">2.回退</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-HEAD%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.7.3.</span> <span class="nav-text">3.HEAD介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8Blog"><span class="nav-number">3.7.4.</span> <span class="nav-text">4.查看远程log</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%88%87%E6%8D%A2%E6%9A%82%E5%AD%98%E5%8C%BA%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8C%BA"><span class="nav-number">3.8.</span> <span class="nav-text">四、切换暂存区、工作区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-number">3.9.</span> <span class="nav-text">五、删除文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6"><span class="nav-number">3.9.1.</span> <span class="nav-text">1.删除本地文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%8C%E8%AF%AF%E5%88%A0"><span class="nav-number">3.9.2.</span> <span class="nav-text">2，误删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%AB%AF%E6%96%87"><span class="nav-number">3.9.3.</span> <span class="nav-text">3.删除远端文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">3.10.</span> <span class="nav-text">六、本地分支和远程分支</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%EF%BC%8C%E5%B8%A6%E6%98%9F%E5%8F%B7%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%93%E5%89%8D%E6%89%80%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">3.10.1.</span> <span class="nav-text">1.查看本地分支，带星号的表示当前所在本地分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">3.10.2.</span> <span class="nav-text">2.创建本地分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">3.10.3.</span> <span class="nav-text">3.创建远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%90%88%E5%B9%B6%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">3.10.4.</span> <span class="nav-text">4.合并本地分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-origin"><span class="nav-number">3.10.5.</span> <span class="nav-text">5.origin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-git-fetch-%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93"><span class="nav-number">3.10.6.</span> <span class="nav-text">6.git fetch 更新远程代码到本地仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-fetch%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">3.10.7.</span> <span class="nav-text">7.fetch更新本地仓库两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%90%88%E5%B9%B6%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">3.10.8.</span> <span class="nav-text">8.合并远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">3.10.9.</span> <span class="nav-text">9.删除本地分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">3.10.10.</span> <span class="nav-text">10.删除远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%96%B0%E5%88%86%E6%94%AF%E5%B9%B6%E5%B0%86%E6%96%B0%E5%88%86%E6%94%AF%E5%92%8C%E8%BF%9C%E7%A8%8B%E6%9F%90%E4%B8%AA%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3%E8%81%94"><span class="nav-number">3.10.11.</span> <span class="nav-text">11.创建本地新分支并将新分支和远程某个分支相关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF"><span class="nav-number">3.10.12.</span> <span class="nav-text">12.修改commit信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%88%A0%E9%99%A4commit%E4%BF%A1%E6%81%AF"><span class="nav-number">3.10.13.</span> <span class="nav-text">13.删除commit信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5"><span class="nav-number">3.11.</span> <span class="nav-text">七、分支策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81bug%E5%88%86%E6%94%AF%E5%92%8C%E6%9A%82%E5%AD%98%E5%B7%A5%E4%BD%9C%E7%8E%B0%E5%9C%BA"><span class="nav-number">3.12.</span> <span class="nav-text">八、bug分支和暂存工作现场</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-bug%E5%88%86%E6%94%AF%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">3.12.1.</span> <span class="nav-text">1.bug分支的用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BAbug%E5%88%86%E6%94%AF%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">3.12.2.</span> <span class="nav-text">2.创建bug分支的流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81feature%E5%88%86%E6%94%AF"><span class="nav-number">3.13.</span> <span class="nav-text">九、feature分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81github%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">3.14.</span> <span class="nav-text">十、github远程仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8ssh%E5%88%9B%E5%BB%BAkey"><span class="nav-number">3.14.1.</span> <span class="nav-text">1.使用ssh创建key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94"><span class="nav-number">3.14.2.</span> <span class="nav-text">2.本地仓库和远程仓库关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%85%B3%E8%81%94%E4%BB%93%E5%BA%93%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">3.14.3.</span> <span class="nav-text">3.关联仓库出现问题解决办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9C%89%E6%97%B6%E5%80%99%E4%B8%8D%E6%83%B3%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81-%E5%BB%BA%E8%AE%AE%E8%BF%98%E6%98%AF%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E5%A5%BD%EF%BC%89"><span class="nav-number">3.14.4.</span> <span class="nav-text">4.有时候不想解决冲突(建议还是解决冲突好）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><span class="nav-number">3.14.5.</span> <span class="nav-text">5.删除分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">3.14.6.</span> <span class="nav-text">6.创建远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AFcommit%E4%BF%A1%E6%81%AF%E7%94%A8%E4%BA%8E%E5%9B%9E%E9%80%80%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC"><span class="nav-number">3.14.7.</span> <span class="nav-text">7.查看远程分支commit信息用于回退到远程分支的某个版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%90%8D%E7%A7%B0"><span class="nav-number">3.14.8.</span> <span class="nav-text">8.修改远程仓库名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-fork%E5%88%AB%E4%BA%BA%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8E%E5%A6%82%E4%BD%95%E5%90%8C%E5%8E%9F%E4%BB%93%E5%BA%93%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="nav-number">3.14.9.</span> <span class="nav-text">9. fork别人的仓库后如何同原仓库保持同步更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-git-pull-can%E2%80%99t-update"><span class="nav-number">3.14.10.</span> <span class="nav-text">10. git pull can’t update</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%A4%9A%E4%BA%BA%E5%90%88%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.15.</span> <span class="nav-text">十一、多人合作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E7%89%88%E6%9C%AC%E6%A0%87%E7%AD%BE"><span class="nav-number">3.16.</span> <span class="nav-text">十二、版本标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%EF%BC%8C%E5%BF%BD%E7%95%A5%E7%89%B9%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="nav-number">3.17.</span> <span class="nav-text">十三，忽略特特殊文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Git%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">3.18.</span> <span class="nav-text">十四、自定义Git服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%94%E3%80%81git%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">3.19.</span> <span class="nav-text">十五、git常见错误及解决办法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Window-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE"><span class="nav-number">4.</span> <span class="nav-text">Window 终端配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Scoop%E9%85%8D%E7%BD%AE"><span class="nav-number">4.1.</span> <span class="nav-text">Scoop配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">4.1.1.</span> <span class="nav-text">安装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%96"><span class="nav-number">4.2.</span> <span class="nav-text">或</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86Scoop%E5%AE%89%E8%A3%85%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E5%BD%95-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.1.</span> <span class="nav-text">将Scoop安装到自定义目录(命令行方式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86Scoop%E9%85%8D%E7%BD%AE%E4%B8%BA%E5%B0%86%E5%85%A8%E5%B1%80%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E5%BD%95-SCOOP-GLOBAL-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.2.</span> <span class="nav-text">将Scoop配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E9%9D%A2%E4%B8%A4%E5%8F%A5%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">4.2.3.</span> <span class="nav-text">上面两句运行的结果(环境变量)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85"><span class="nav-number">4.3.</span> <span class="nav-text">shell工具安装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MapReduce"><span class="nav-number">5.</span> <span class="nav-text">MapReduce</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">MapReduce工作流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">6.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-1"><span class="nav-number">6.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA"><span class="nav-number">6.2.</span> <span class="nav-text">数据导出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#on-duplicate-key-update"><span class="nav-number">6.3.</span> <span class="nav-text">on duplicate key update</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">6.4.</span> <span class="nav-text">数据库查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">6.4.1.</span> <span class="nav-text">1.1使用索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E4%BC%98%E5%8C%96SQL%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.4.2.</span> <span class="nav-text">1.2优化SQL语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.4.3.</span> <span class="nav-text">1.3 优化数据库对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93"><span class="nav-number">6.5.</span> <span class="nav-text">MySQL 索引知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">6.5.1.</span> <span class="nav-text">什么是索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E5%BC%80%E5%A7%8B"><span class="nav-number">6.5.2.</span> <span class="nav-text">从一个案例开始</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E8%B1%A1"><span class="nav-number">6.5.2.1.</span> <span class="nav-text">现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">6.5.2.2.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%96%91%E9%97%AE"><span class="nav-number">6.5.2.3.</span> <span class="nav-text">疑问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.5.3.</span> <span class="nav-text">索引的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">6.5.3.1.</span> <span class="nav-text">有序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash"><span class="nav-number">6.5.3.2.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">6.5.3.3.</span> <span class="nav-text">二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91"><span class="nav-number">6.5.3.4.</span> <span class="nav-text">B+树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Innodb-B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">6.5.4.</span> <span class="nav-text">Innodb B+树索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">6.5.4.1.</span> <span class="nav-text">聚集索引和非聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Select-%E8%AF%AD%E5%8F%A5%E6%9F%A5%E6%89%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">6.5.4.2.</span> <span class="nav-text">Select 语句查找记录的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">6.5.4.3.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="nav-number">6.5.4.4.</span> <span class="nav-text">最左匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="nav-number">6.5.4.5.</span> <span class="nav-text">索引下推</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MRR-%E4%BC%98%E5%8C%96"><span class="nav-number">6.5.4.6.</span> <span class="nav-text">MRR 优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="nav-number">6.5.5.</span> <span class="nav-text">常见的索引失效场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="nav-number">6.5.5.1.</span> <span class="nav-text">失效场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">6.5.5.2.</span> <span class="nav-text">为什么会失效？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E5%88%9D%E5%A7%8B%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="nav-number">6.5.6.</span> <span class="nav-text">回到初始的案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="nav-number">6.5.7.</span> <span class="nav-text">名词解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.5.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">6.6.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%99%BB%E5%BD%95"><span class="nav-number">6.6.1.</span> <span class="nav-text">命令行登录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-2"><span class="nav-number">6.6.2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#homebrew-%E5%AE%89%E8%A3%85"><span class="nav-number">6.6.2.1.</span> <span class="nav-text">homebrew 安装</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%96%91%E9%9A%BE-1"><span class="nav-number">6.7.</span> <span class="nav-text">疑难</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">6.7.1.</span> <span class="nav-text">set设置过期时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4-1"><span class="nav-number">6.7.2.</span> <span class="nav-text">命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E6%8E%92%E5%BA%8F"><span class="nav-number">7.1.</span> <span class="nav-text">外排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hexo"><span class="nav-number">8.</span> <span class="nav-text">Hexo</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Brew-%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99"><span class="nav-number">8.1.</span> <span class="nav-text">Brew 安装报错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0github-pages%E5%8D%9A%E5%AE%A2"><span class="nav-number">8.2.</span> <span class="nav-text">利用Hexo在多台电脑上提交和更新github pages博客</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E6%96%87%E7%AB%A0"><span class="nav-number">8.3.</span> <span class="nav-text">写文章</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Markdown%E6%8F%92%E4%BB%B6"><span class="nav-number">9.</span> <span class="nav-text">Markdown插件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E9%94%AE%E5%B0%86-Word-%E8%BD%AC%E6%8D%A2%E4%B8%BA-Markdown"><span class="nav-number">9.1.</span> <span class="nav-text">一键将 Word 转换为 Markdown</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AWritage-Pandoc-%E2%80%93-%E5%8F%8C%E5%89%91%E5%90%88%E7%92%A7%EF%BC%81"><span class="nav-number">9.1.1.</span> <span class="nav-text">方法一：Writage + Pandoc – 双剑合璧！</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E5%8A%A0%E5%BF%AB%E6%8D%B7%EF%BC%88%E6%9C%89%E6%97%B6%E7%95%A5%E5%9D%91%EF%BC%89%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9AWord-to-Markdown-Converter%E5%9C%A8%E7%BA%BF%E8%BD%AC%E6%8D%A2%E7%BD%91%E9%A1%B5%EF%BC%81"><span class="nav-number">9.1.1.1.</span> <span class="nav-text">更加快捷（有时略坑）的方法二：Word to Markdown Converter在线转换网页！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="nav-number">9.1.1.2.</span> <span class="nav-text">图片的下载与存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E7%89%88word2markdown"><span class="nav-number">9.2.</span> <span class="nav-text">在线版word2markdown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ulysses-mac%E6%94%AF%E6%8C%81-%E7%BA%AF%E6%96%87%E6%9C%AC-Markdown2Word-%EF%BC%8C%E4%BD%86%E4%BB%98%E8%B4%B9"><span class="nav-number">9.3.</span> <span class="nav-text">Ulysses mac支持 纯文本 Markdown2Word ，但付费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%951-markdown-image"><span class="nav-number">9.4.</span> <span class="nav-text">方法1 markdown-image</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%952-pandoc"><span class="nav-number">9.5.</span> <span class="nav-text">方法2 pandoc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%953"><span class="nav-number">9.6.</span> <span class="nav-text">方法3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%954-picGo-GitHub-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87"><span class="nav-number">9.7.</span> <span class="nav-text">方法4 picGo+GitHub 上传图片</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E5%85%BB%E6%88%90"><span class="nav-number">10.</span> <span class="nav-text">开发养成</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-number">11.</span> <span class="nav-text">工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E8%84%91%E7%BB%B4%E6%8A%A4"><span class="nav-number">11.1.</span> <span class="nav-text">电脑维护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BA%E6%96%87%E5%B7%A5%E5%85%B7"><span class="nav-number">11.2.</span> <span class="nav-text">论文工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="nav-number">12.</span> <span class="nav-text">机器学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B-amp-%E8%B5%84%E6%96%99"><span class="nav-number">12.1.</span> <span class="nav-text">课程&amp;资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8C%E5%85%A8%E5%A5%97C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E5%B7%B2%E6%9B%B4%E6%96%B0%E5%AE%8C%E6%AF%95%EF%BC%89"><span class="nav-number">13.</span> <span class="nav-text">C++入门教程，全套C++基础教程（已更新完毕）</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小邝"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">小邝</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kuangyl-max" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kuangyl-max" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
</div>
<div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"VldYGbfDFwTUlOKd9hViAlUO-gzGzoHsz","app_key":"6N6QvtWLrytbGARKbo2g3tMS","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'VldYGbfDFwTUlOKd9hViAlUO-gzGzoHsz',
      appKey     : '6N6QvtWLrytbGARKbo2g3tMS',
      placeholder: "无需登录即可评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>



<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
