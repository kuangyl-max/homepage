<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kuangyl-max.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":5},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Gitgit命令交互式学习https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;wiki&#x2F;896043488029600 https:&#x2F;&#x2F;blog.csdn.net&#x2F;u014734886&#x2F;article&#x2F;details&#x2F;79527710 https:&#x2F;&#x2F;learngitbranching.js.org&#x2F;?locale&#x3D;zh_CN 示例：{width&#x3D;”5.540972222222222in”he">
<meta property="og:type" content="article">
<meta property="og:title" content="Git教程">
<meta property="og:url" content="https://kuangyl-max.github.io/2021/11/15/git/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="Gitgit命令交互式学习https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;wiki&#x2F;896043488029600 https:&#x2F;&#x2F;blog.csdn.net&#x2F;u014734886&#x2F;article&#x2F;details&#x2F;79527710 https:&#x2F;&#x2F;learngitbranching.js.org&#x2F;?locale&#x3D;zh_CN 示例：{width&#x3D;”5.540972222222222in”he">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-17-19-cbcb88da5f3b55ab6a6bb41c1019e995-image15-1fbb47.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180715-2020-12-05-18-07-16.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180740-2020-12-05-18-07-40.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180754-2020-12-05-18-07-55.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180805-2020-12-05-18-08-06.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/13/09-43-36-1e86b868bb36524bef9ae76be9b53dd3-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RkZGQ2NjY2cXE=,size_16,color_FFFFFF,t_70-c7a109.png">
<meta property="og:image" content="https://kuangyl-max.github.io/2021/Library/Application%2520Support/typora-user-images/image-20210107132654116.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/01/07/13-27-58-f6bfb78a8b4aac4ac07cefedd25bdc5c-image-20210107132756513-207804.png">
<meta property="og:image" content="https://pic1.zhimg.com/v2-fa1b0b20624cd7f8c31f2879e6c2820d_r.jpg?source=1940ef5c">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182720-2020-12-05-18-27-25.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182904-2020-12-05-18-29-14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183048-2020-12-05-18-30-50.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183149-2020-12-05-18-31-52.png">
<meta property="og:image" content="https://kuangyl-max.github.io/2021/Library/Application%2520Support/typora-user-images/image-20210415110322574.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-03-e0c1cd706c9becd959756c6b89e22b5f-image17-61c157.png">
<meta property="og:image" content="https://kuangyl-max.github.io/2021/workSpace/documentation/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/media/image18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/13/10-56-05-d27dfd459ca4a4fc85609d8b0eb6f231-image-20201213105603140-0d55f1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-23-2e2011e3bb51a81ccbaa15e5a905487e-image19-b07eeb.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-44-729f65c734788aa782d054c4bded528d-image20-dee2cb.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-30-06-2012268feac886848fd1c027c8329c5d--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-f0ea7f.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/21/12-48-38-701e02bf0b2d71ab51b7e2b6aa973d52-0-9b8ebd.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-07-3140921b12cc7d9a949076b2bb80d637--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-ec896c.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-41-f6ddf40f921f9953b6f84d107a11f689--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-20201205153241447-d86c8b.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205155858-2020-12-05-15-58-59.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage22.png-2020-12-05-16-32-09.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image23-2020-12-05-16-34-27.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image24-2020-12-05-16-34-46.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image25-2020-12-05-16-35-01.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image26-2020-12-05-16-35-44.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage27.png-2020-12-05-16-49-50.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-24-7d7b962a0e07f5d49418c4268577902f-image28-614ef5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-49-1d7bb19fe4188d6de19a5120f330096e-image29-5332f5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-20-1deb9320af5a425d8e1e02ca5c9184e8-image30-40c5b0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-33-3d49d3ec358fcd726421df18e3439ff2-image31-e7bed9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-47-fc603198cc94a93c22b3c1a4cf86ae01-image32-05ae14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-55-db53e89c0d0421c1afd2dc1c9e257bec-image33-a0649c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-06-7192d4ded3c4a88a0a438d4c4ae50a64-image34-e57f36.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-16-7805d35ac338422bfca0392abf72374d-image35-79c71e.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-29-3787014405122b6bab510595d1f67c8f-image36-58d7e9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-46-907a7552e60ade951ac68fefd0ae0475-image37-5a4873.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-54-7861202049bf28c4e0b02a0e0cfb9646-image38-d2549a.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-01-5f3dd4037789e1471433f7b4c6471dd8-image39-3701ae.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-14-79701861ba33c16dd061af7ab8d9fdb2-image40-3604cf.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-27-8d95fbbaac75e564a6e381a823963be1-image41-b9f423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-34-f3588fbd8ff4cc8f57fd7b52145b133d-image42-d1b4a6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-45-0117a0f019fd2f1c5b58c3d84d94fa01-image43-0c7c1c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-52-5e1c6ec87cd49947634dde35b1dbca61-image44-25d6d0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-58-1f3bf58e1d2102553824b87ab13bbd30-image45-3c423b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-14-1867d75af9c5dc305130349b6adcbd8f-image46-2d79c2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-06-ca6d1ccb0acf2b7980d2193ccd72ddc7-image47-6c2615.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-06-b5ddd5f3cf54db08d07746d951b5039f-image48-9450fb.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-44-83545c1a9844f53a24e53f3b2bca1aa6-image49-eea995.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-20-53-4c5865f227274bbf92353bbd22b50d65-image50-2cb8e9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-23-f398f7bb150853bc40db13154a57314a-image51-93b6f3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-30-80bdcc06dbf6463f2baf0a7387760fb5-image52-dea17a.png">
<meta property="og:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-37-aebe80c876b2d1692544da5a0b26cf4c-image53-1fecda.png">
<meta property="article:published_time" content="2021-11-15T05:46:40.000Z">
<meta property="article:modified_time" content="2021-11-15T12:31:52.946Z">
<meta property="article:author" content="小邝">
<meta property="article:tag" content="工具">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-17-19-cbcb88da5f3b55ab6a6bb41c1019e995-image15-1fbb47.png">

<link rel="canonical" href="https://kuangyl-max.github.io/2021/11/15/git/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Git教程 | 博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband">
<a target="_blank" rel="noopener" href="https://github.com/kuangyl-max" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kuangyl-max.github.io/2021/11/15/git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="小邝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Git教程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 13:46:40 / 修改时间：20:31:52" itemprop="dateCreated datePublished" datetime="2021-11-15T13:46:40+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
                </span>
            </span>

          
            <span id="/2021/11/15/git/" class="post-meta-item leancloud_visitors" data-flag-title="Git教程" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
	<span>℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/15/git/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/15/git/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git命令交互式学习"><a href="#git命令交互式学习" class="headerlink" title="git命令交互式学习"></a>git命令交互式学习</h2><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014734886/article/details/79527710">https://blog.csdn.net/u014734886/article/details/79527710</a></p>
<p><a target="_blank" rel="noopener" href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p>
<p>示例：<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-17-19-cbcb88da5f3b55ab6a6bb41c1019e995-image15-1fbb47.png">{width=”5.540972222222222in”<br>height=”2.9277777777777776in”}</p>
<h2 id="Git-ssh-配置："><a href="#Git-ssh-配置：" class="headerlink" title="Git ssh 配置："></a>Git ssh 配置：</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anyefrozen/p/6379046.html">https://www.cnblogs.com/anyefrozen/p/6379046.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lqlqlq007/article/details/78983879">https://blog.csdn.net/lqlqlq007/article/details/78983879</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lilygg/article/details/97919376?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/lilygg/article/details/97919376?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
<h2 id="疑难"><a href="#疑难" class="headerlink" title="疑难"></a>疑难</h2><h3 id="git下载仓库内单个文件夹内容"><a href="#git下载仓库内单个文件夹内容" class="headerlink" title="git下载仓库内单个文件夹内容"></a>git下载仓库内单个文件夹内容</h3><blockquote>
<p>git学习之git clone 克隆或下载一个仓库单个文件夹有时候因为需要我们只想gitclone下仓库的单个或多个文件夹，而不是全部的仓库内容，这样就很省事，所以下面就开始教程啦<br>在Git1.7.0以前，这无法实现，但是幸运的是在Git1.7.0以后加入了Sparse Checkout模式，这使得CheckOut指定文件或者文件夹成为可能。</p>
</blockquote>
<p><strong>现有一个test仓库<a target="_blank" rel="noopener" href="https://github.com/mygithub/test">https://github.com/mygithub/test</a></strong><br><strong>你要gitclone里面的 childfile 子目录：</strong><br><strong>在本地文件夹位置打开Git Bash 进行一下步骤</strong></p>
<h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><p>代码直接复制即可用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&#x27;childfile&#x27;</span>替换为自己要下载的文件夹名称</span></span><br><span class="line">git init test &amp;&amp; cd test     #新建仓库并进入文件夹</span><br><span class="line">git config core.sparsecheckout true #设置允许克隆子目录</span><br><span class="line">echo &#x27;childfile*&#x27; &gt;&gt; .git/info/sparse-checkout #设置要克隆的仓库的子目录路径   </span><br><span class="line">git remote add origin git@github.com:mygithub/test.git  #这里换成你要克隆的项目和库</span><br><span class="line">git pull origin master    #下载</span><br></pre></td></tr></table></figure>

<h3 id="git-clone-太慢"><a href="#git-clone-太慢" class="headerlink" title="git clone 太慢"></a>git clone 太慢</h3><p>原有git链接</p>
<p><code>https://github.com/someone/repo.git</code></p>
<p>改为如下链接之一</p>
<ul>
<li><p><code>https://hub.fastgit.org/someone/repo.git</code></p>
</li>
<li><p><code>https://gitclone.com/github.com/someone/repo.git</code></p>
</li>
<li><p><code>https://github.com.cnpmjs.org/someone/repo.git</code></p>
</li>
</ul>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone https://hub.fastgit.org/someone/repo.git</span><br><span class="line"><span class="meta">#</span><span class="bash">或者-空白文件夹</span></span><br><span class="line">git init </span><br><span class="line">git remote add origin https://hub.fastgit.org/someone/repo.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">或者-git文件夹</span></span><br><span class="line">git remote remove origin</span><br><span class="line">git remote add origin https://hub.fastgit.org/someone/repo.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果需要用完再改回到原来的git链接，可以先执行</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="meta">#</span><span class="bash">记录下git链接，之后恢复即可</span></span><br></pre></td></tr></table></figure>



<h3 id="Github如何上传超过100M的大文件"><a href="#Github如何上传超过100M的大文件" class="headerlink" title="Github如何上传超过100M的大文件"></a>Github如何上传超过100M的大文件</h3><blockquote>
<p>注意：安装 Git LFS 需要 Git 的版本不低于 1.8.5</p>
</blockquote>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><em>Linux</em></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a><em>Mac</em></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装HomeBrew </span></span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">brew install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><em>Windows</em></h4><ol>
<li>下载安装 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/github/git-lfs/releases">windows installer</a></li>
<li>运行 windows installer</li>
<li>在命令行执行 <code>git lfs install</code></li>
</ol>
<p>选择您希望Git LFS管理的文件类型（或直接编辑.gitattributes）。您可以随时配置其他文件扩展名。这一步成功后会生成一个gitattributes文件</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180715-2020-12-05-18-07-16.png" alt="学习笔记-20201205180715-2020-12-05-18-07-16"><br> 添加并commit gitattributes文件</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180740-2020-12-05-18-07-40.png" alt="学习笔记-20201205180740-2020-12-05-18-07-40"><br>然后再添加大文件到本地缓存区</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180754-2020-12-05-18-07-55.png" alt="学习笔记-20201205180754-2020-12-05-18-07-55"><br> 这里要注意一点：以上是官网步骤，我没这样走。如果你按照以上步骤走的话会还是会出现push fail(如下图)的情况，可参考我的解决办法。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180805-2020-12-05-18-08-06.png" alt="学习笔记-20201205180805-2020-12-05-18-08-06"></p>
<p>参考解决办法：</p>
<p>1-2步没变，第3步我是生成.gitattributes后 add并且commit并且把.gitattributes文件push到远程分支，合并完成后，然后再add并且commit然后再push这个大文件.</p>
<p>简单说，就是我先把这个.gitattributes跟踪文件提交上传到远程，再把大文件提交并上传到远程的，这个要注意顺序。</p>
<p>有的同学已经把大文件提交了，但是.gitattributes还没有提交，这种情况需要回滚版本，具体操作可以</p>
<h3 id="git-lfs的使用"><a href="#git-lfs的使用" class="headerlink" title="git lfs的使用"></a>git lfs的使用</h3><p>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/mianbaoshu/p/10972254.html">https://www.cnblogs.com/mianbaoshu/p/10972254.html</a></p>
<h4 id="1-什么是git-lfs"><a href="#1-什么是git-lfs" class="headerlink" title="1.什么是git lfs"></a>1.什么是git lfs</h4><p>Git LFS（Large File Storage, 大文件存储）是可以把音乐、图片、视频等指定的任意文件存在 Git 仓库之外，而在 Git 仓库中用一个占用空间 1KB 不到的文本指针来代替的小工具。通过把大文件存储在 Git 仓库之外，可以减小 Git 仓库本身的体积，使克隆 Git 仓库的速度加快，也使得 Git 不会因为仓库中充满大文件而损失性能。</p>
<h4 id="2-优点是什么"><a href="#2-优点是什么" class="headerlink" title="2.优点是什么"></a>2.优点是什么</h4><p>git每次保存diff，一些大文件发生变化时，整个仓库就会增加很大的体积，导致clone和pull的数据量大增。对于<code>git lfs</code>来说，在使用<code>git lfs track</code>命令后，git push的时候，<code>git lfs</code>会截取要管理的大文件，并将其传至<code>git lfs</code>的服务器中，从而减小仓库的体积</p>
<h4 id="3-怎么使用"><a href="#3-怎么使用" class="headerlink" title="3.怎么使用"></a>3.怎么使用</h4><ol>
<li><p>查看现有的文件追踪模式：<code>git lfs track</code></p>
</li>
<li><p>添加要管理的大文件的文件类型，比如gz文件</p>
</li>
</ol>
<p>运行命令：<code>git lfs track *.gz</code>添加类型后，查看管理文件.gitattributes，可以发现.gitattributes中新增加一行：<code>*.gz filter=lfs diff=lfs merge=lfs -text</code></p>
<ol start="3">
<li><p>将管理文件.gitattributes提交至仓库. 它保存了文件的追踪记录</p>
</li>
<li><p>获取git lfs管理的所有文件列表：git lfs ls-files </p>
</li>
<li><p>添加大文件到git仓库，和其它添加方式一样</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add my.gz</span><br><span class="line">git commit -m &quot;add gz file&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将代码 push 到远程仓库后，LFS 跟踪的文件会以『Git LFS』的形式显示:</li>
<li>clone 时 使用’git clone’ 或 <code>git lfs clone</code>均可</li>
<li>查看Git LFS 的帮助：git lfs help</li>
<li>下载被git lfs管理的文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git lfs fetch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lfs checkout</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lfs pull</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li>删除lfs里的文件</li>
</ol>
<p>如果需要删除lfs里的文件，需要在gitee后台操作，先到后台里查看文件的oid</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/13/09-43-36-1e86b868bb36524bef9ae76be9b53dd3-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RkZGQ2NjY2cXE=,size_16,color_FFFFFF,t_70-c7a109.png" alt="删除lfs"></p>
<p>然后在本地通过下面命令判断是否是能删除的文件，然后在后台操作删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --all -p -S 8a9c160e</span></span><br></pre></td></tr></table></figure>

<p><strong>删除文件后本地分支上传时可能的报错</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unable to find source for object a0ee616e6195bcb5f4136fb36b6b803566cec234f4468bda64e42a34a5f76697 (try running git lfs fetch --all)</span><br><span class="line">Uploading LFS objects:   0% (0/20), 0 B | 0 B/s, done.</span><br></pre></td></tr></table></figure>

<p>查了下这个文件是前面我删除的文件，我想要的结果是忽略这个文件接着上传，可以设置下面这个属性</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config lfs.allowincompletepush <span class="literal">true</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>git lfs track *<em>/</em>.zip 任意子目录的zip文件</p>
</blockquote>
<p><strong>参考文档</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/help/articles/4235#article-header0">Git LFS 操作指南</a></li>
</ul>
<h3 id="删除远程lfs大文件"><a href="#删除远程lfs大文件" class="headerlink" title="删除远程lfs大文件"></a>删除远程lfs大文件</h3><p>一些时候由于开发初期经验不足和贪图方便, 会把一些不应该提交到 Git 的文件上传到 Github, 带来一系列安全问题, 更有可能是把一些大文件上传到 GitHub 上, 导致项目非常臃肿, 每次 pull、push 都要花费很多时间.</p>
<p>这时候就可以寻求一些特殊的工具的帮助, <a target="_blank" rel="noopener" href="https://rtyley.github.io/bfg-repo-cleaner/">BFG Repo-Cleaner by rtyley </a>就是这样一款工具, 可以从 Git 项目中彻底删除某一个文件的历史记录.</p>
<p><strong>下载及运行</strong></p>
<p><a target="_blank" rel="noopener" href="https://rtyley.github.io/bfg-repo-cleaner/">BFG Repo-Cleaner </a>是由 Scala (一种JVM语言) 写成, 所以会被编译成 jar 包, 下载非常方便, 下载地址可在官网或直接点击 <a target="_blank" rel="noopener" href="https://search.maven.org/classic/remote_content?g=com.madgag&a=bfg&v=LATEST">bfg 下载地址 </a>.</p>
<p>但因此运行 <code>bfg.jar</code> 就需要 Java 环境, 关于 Java 环境的安装, macOS可以参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/imzhizi/p/macos-jdk-installation-homebrew.html">macOS 的 JDK 安装问题 </a>, 而 Windows 已经有很多人提过, 不做赘述.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用brew安装配置</span></span><br><span class="line">brew cask install oracle-jdk</span><br><span class="line">brew install bfg</span><br></pre></td></tr></table></figure>

<p><strong>让它完全消失</strong></p>
<ol>
<li>首先需要自行从项目中删除不想要的文件并提交, 这样能最大程度避免误删、误操作.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先需要自行从项目中删除不想要的文件</span></span><br><span class="line">rm file-to-delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交改动, 即最新分支是不包含要被删除的文件</span></span><br><span class="line">git commit -m <span class="string">&quot;删除 file-to-delete&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后使用 <code>--mirror</code> 命令裸克隆(clone)整个项目.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --mirror git@github.com:username/some-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据经验, 如果是包含大文件的项目, 使用 ssh 将会克隆的非常缓慢, 可以改用 https</span></span><br><span class="line">git <span class="built_in">clone</span> --mirror https://github.com/username/some-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候, 你的当前目录下就会产生一个名为 some-project.git 的文件夹</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接着开始删除文件历史.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据情况的不同, bfg 可选择根据文件大小删除</span></span><br><span class="line">java -jar bfg.jar --strip-blobs-bigger-than 100M some-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据情况的不同, bfg 可选择直接根据名字删除</span></span><br><span class="line">java -jar bfg.jar --delete-files name-of-file  some-project.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令中java -jar bfg.jar 可以用bfg代替</p>
</blockquote>
<ol start="4">
<li>任选以上命令执行其中一个后, 执行 <code>git gc</code> 真正删除这些文件并提交.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> some-project.git</span><br><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这时候那个文件就会消失了…</p>
<p>参考链接：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://rtyley.github.io/bfg-repo-cleaner/">https://rtyley.github.io/bfg-repo-cleaner/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/removing-sensitive-data-from-a-repository">git filter-branch：</a></p>
</li>
</ul>
<h3 id="git-clone大文件EOF错误"><a href="#git-clone大文件EOF错误" class="headerlink" title="git clone大文件EOF错误"></a>git clone大文件EOF错误</h3><p>我们常用的<code>git clone https://XXX </code>下载大文件时，加上墙的问题。会出现中断</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.com/xhang/gitlab.git</span><br><span class="line"></span><br><span class="line">正克隆到 &#x27;gitlab&#x27;...</span><br><span class="line"></span><br><span class="line">remote: Counting objects: 451995, done.</span><br><span class="line"></span><br><span class="line">remote: Compressing objects: 100% (96627/96627), done.</span><br><span class="line"></span><br><span class="line">fatal: The remote end hung up unexpectedlyB | 34.00 KiB/s</span><br><span class="line"></span><br><span class="line">fatal: 过早的文件结束符（EOF）</span><br><span class="line"></span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<p><strong>解决一：采用ssh方式</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@gitlab.com:xhang/gitlab.git</span><br></pre></td></tr></table></figure>

<p><strong>解决二：加大https缓存（推荐）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br><span class="line">git config http.postBuffer 524288000</span><br></pre></td></tr></table></figure>

<h3 id="如何控制git库的膨胀？"><a href="#如何控制git库的膨胀？" class="headerlink" title="如何控制git库的膨胀？"></a>如何控制git库的膨胀？</h3><p>根据 Git 的数据存储机制，只要通过命令 git add 将文件存储至暂存区，都会对版本库中的每一个文件，不论是图片、视频、源文件还是二进制文件生成相对应的 Blob 对象（即一段二进制数据。可以类比为<strong>url编码，</strong>通过加解码获得内容信息）。</p>
<p>如果你的项目中不小心打包进来了比较大的 word 文档或视频资源，Git 本身又识别不了该类型文件，只能当作二进制文件全量存储。所以，在其他人拉取该 word 文档更新完后再推远程分支的时候，则会使得 .git 下面的 objects 的文件夹大小迅速膨胀。</p>
<p><strong>注：如果是文本或代码等 Git 可以识别的文件，则只会存储有差异的文件。</strong></p>
<p>上面使用场景中表面上少了500M空间，实则增加了一次至少500M的历史提交记录，仓库容量反而变得更臃肿。</p>
<h3 id="github重置仓库"><a href="#github重置仓库" class="headerlink" title="github重置仓库"></a>github重置仓库</h3><p><strong>执行之前本地要有备份！！！！</strong></p>
<ol>
<li><p>在你的仓库中点击setting</p>
<p><img src="../../../Library/Application%2520Support/typora-user-images/image-20210107132654116.png" alt="image-20210107132654116"></p>
</li>
<li><p>点击Delete this repository<img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/01/07/13-27-58-f6bfb78a8b4aac4ac07cefedd25bdc5c-image-20210107132756513-207804.png" alt="image-20210107132756513"></p>
</li>
<li><p>重新创建个同名厂库</p>
</li>
<li><p>本地执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .git</span><br><span class="line">git init </span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init repos&quot;</span><br><span class="line">git remote addd origin https:&#x2F;&#x2F;hub.fastgit.org&#x2F;yourname&#x2F;your-repos.git</span><br><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注意，如果提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: RPC 失败。HTTP 413 curl 22 The requested URL returned error: 413</span><br><span class="line">fatal: 远端意外挂断了</span><br><span class="line">fatal: 远端意外挂断了</span><br></pre></td></tr></table></figure>

<p>可以尝试以下步骤</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#1.查看http.postbuffer （如果没有设置，默认值是1兆，确认目前值确实较小）</span><br><span class="line">git config --list</span><br><span class="line">#2.设置http.postbuffer ，单位byte</span><br><span class="line">git config http.postBuffer 524288000 #（512MB）</span><br><span class="line">#3.如果还是无法解决问题，将ssl验证禁止</span><br><span class="line">git config http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>禁止ssl也可在克隆时执行<code>env GIT_SSL_NO_VERIFY=true git clone https://&lt;host_name/git/project.git </code></p>
</blockquote>
<ol start="2">
<li>或者更换为ssh链接</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:yourname&#x2F;your-repos.git</span><br></pre></td></tr></table></figure>

<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/babysbreath/p/7118414.html">https://www.cnblogs.com/babysbreath/p/7118414.html</a></p>
<p><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/6b97984d7582d75da2b0bf93.html">https://jingyan.baidu.com/article/6b97984d7582d75da2b0bf93.html</a></p>
<h3 id="如何精简你的-Git-仓库？"><a href="#如何精简你的-Git-仓库？" class="headerlink" title="如何精简你的 Git 仓库？"></a>如何精简你的 Git 仓库？</h3><p><strong>第一种方案：压缩 Git 仓库。</strong></p>
<p>例如，码云项目管理中会提供存储库 GC 功能，用于清理悬空文件，压缩存储库对象，减少存储库磁盘占用。</p>
<p><img src="https://pic1.zhimg.com/v2-fa1b0b20624cd7f8c31f2879e6c2820d_r.jpg?source=1940ef5c" alt="img"></p>
<p><strong>第二种方案（推荐）：删除大文件提交记录。</strong></p>
<p>查看存储库中的大文件：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all | grep -E `git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk &#x27;&#123;print$1&#125;&#x27; | sed &#x27;:a;N;$!ba;s/\n/|/g&#x27;`</span><br></pre></td></tr></table></figure>

<p>改写历史，去除大文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --tree-filter &#x27;rm -f path/to/large/files&#x27; --tag-name-filter cat -- --all</span><br><span class="line">git push origin --tags --force</span><br><span class="line">git push origin --all --force</span><br></pre></td></tr></table></figure>

<p>并告知所有组员，push 代码前需要 pull rebase，而不是 merge，否则会从该组员的本地仓库再次引入到远程库中。</p>
<p><strong>.git文件过大，github仓库瘦身</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luchengtao11/article/details/82531044?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/luchengtao11/article/details/82531044?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
<p><strong>查看git仓库大文件并删除</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wenqibiao8/article/details/81263751">https://blog.csdn.net/wenqibiao8/article/details/81263751</a></p>
<h3 id="git-add详解"><a href="#git-add详解" class="headerlink" title="git add详解"></a>git add详解</h3><p> 一、前言<br>git add命令主要用于把我们要提交的文件的信息添加到索引库中。当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。</p>
<p>查看git add 内容 git status<br>二、基本<br><code>git add &lt;path&gt;</code>表示 add to index only files created or modified and not those deleted<br>我通常是通过<code>git add &lt;path&gt;</code>的形式把我们<code>&lt;path&gt;</code>添加到索引库中，<code>&lt;path&gt;</code>可以是文件也可以是目录。<br>git不仅能判断出<code>&lt;path&gt;</code>中，修改（不包括已删除）的文件，还能判断出新添的文件，并把它们的信息添加到索引库中。<br>三、<code>git add -u</code><br><code>git add -u </code> 表示 add to index only files modified or deleted and not those created<br><code>git add -u [&lt;path&gt;]</code>: 把<path>中所有tracked文件中被修改过或已删除文件的信息添加到索引库。它不会处理untracted的文件。<br>省略<path>表示.,即当前目录。<br>四、<code>git add -A</code><br><code>git add -A: [&lt;path&gt;]</code>表示把<path>中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。<br>省略<path>表示.,即当前目录。<br>五、<code>git add -i</code><br>我们可以通过<code>git add -i [&lt;path&gt;]命</code>令查看<path>中被所有修改过或已删除文件但没有提交的文件，<br>并通过其revert子命令可以查看<code>&lt;path&gt;</code>中所有untracted的文件，同时进入一个子命令系统。<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br><span class="line">     staged   unstaged path</span><br><span class="line">1:    +0&#x2F;-0   nothing branch&#x2F;t.txt</span><br><span class="line">2:    +0&#x2F;-0   nothing branch&#x2F;t2.txt</span><br><span class="line">3:  unchanged    +1&#x2F;-0 readme.txt</span><br></pre></td></tr></table></figure>

<p><strong>* Commands *</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: [s]tatus   2: [u]pdate   3: [r]evert   4: [a]dd untracked</span><br><span class="line">5: [p]atch   6: [d]iff    7: [q]uit    8: [h]elp</span><br></pre></td></tr></table></figure>

<p>What now&gt;<br>这里的t.txt和t2.txt表示已经被执行了git add，待提交。即已经添加到索引库中。<br>readme.txt表示已经处于tracked下，它被修改了，但是还没有被执行了git add。即还没添加到索引库中。<br>5.1、revert子命令<br>可以通过<code>git add -i</code>的revert子命令（3: <code>[r]evert</code>）把已经添加到索引库中的文件从索引库中剔除。<br>（<code>3: [r]evert</code>）表示通过3或r或revert加回车执行该命令。执行该命令后，git会例出索引库中的文件列表.<br>然后通过数字来选择。输入”1”表示git会例出索引库中的文件列表中的第1个文件。<br>“1-15”表示git会例出索引库中的文件列表中的第1个文件到第15个文件.回车将执行。<br>如果我们不输入任何东西，直接回车，将结束revert子命令，返回git add -i的主命令行。<br>5.2、update子命令<br>可以通过update子命令（2: <code>[u]pdate</code>）把已经tracked的文件添加到索引库中。其操作和revert子命令类似。<br>5.3、add untracked子命令<br>通过add untracked子命令（4: <code>[a]dd untracked</code>）可以把还没被git管理的文件添加到索引库中。其操作和revert子命令类似。<br>5.4、diff子命令<br>可以通过diff子命令（6: <code>[d]iff</code>）可以比较索引库中文件和原版本的差异。其操作和revert子命令类似。<br>5.5、status子命令<br>status子命令(1: <code>[s]tatus</code>)功能上和git add -i相似<br>5.6、quit子命令<br>quit子命令（7: <code>[q]uit</code>）用于退出git add -i命令系统<br>六、帮助<br>我们可以通过<code>git add -h</code>命令来看git add命令的帮助文档。</p>
<h3 id="git移除已经add的文件"><a href="#git移除已经add的文件" class="headerlink" title="git移除已经add的文件"></a>git移除已经add的文件</h3><p>使用 git rm 命令即可，有两种选择,<br>一种是 <code>git rm --cached</code> “文件路径”，不删除物理文件，仅将该文件从缓存中删除；<br>一种是 <code>git rm --f “文件路径”</code>，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。<br><code>[其他] </code>请问 <code>git rm --cache</code> 和 <code>git reset HEAD</code> 的区别到底在哪里呢？<br>如果要删除文件，最好用 <code>git rm file_name</code>，而不应该直接在工作区直接 <code>rm file_name</code>。<br>如果一个文件已经add到暂存区，还没有 commit，此时如果不想要这个文件了，有两种方法：<br>1，用版本库内容清空暂存区，<code>git reset HEAD</code> 但要慎重使用<br>2，只把特定文件从暂存区删除，<code>git rm --cached xxx</code></p>
<h3 id="GIT撤销修改-restore"><a href="#GIT撤销修改-restore" class="headerlink" title="GIT撤销修改 restore"></a>GIT撤销修改 restore</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dcef204dba74">https://www.jianshu.com/p/dcef204dba74</a></p>
<p>GIT 撤销修改，主要利用 <code>git restore</code> 命令。现在，我们来假象一个使用场景。当我们大半夜战至性头时，一上头不小心在文件中写了句不该写的话<code>&quot;老板是个大煞笔&quot;</code>！并且已经 <code>git add</code> 到暂存区(staged) 中了！如果再继续<code>commit</code> 的话，第二天就面临失业的风险！</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be <span class="symbol">committed:</span></span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        <span class="symbol">modified:</span>   READEME.md</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，有一个待提交文件，并且还有一个重要的提示：<strong>use “git restore –staged <file>…” to unstage</strong> ，翻译过来就是，使用 <code>git restore --staged &lt;file&gt;...</code> 可以使文件变成已修改(未执行 <code>add</code> 时  )状态。<br> 好的，是时候展现真正的技术了，命令敲起来ヾ(ﾟ∀ﾟゞ)：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git restore --staged READEME.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="symbol">commit:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        <span class="symbol">modified:</span>   READEME.md</span><br></pre></td></tr></table></figure>

<p>当我们执行 <code>store --staged</code> 命令后，再用 <code>status</code> 查看状态，会发现，文件已经变成 add 执行前的状态了。是的，这样咱们就彻底保住了工作。现在划重点，我们看下执行 <code>git restore --staged READEME.md</code> 到底发生了什么。</p>
<blockquote>
<p><strong><code>git restore --staged [file]</code></strong> : 表示从暂存区将文件的状态修改成 unstage  状态。当然，也可以不指定确切的文件 ，例如：<br><code>git restore --staged *.java</code> 表示将所有暂存区的java文件恢复状态<br><code>git restore --staged .</code> 表示将当前目录所有暂存区文件恢复状态<br>**<code>--staged</code>** 参数就是表示仅仅恢复暂存区的</p>
</blockquote>
<p>问题总结接踵而至，如果我不们不止执行了 <code>add</code> 命令，还执行了 <code>commit</code> 命令。是不是也可以利用 <code>restore</code> 命令返回呢？答案是肯定的。下面，我们介绍几个命令。</p>
<p> 我们又有错别字了，但是已经 <code>commit</code> 了，那么应该怎么办呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git restore -s HEAD~<span class="number">1</span> READEME.md  <span class="comment">// 该命名表示将版本回退到当前快照的前一个版本</span></span><br><span class="line">$ git restore -s <span class="number">91410</span>eb9  READEME.md  <span class="comment">// 改命令指定明确的 commit id ，回退到指定的快照中</span></span><br><span class="line">$ git reset --soft HEAD^  <span class="comment">// 该命令表示撤销 commit 至上一次 commit 的版本</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇文章的所有重点都集中在一个命令上 <code>restore</code> ，该命令主要有三个参数，我重点介绍一下，<code>restore</code> 命令，默认是带着 <code>--worktree</code> 参数的</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>git restore --worktree README.md</code></td>
<td align="center">表示撤销 README.md 文件工作区的的修改</td>
<td align="center">参数等同于 -W</td>
</tr>
<tr>
<td align="center"><code>git restore --staged README.md</code></td>
<td align="center">表示撤销暂存区的修改，将文件状态恢复到未 <code>add</code> 之前</td>
<td align="center">参数等同于 -S</td>
</tr>
<tr>
<td align="center"><code>git restore -s HEAD~1 README.md</code></td>
<td align="center">表示将当前工作区切换到上个 commit 版本</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>git restore -s dbv213 README.md</code></td>
<td align="center">表示将当前工作区切换到指定 commit id 的版本</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="提交忽略某些文件"><a href="#提交忽略某些文件" class="headerlink" title="提交忽略某些文件"></a>提交忽略某些文件</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mafeng/p/7635228.html">https://www.cnblogs.com/mafeng/p/7635228.html</a></p>
<h4 id="1-设置-gitignore"><a href="#1-设置-gitignore" class="headerlink" title="1.设置.gitignore"></a>1.设置.gitignore</h4><p>常用的规则：<br>1）/mtk/        过滤整个文件夹<br>2）*.zip         过滤所有.zip文件<br>3）/mtk/do.c     过滤某个具体文件</p>
<p>被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。<br>需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：<br>1）!*.zip<br>2）!/mtk/one.txt</p>
<p>唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。<br>为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么我们就需要使用：<br>1）/mtk/<br>2）!/mtk/one.txt<br>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</p>
<p>最后需要强调的一点是，<strong>如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用</strong>，Git仍然会对所有文件进行版本管理。<br>简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。因此一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦。</p>
<h4 id="2-使用命令"><a href="#2-使用命令" class="headerlink" title="2.使用命令"></a>2.使用命令</h4><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<br>正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。<br><code>git update-index --assume-unchanged FILE</code> 在FILE处输入要忽略的文件。<br>如果要还原的话，使用命令：<br><code>git update-index --no-assume-unchanged FILE</code></p>
<h4 id="3-使用-git-info-exclude"><a href="#3-使用-git-info-exclude" class="headerlink" title="3.使用.git/info/exclude"></a>3.使用.git/info/exclude</h4><p>git 还提供了另一种 exclude 的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去。用来保存的是公共的需要排除的文件。而 .git/info/exclude 这里设置的则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。</p>
<h3 id="git-clean清除未跟踪的文件"><a href="#git-clean清除未跟踪的文件" class="headerlink" title="git clean清除未跟踪的文件"></a>git clean清除未跟踪的文件</h3><p>有时做Build会引入很多之前没加入.gitignore的文件。这时你不可能每个目录每个文件地去删。<code>git clean -df </code>可帮你搞定一切。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clean -dn #这个命令可以看看有哪此文件和目录会被删</span><br><span class="line"></span><br><span class="line">git clean -f #只会删文件，不会删目录</span><br></pre></td></tr></table></figure>

<h3 id="git删除指定commit"><a href="#git删除指定commit" class="headerlink" title="git删除指定commit"></a>git删除指定commit</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lwcode6/p/11809973.html">https://www.cnblogs.com/lwcode6/p/11809973.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuluoxingkong/p/9835368.html">https://www.cnblogs.com/yuluoxingkong/p/9835368.html</a></p>
<p>或者采取以下方法</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lwcode6/p/11809973.html">https://www.cnblogs.com/lwcode6/p/11809973.html</a></p>
</blockquote>
<ol>
<li>使用<code>git log </code>命令，查看已提交的记录。例如红色圈出的commit是本次要删除的commit。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182720-2020-12-05-18-27-25.png" alt="学习笔记-20201205182720-2020-12-05-18-27-25"></p>
<ol start="2">
<li><p>先找到此次提交之前的一次提交的commit 1d6b81b138f89735265900b94fcd1ec39375e7b4</p>
</li>
<li><p>执行<code>git rebase -i 1d6b81b138f89735265900b94fcd1ec39375e7b4</code>，弹出如下页面（不包含当前commit）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182904-2020-12-05-18-29-14.png" alt="学习笔记-20201205182904-2020-12-05-18-29-14"></p>
<p>按字母I键进入编辑模式，将需要删除的commit的pick改为drop，然后按esc退出编辑，：wq保存<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183048-2020-12-05-18-30-50.png" alt="学习笔记-20201205183048-2020-12-05-18-30-50"></p>
<ol start="4">
<li>再次执行git log命令，查看已提交记录，之前红色圈出的commit记录已被删除<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183149-2020-12-05-18-31-52.png" alt="学习笔记-20201205183149-2020-12-05-18-31-52"></li>
</ol>
<h3 id="git删除指定commit-续"><a href="#git删除指定commit-续" class="headerlink" title="git删除指定commit-续"></a>git删除指定commit-续</h3><p><strong>一、删除文件</strong><br>如果需要删除的 commit 是一个或多个文件，可以进行以下操作。</p>
<ol>
<li>被提交到仓库的某个文件需要删除，可以使用 git rm 命令：<br><code>git rm &lt;file&gt; </code>// 从工作区和暂存区删除某个文件2. <code>git commit -m &quot;&quot;</code> // 再次提交到仓库<br>如果只想从暂存区删除文件，本地工作区不做出改变，可以：<br><code>git rm --cached &lt;file&gt;</code><br>如果在工作区不小心删错了某个文件，可以用 git checkout 将暂存区的文件覆盖工作区的文件，从而把误删的文件恢复：<br><code>git checkout -- &lt;file&gt;</code><br>用 <code>git rm </code>删除文件，同时还会将这个删除操作记录下来；<br>用 <code>rm 删除文件</code>，删除的仅仅是本地物理文件，没有将其从 git 的记录中剔除。</li>
<li><code>git add</code> 和 <code>git rm</code> 有相似的功能，<br>但 <code>git add</code> 仅能记录添加、改动的动作，删除的动作需靠 <code>git rm </code>来完成。<br><strong>二、GitHub 删除某次 commit</strong><br>如果需要删除的不只是某个文件，而是交错的代码，那么有以下三种方法可以删除 commit 。</li>
</ol>
<ul>
<li>git reset</li>
<li>git reset ：回滚到某次提交。</li>
<li>git reset –soft：此次提交之后的修改会被退回到暂存区。</li>
<li>git reset –hard：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的。<br>回滚代码</li>
</ul>
<p>如果需要删除的 commit 是最新的，那么可以通过 <code>git reset </code>命令将代码回滚到之前某次提交的状态，但一定要将现有的代码做好备份，否则回滚之后这些变动都会消失。具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;回滚代码</span><br><span class="line">git log &#x2F;&#x2F; 查询要回滚的 commit_id</span><br><span class="line">git reset --hard commit_id &#x2F;&#x2F; HEAD 就会指向此次的提交记录</span><br><span class="line">git push origin HEAD --force &#x2F;&#x2F; 强制推送到远端</span><br></pre></td></tr></table></figure>

<p>误删恢复</p>
<p>如果回滚代码之后发现复制错了 commit_id，或者误删了某次 commit 记录，也可以通过下方代码恢复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;误删恢复</span><br><span class="line">git relog &#x2F;&#x2F; 复制要恢复操作的前面的 hash 值</span><br><span class="line">git reset --hard hash &#x2F;&#x2F; 将 hash 换成要恢复的历史记录的 hash 值</span><br></pre></td></tr></table></figure>

<p>注意：删除中间某次提交时最好不要用<code> git reset</code> 回退远程库，因为之后其他人提交代码时用<code> git pull</code> 也会把自己的本地仓库回退到之前的版本，容易出现差错进而增加不必要的工作量。</p>
<h3 id="git-rebase-合并多次commit"><a href="#git-rebase-合并多次commit" class="headerlink" title="git rebase 合并多次commit"></a>git rebase 合并多次commit</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdlwzy/article/details/83379546?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/csdlwzy/article/details/83379546?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>
<p><strong>使用rebase命令</strong></p>
<p>想要合并前三个 commit ，使用下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>

<p>进入编辑界面，把要保留的 commit 使用pick，其他的使用squash命令，或者根据命令提示选择自己想用的命令</p>
<p><img src="../../../Library/Application%2520Support/typora-user-images/image-20210415110322574.png" alt="image-20210415110322574"></p>
<h3 id="git-rebase-Vs-git-revert"><a href="#git-rebase-Vs-git-revert" class="headerlink" title="git rebase Vs git revert"></a>git rebase Vs git revert</h3><p>git rebase：当两个分支不在一条线上，需要执行 merge 操作时使用该命令。</p>
<p><strong>撤销提交</strong><br>如果中间的某次 commit 需要删除，可以通过 <code>git rebase </code>命令实现，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;撤销提交</span><br><span class="line">git log &#x2F;&#x2F; 1.查找要删除的前一次提交的 commit_id</span><br><span class="line">git rebase -i commit_id &#x2F;&#x2F; 2.将 commit_id 替换成复制的值</span><br><span class="line">&#x2F;&#x2F;3.进入 Vim 编辑模式将要删除的 commit 前面的 &#96;pick&#96; 改成 &#96;drop&#96;</span><br><span class="line">&#x2F;&#x2F;4.保存并退出 Vim</span><br></pre></td></tr></table></figure>

<p>这样就完成了。<br><strong>解决冲突</strong><br>该命令执行时极有可能出现 reabase 冲突，可以通过以下方法解决：</p>
<ol>
<li>git diff // 查看冲突内容</li>
<li>// 手动解决冲突（冲突位置已在文件中标明）</li>
<li>git add <file> 或 git add -A // 添加</li>
<li>git rebase –continu // 继续 rebase</li>
<li>// 若还在 rebase 状态，则重复 2、3、4，直至 rebase 完成出现 applying 字样</li>
<li>git push<br><strong>git revert</strong></li>
</ol>
<ul>
<li><p>git revert：放弃某次提交。</p>
</li>
<li><p>git revert 之前的提交仍会保留在 git log 中，而此次撤销会做为一次新的提交。</p>
</li>
<li><p>git revert -m：用于对 merge 节点的操作，-m 指定具体某个提交点。<br><strong>撤销提交</strong><br>要撤销中间某次提交时，使用 <code>git revert</code> 也是一个很好的选择：</p>
<ol>
<li>git log // 查找需要撤销的 commit_id</li>
<li>git revert commit_id  // 撤销这次提交<br>撤销 merge 节点提交 如果这次提交是 merge 节点的话，则需要加上 -m 指令：git revert commit_id -m 1 // 第一个提交点</li>
<li>// 手动解决冲突</li>
<li>git add -A</li>
<li>git commit -m “”</li>
<li>git revert commit_id -m 2 // 第二个提交点</li>
<li>// 重复 2，3，4</li>
<li>git push</li>
</ol>
</li>
</ul>
<p>原文链接：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c9f131e22a60">https://www.jianshu.com/p/c9f131e22a60</a></p>
<p><strong>附： git rebase</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41629756/article/details/100731258">https://blog.csdn.net/qq_41629756/article/details/100731258</a></p>
<ol>
<li>git log先找到需要变基(rebase)的Hash ID的下一个ID(不是本身Hash值)</li>
<li>git rebase -i (Hash ID) 此时会出现两种情况<br>1）工作区有变更尚未提交</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i 121f508bc4ac7044c1dda188fc595e7029613f22</span><br><span class="line">不能变基：您有未暂存的变更。</span><br><span class="line">而且您的索引中包含未提交的变更。</span><br><span class="line">请提交或贮藏修改。</span><br></pre></td></tr></table></figure>

<p>遇到这种情况需要将变更缓存，输入git stash 存储变更后再进行第二步操作<br>2）工作区无变更<br>此时直接往下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pick f60514c5 a</span><br><span class="line">pick e52ec2e0 b</span><br><span class="line">pick b2ee5bd4 c</span><br><span class="line">pick 1e3b1ed8 d</span><br><span class="line">pick ac231a7a e</span><br><span class="line">pick 1ddd77c2 f</span><br><span class="line">pick de41e172 g</span><br><span class="line">pick bab63064 h</span><br><span class="line">pick f898eacd i</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 变基 b0279a0c..f898eacd 到 b0279a0c（9 个提交）</span><br><span class="line">#</span><br><span class="line"># 命令:</span><br><span class="line"># p, pick &#x3D; 使用提交</span><br><span class="line"># r, reword &#x3D; 使用提交，但修改提交说明</span><br><span class="line"># e, edit &#x3D; 使用提交，但停止以便进行提交修补</span><br><span class="line"># s, squash &#x3D; 使用提交，但和前一个版本融合</span><br><span class="line"># f, fixup &#x3D; 类似于 &quot;squash&quot;，但丢弃提交说明日志</span><br><span class="line"># x, exec &#x3D; 使用 shell 运行命令（此行剩余部分）</span><br><span class="line"># d, drop &#x3D; 删除提交</span><br><span class="line">#</span><br><span class="line"># 这些行可以被重新排序；它们会被从上至下地执行。</span><br><span class="line">#</span><br><span class="line"># 如果您在这里删除一行，对应的提交将会丢失。</span><br><span class="line">#</span><br><span class="line"># 然而，如果您删除全部内容，变基操作将会终止。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据提示，将pick改为适应需求的关键词即可</li>
<li>退出保存</li>
<li>输入 git stash pop 释放之前保存的缓存然后正常操作即可</li>
</ol>
<h3 id="如何删除Git上的远程文件夹"><a href="#如何删除Git上的远程文件夹" class="headerlink" title="如何删除Git上的远程文件夹"></a>如何删除Git上的远程文件夹</h3><p><strong>方法一</strong></p>
<p>这里以删除 test文件夹为案例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached test //--cached不会把本地的test删除</span><br><span class="line">git commit -m &#x27;delete test dir&#x27;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<p>如果误提交的文件夹比较多，方法一也较繁琐<br>直接修改.gitignore文件,将不需要的文件过滤掉，然后执行命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git push  -u origin master</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm -r -n --cached  */dirs/\*      #把dirs里的全部移除</span><br><span class="line"><span class="meta">#</span><span class="bash"> -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span></span><br></pre></td></tr></table></figure>

<h3 id="清空commits历史记录"><a href="#清空commits历史记录" class="headerlink" title="清空commits历史记录"></a>清空commits历史记录</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/magic-wei/p/9919277.html">https://www.cnblogs.com/magic-wei/p/9919277.html</a></p>
<p>git是当前最常见的版本控制工具，但出现以下情况时，往往需要清空commits历史记录：</p>
<ul>
<li>commits记录占用空间过大甚至远远超过版本控制文件本身大小，进行云端代码管理时会受制于空间限制，无法继续更新</li>
<li>历史记录中存在敏感信息，需要清理</li>
</ul>
<p>清理commits历史记录的核心思想是，直接删除本地的.git目录，重新建立git仓库并与远程仓库建立链接，采用强制提交的方式覆盖远程仓库的commits记录。下面是一段示例脚本。</p>
<p>参数说明：</p>
<ul>
<li>$REPO_DIR 表示需要处理的Git仓库本地目录</li>
<li><a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a>:xxxx/$REPO_DIR.git 表示远程仓库地址</li>
</ul>
<p>则可以按照如下步骤处理：</p>
<h4 id="进入本地仓库，删除-git目录"><a href="#进入本地仓库，删除-git目录" class="headerlink" title="进入本地仓库，删除.git目录"></a>进入本地仓库，删除.git目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$REPO_DIR</span></span><br><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure>

<h4 id="重新git初始化并添加commit"><a href="#重新git初始化并添加commit" class="headerlink" title="重新git初始化并添加commit"></a>重新git初始化并添加commit</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add . <span class="comment"># 重新添加所有的文件</span></span><br><span class="line">git commit -m <span class="string">&quot;restart git commit&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加远程仓库链接"><a href="#添加远程仓库链接" class="headerlink" title="添加远程仓库链接"></a>添加远程仓库链接</h4><p>在添加远程仓库时，需要设置远程仓库的代号，本教程记为<strong>origin</strong>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xxxx/<span class="variable">$REPO_DIR</span>.git</span><br></pre></td></tr></table></figure>

<p>此时，可以用<code>git remote -v</code>检查远程仓库的设置。</p>
<h4 id="强制提交，覆盖远程仓库的commits历史记录"><a href="#强制提交，覆盖远程仓库的commits历史记录" class="headerlink" title="强制提交，覆盖远程仓库的commits历史记录"></a>强制提交，覆盖远程仓库的commits历史记录</h4><p>假设提交到远程仓库的master分支，则强制提交脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master <span class="comment"># 或者 git push --force origin master</span></span><br></pre></td></tr></table></figure>

<p>强制提交之后，再看远程仓库master分支的commits记录就变成1了。</p>
<p>如果需要与上游保持同步检测，可以使用指令<code>--set-upstream origin/master</code>，即</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master --set-upstream origin/master <span class="comment"># 如果指向其他分支，可以修改为 origin/$&#123;指定分支名&#125;</span></span><br></pre></td></tr></table></figure>

<p>至此，大功告成～</p>
<h4 id="后续讨论"><a href="#后续讨论" class="headerlink" title="后续讨论"></a>后续讨论</h4><p>细心的朋友可能会发现，上述操作之后，如果你还记得历史记录中某个commit的链接，你仍然可以通过链接访问到该commit下的文件，甚至可以基于这个commit重新创建新分支。为什么会出现这种情况呢？这其实和Git本身的设计机制有关，主要是为了提高容错率，防止你因为一些误操作弄丢了某些commits进而造成无法挽回的结果。</p>
<p>实际上，这些commits并没有马上被清理掉，仅仅是你的所有分支或标签无法访问到它们，这些commits被称为unreachable commits. 它们通常会被缓存一段时间，这个周期默认是30天，你也可以通过git命令行手动修改缓存周期或者手动清理。由于Github也是建立在Git这个版本管理工具上的网站，所以它也有这个机制。虽然它们在缓存期内仍然可以被访问到，但你clone到本地并不会包含它们，也就是说，你并不能在本地删除Github上已经存在的unreachable commits，因为本地根本访问不到它们（<a target="_blank" rel="noopener" href="https://help.github.com/cn/github/committing-changes-to-your-project/commit-exists-on-github-but-not-in-my-local-clone">存在于 GitHub 上但不存在于本地克隆中的提交</a>）。如果不着急的话，你可以等30天之后再试试看是否还能访问这些unreachable commits的链接；但如果你很着急，你可以联系<a target="_blank" rel="noopener" href="https://support.github.com/">Github Support</a>帮你清理这些你不想保留的commits。</p>
<p>所以，如果你只是维护个人的文件仓库的话，不需要担心这个问题，你在新机器上clone下来的仍然是缩减大小之后的仓库，而Github上的unreachable commit会在缓存期后被清理掉。如果是与他人协作的仓库，还是谨慎使用<code>git push --force</code>这种危险的操作吧，确实遇到需要这个操作的场景时，考虑用更安全的<code>git push --force-with-lease</code>. 如果你强制提交之后发现后悔了，找到想恢复的commit的链接并创建新分支就可以找回那个commit所在历史分支之前的内容啦。</p>
<p>感谢@绿静風 发现了这个问题，促使我进一步查阅资料去完善这篇博文，在此表示感谢！</p>
<p>后续讨论的主要参考内容如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Internals-Maintenance-and-Data-Recovery">Git Internals - Maintenance and Data Recovery</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4367977/how-to-remove-a-dangling-commit-from-github">Stackoverflow - How to remove a dangling commit from GitHub?</a></li>
</ul>
<p>如果只是想删除历史记录中曾经存在（但现在并不需要）的大文件，可以参考这个Issue中的讨论：<a target="_blank" rel="noopener" href="https://github.com/18F/C2/issues/439">Consider cleaning up the .git folder to reduce the large repo size</a>git commit和git push的区别</p>
<p>git commit操作的是本地库，git push操作的是远程库。</p>
<ul>
<li>git commit是将本地修改过的文件提交到本地库中。</li>
<li>git push是将本地库中的最新信息发送给远程库。</li>
</ul>
<h3 id="创建分支branch和使用Pull-request"><a href="#创建分支branch和使用Pull-request" class="headerlink" title="创建分支branch和使用Pull request"></a>创建分支branch和使用Pull request</h3><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-03-e0c1cd706c9becd959756c6b89e22b5f-image17-61c157.png">{width=”6.052777777777778in”<br>height=”3.3958333333333335in”}<br>重点看一下base和compare，Pull request将compare的分支的更新发送给base的分支，如上图所示。点击”Create pull request”，然后填写发送Pull request的原因和描述，再点击点击”Create pull request”，完成发送。</p>
<h3 id="GitHub-实现多人协同提交代码并且权限分组管理"><a href="#GitHub-实现多人协同提交代码并且权限分组管理" class="headerlink" title="GitHub 实现多人协同提交代码并且权限分组管理"></a>GitHub 实现多人协同提交代码并且权限分组管理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34044273/article/details/86394095?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control">https://blog.csdn.net/weixin_34044273/article/details/86394095?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control</a></p>
<h3 id="Git多分支平行发展（一个仓库包含多个不同的项目）"><a href="#Git多分支平行发展（一个仓库包含多个不同的项目）" class="headerlink" title="Git多分支平行发展（一个仓库包含多个不同的项目）"></a>Git多分支平行发展（一个仓库包含多个不同的项目）</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015430066">https://segmentfault.com/a/1190000015430066</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015430066">https://segmentfault.com/a/1190000015430066</a></p>
<h3 id="Git中submodule的使用"><a href="#Git中submodule的使用" class="headerlink" title="Git中submodule的使用"></a>Git中submodule的使用</h3><p><strong>背景</strong></p>
<p>面对比较复杂的项目，我们有可能会将代码根据功能拆解成不同的子模块。主项目对子模块有依赖关系，却又并不关心子模块的内部开发流程细节。</p>
<p>这种情况下，通常不会把所有源码都放在同一个 Git 仓库中。</p>
<p>有一种比较简单的方式，是在当前工作目录下，将子模块文件夹加入到 .gitignore 文件内容中，这样主项目就能够无视子项目的存在。这样做有一个弊端就是，使用主项目的人需要有一个先验知识：需要在当前目录下放置一份某版本的子模块代码。</p>
<p>还有另外一种方式可供借鉴，可以使用 Git的 submodule 功能，也是这篇文章的主题。</p>
<p>实际上 Git<br>工具的 submodule 功能就是建立了当前项目与子模块之间的依赖关系：子模块路径、子模块的远程仓库、子模块的版本号。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87053283">https://zhuanlan.zhihu.com/p/87053283</a></p>
<h3 id="git-clone移动本地厂库"><a href="#git-clone移动本地厂库" class="headerlink" title="git clone移动本地厂库"></a>git clone移动本地厂库</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone d:/SourceRepository d:/DestinationRepository</span><br></pre></td></tr></table></figure>

<p>d:/SourceRepository:想克隆的本地仓库路径，<br>d:/DestinationRepository:想克隆去另一个地方的路径</p>
<p>例如 git clone d:/git e:/git11<br>是将d:/git的仓库（即包含隐藏文件.git的目录）克隆到 e:/git11目录下</p>
<p><img src="../../../workSpace/documentation/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/media/image18.png">{width=”7.216666666666667in”<br>height=”1.74375in”}</p>
<h3 id="git裸克隆"><a href="#git裸克隆" class="headerlink" title="git裸克隆"></a>git裸克隆</h3><p>myIdea:<strong>尤其是克隆含有超大文件的仓库时，由于工作区含有大文件的缓存，故要用<code>git clone --mirror</code></strong> 以下为–mirror后的：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/13/10-56-05-d27dfd459ca4a4fc85609d8b0eb6f231-image-20201213105603140-0d55f1.png" alt="image-20201213105603140"></p>
<p>用法1：<code>git clone &lt;repository&gt; &lt;directory&gt;</code></p>
<p>将<code>&lt;repository&gt;</code>指向的版本库创建一个克隆到<code>&lt;directory&gt;</code>目录。目录<code>&lt;directory&gt;</code>相当于克隆版本库的工作区，文件都会检出，版本库位于工作区的.git目录中</p>
<p>用法2：<code>git clone --bare &lt;repository&gt; &lt;directory.git&gt;</code></p>
<p>用法3：<code>git clone --mirror &lt;repository&gt; &lt;directory.git&gt;</code></p>
<p>用法2和用法3创建的克隆版本库都不包含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。一般约定俗成裸版本库的目录名以.git做后缀，所以上面示例中将克隆出来的裸版本库目录名写作&lt;directory.git&gt;。区别在于用法3克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用git fetch命令和上游版本库进行持续同步。</p>
<p>不使用–bare或–mirror创建出来的克隆包含工作区，这样就会产生两个包含工作区的版本库，这两个版本库对等。这两个工作区本质上没有区别，往往提交在一个版本A中进行，另一个B作为备份。只能从B执行git pull命令从A中拉回新的提交实现版本库同步，而不能从版本库A向版本库B执行git push推送操作</p>
<p>还可以通过git init的方式创建裸版本库，需要加–bare参数。</p>
<p>当执行git push命令时，如果没有设定推送的分支，而且当前分支也没有注册到远程的某个分支，将检查远程分支是否有和本地相同的分支名（如master），如果有，则推送，否则报错。</p>
<h3 id="git-pull和git-fetch的区别"><a href="#git-pull和git-fetch的区别" class="headerlink" title="git pull和git fetch的区别"></a>git pull和git fetch的区别</h3><p><strong>前言</strong></p>
<p>在我们使用git的时候用的更新代码是git fetch，git<br>pull这两条指令。但是有没有小伙伴去思考过这两者的区别呢？有经验的人总是说最好用git<br>fetch+git merge，不建议用git pull。也有人说git pull=git fetch+git<br>merge，真的是这样吗？为什么呢？既然如此为什么git还要提供这两种方式呢？</p>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41975655/article/details/82887273">https://blog.csdn.net/weixin_41975655/article/details/82887273</a></li>
</ul>
<h3 id="fatal-does-not-appear-to-a-git-repository"><a href="#fatal-does-not-appear-to-a-git-repository" class="headerlink" title="fatal: does not appear to a git repository"></a>fatal: does not appear to a git repository</h3><p>几周没用git，今天一来托管就报错，下面记录一下解决办法。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git push <span class="literal">-u</span> origin master</span><br><span class="line">fatal: <span class="string">&#x27;git@github.com/zejun_web&#x27;</span> does not appear to be a git repository</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>

<p>这是报错信息，建立了文件夹用了</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>后，也remote了，结果就是push不上去。</p>
<p>后面检查了一下remote内容</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git remote <span class="literal">-v</span></span><br><span class="line">origin  git@github.com/zejun_web (fetch)</span><br><span class="line">origin  git@github.com/zejun_web (push)</span><br></pre></td></tr></table></figure>

<p>敢情是remote命令就错了，里面少了git账号:git-ze,应该是：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:git<span class="literal">-ze</span>/zejun_web.git</span><br></pre></td></tr></table></figure>

<p>这样就知道怎么解决了，<br>先remove掉添加在远程的origin</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></table></figure>

<p>此时再用</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>就会发现没有origin了</p>
<p>再正确输入</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:git<span class="literal">-ze</span>/xxxx.git</span><br></pre></td></tr></table></figure>

<p>就可以了。</p>
<p>然后</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git push <span class="literal">-u</span> origin master</span><br><span class="line">Enumerating objects: <span class="number">7</span>, done.</span><br><span class="line">Counting objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up to 8 threads</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), <span class="number">545</span> bytes | <span class="number">272.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">7</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: Resolving deltas: <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), done.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">&#x27;master&#x27;</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/git<span class="literal">-ze</span>/zejun_web/pull/new/master</span><br><span class="line">remote:</span><br><span class="line">To github.com:git<span class="literal">-ze</span>/zejun_web.git</span><br><span class="line"> * [<span class="type">new</span> <span class="type">branch</span>]      master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里就成功啦。<br>网上查了一下还有的说要重新配置邮箱和姓名等信息的。。如果没有添加公钥的话确实还是要先在GitHub上添加公钥，如果已经添加过了，可以先用git remote<br>-v命令来检查一下添加的origin是不是代码写错了，写少了。</p>
<p>如果错了就先 git remote rm origin<br>然后最后就可以push了。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-23-2e2011e3bb51a81ccbaa15e5a905487e-image19-b07eeb.png">{width=”7.141666666666667in”<br>height=”2.248611111111111in”}</p>
<blockquote>
<p>要注意的就是第一次push的话，要加上 -u<br>在语句里，把本地master分支和远程库的master分支关联起来。</p>
</blockquote>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/python_neophyte/article/details/83381936">https://blog.csdn.net/python_neophyte/article/details/83381936</a></li>
</ul>
<h3 id="git-fork与clone有什么区别及使用场景"><a href="#git-fork与clone有什么区别及使用场景" class="headerlink" title="git fork与clone有什么区别及使用场景"></a>git fork与clone有什么区别及使用场景</h3><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><p>git clone xx 是我们比较熟悉的操作,它类似于Download功能，可以理解为将云端代码下载到我们自己电脑的本地。</p>
<p>正常的话需要我们本机安装了git，然后使用git clone [仓库地址]<br>即可将制定仓库地址代码下载到我们本机。</p>
<h4 id="git-fork"><a href="#git-fork" class="headerlink" title="git fork"></a>git fork</h4><p>我们在github上打开别人的项目，右上角会有一个fork及fork的人数。如下图：</p>
<ul>
<li><p>watch</p>
<p>就类似于关注，后续项目有任何更新都会通知你，如果设置了邮件还会邮件通知。觉得比较好的项目可以通过star进行收藏，并且收藏的同时也点了一个赞，在github中，star越多的项目肯定是越牛逼的项目了。这个也是很多面试官比较在意的，你有没有github开源项目？star多少？就是指这个了</p>
</li>
<li><p>fork<br>就是我们要讲的，我们将开源项目存储到我们自己的云端作为一个分支，我们可以进行一些bug修复或功能修改然后git pull到开源项目，如果开源项目认可，可以将你的修改合并到他们的分支。</p>
</li>
</ul>
<p>根据上面的描述大约可以知道fork的作用了。我们fork完之后，代码存储到了云端并没有下载到本地。</p>
<p>fork之后我们可以通过github账号的repositories 里找到</p>
<p><strong>两者适用场景</strong></p>
<p>Git可以多人协作完成项目，或者我写完一个项目可以开源到GitHub上，看到的小伙伴fork我的代码之后发现有BUG或者有一个地方有更好的算法可以解决，他可以在他自己的仓库里面修改源码，修改好之后他可以pull request，这样我就可以看到什么地方修改了，如果我觉得他的算法可行就可以把他的代码Merge到我的项目里面，简单说就帮我修复bug了，不用我自己动手。</p>
<p>git clone 就是他们clone到本地进行修改，然后他可以提交到clone的源码中。</p>
<h3 id="git-推送本地分支到远程分支-git-push-origin"><a href="#git-推送本地分支到远程分支-git-push-origin" class="headerlink" title="git 推送本地分支到远程分支 git push origin"></a>git 推送本地分支到远程分支 git push origin</h3><p>推送本地分支local_branch到远程分支 remote_branch并建立关联关系</p>
<p>a.远程已有remote_branch分支并且已经关联本地分支local_branch且本地已经切换到local_branch</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p> b.远程已有remote_branch分支但未关联本地分支local_branch且本地已经切换到local_branch</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="literal">-u</span> origin/remote_branch</span><br></pre></td></tr></table></figure>

<p>c.远程没有remote_branch分支并，本地已经切换到local_branch</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin local_branch:remote_branch</span><br></pre></td></tr></table></figure>

<h3 id="git-remote关联了两个或多个仓库"><a href="#git-remote关联了两个或多个仓库" class="headerlink" title="git remote关联了两个或多个仓库"></a>git remote关联了两个或多个仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看远程仓库的数量（简单信息）</span></span><br><span class="line">git remote -v</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个远程仓库的具体信息，以origin为例：</span></span><br><span class="line">git remote show origin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如关联两个仓库: github 和码云</span></span><br><span class="line"> </span><br><span class="line">git remote add origin github-url</span><br><span class="line"> </span><br><span class="line">git remote add gitee gitee-url</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支有两个：master ，test-branch</span></span><br></pre></td></tr></table></figure>

<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41287260/article/details/89743120">https://blog.csdn.net/weixin_41287260/article/details/89743120</a></li>
</ul>
<h3 id="git-add外部文件"><a href="#git-add外部文件" class="headerlink" title="git add外部文件"></a>git add外部文件</h3><p>需要把外部文件复制到仓库目录下：<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-44-729f65c734788aa782d054c4bded528d-image20-dee2cb.png">{width=”8.770833333333334in”<br>height=”2.45625in”}</p>
<h3 id="git-add-文件"><a href="#git-add-文件" class="headerlink" title="git add 文件"></a>git add 文件</h3><p>方法一 git add 添加多个文件，文件之间以空格隔开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add file1 file2 file3</span><br></pre></td></tr></table></figure>

<p>方法二 多次git add</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add file1</span><br><span class="line"></span><br><span class="line">git add file2</span><br><span class="line"></span><br><span class="line">git add file2</span><br></pre></td></tr></table></figure>

<p>方法三 添加指定目录下的文件<br>config目录下及子目录下所有文件，home目录下的所有.php文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config/*</span><br><span class="line"></span><br><span class="line">git home/*.php</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法四 git add . 添加所有的文件， 或者 git add --all 添加所有的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git add --all</span><br></pre></td></tr></table></figure>

<p>方法五 添加所有子目录(**/)下的所有.zip文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add **/*.zip </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="git-commit-提交到版本库"><a href="#git-commit-提交到版本库" class="headerlink" title="git commit 提交到版本库"></a>git commit 提交到版本库</h3><p>git add 目的是将修改文件由工作区提交到暂存区，可以多次提交<br>然后commit操作，将文件从暂存区提交到版本库</p>
<p>git commit -m &quot;add new file&quot;</p>
<h2 id="git-廖雪峰学习文档"><a href="#git-廖雪峰学习文档" class="headerlink" title="git 廖雪峰学习文档"></a>git 廖雪峰学习文档</h2><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p>先来看名词解释。</p>
<h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：<img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-30-06-2012268feac886848fd1c027c8329c5d--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-f0ea7f.png" alt="working-dir"></p>
<h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/21/12-48-38-701e02bf0b2d71ab51b7e2b6aa973d52-0-9b8ebd.jpeg" alt="git-repo"></p>
<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure>

<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>
<p>先用<code>git status</code>查看一下状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   LICENSE</span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>现在，暂存区的状态就变成这样了：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-07-3140921b12cc7d9a949076b2bb80d637--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-ec896c.jpeg" alt="git-stage"></p>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;understand how stage works&quot;</span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>

<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-41-f6ddf40f921f9953b6f84d107a11f689--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-20201205153241447-d86c8b.jpeg" alt="git-stage-after-commit"></p>
<p>git-stage视频：</p>
<p><video id="video" controls="" preload="none" poster="http://media.w3.org/2010/05/sintel/poster.png">   <source id="mp4" src="https://www.bilibili.com/video/av51227250?zw " type="video/mp4"> </video></p>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576">https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576</a></li>
</ul>
<blockquote>
<p>他人整理如下： <a target="_blank" rel="noopener" href="https://blog.csdn.net/u014734886/article/details/79527710">https://blog.csdn.net/u014734886/article/details/79527710</a></p>
</blockquote>
<h2 id="一、git初始化本地仓库和配置"><a href="#一、git初始化本地仓库和配置" class="headerlink" title="一、git初始化本地仓库和配置"></a>一、git初始化本地仓库和配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;想输入到文件的内容，一般为# 库名字&quot; &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>如果没有配置需要配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;abc@bupt.edu.cn&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;xy&quot;</span><br><span class="line"></span><br><span class="line">git config --list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还可以配置git显示颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置别名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status 使用git st 代替 git status</span><br><span class="line"></span><br><span class="line">git config --global alias.co checkout 使用git co 代替 git checkout</span><br><span class="line"></span><br><span class="line">git config --global alias.ci commit 使用git ci 代替 git commit</span><br><span class="line"></span><br><span class="line">git config --global alias.br branch 使用git br 代替 git branch</span><br></pre></td></tr></table></figure>

<p>有人丧心病狂地把lg配置成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph</span><br><span class="line">--pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)</span><br><span class="line">%C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二、提交文件"><a href="#二、提交文件" class="headerlink" title="二、提交文件"></a>二、提交文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git status  查看当前仓库的状态</span><br><span class="line"></span><br><span class="line">git diff file_name</span><br><span class="line"></span><br><span class="line">git add file2.txt file3.txt 想添加所有的文件git add .</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git commit -m &quot;提交记录文字&quot;</span><br><span class="line"></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Fixes bug&quot;</span><br></pre></td></tr></table></figure>

<p>如果发现commit信息写错了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &quot;Fixes bug #42&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、回退"><a href="#三、回退" class="headerlink" title="三、回退"></a>三、回退</h2><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205155858-2020-12-05-15-58-59.png" alt="学习笔记-20201205155858-2020-12-05-15-58-59"></p>
<h3 id="1-查看commit信息和命令信息"><a href="#1-查看commit信息和命令信息" class="headerlink" title="1.查看commit信息和命令信息"></a>1.查看commit信息和命令信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log（查看当前状态下的commit信息，不能查看以后的信息）</span><br><span class="line"></span><br><span class="line">git reflog（查看所有的命令信息）</span><br><span class="line"></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">git log -p --graph</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/98c473fb0ee2">https://www.jianshu.com/p/98c473fb0ee2</a></p>
<p>通过 git pull更新后，会显示别人修改了哪些文件。此时你想要查看某个文件的具体修改的内容，可通过下面的命令去查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log -p   + 文件名 （可查看该文件以前每一次push的修改内容）</span><br><span class="line">git log - p -1   + 文件名 （只查看该文件当前这一次的push内容）</span><br><span class="line"></span><br><span class="line">git log --graph 看到分支合并图</span><br><span class="line"></span><br><span class="line">git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-回退"><a href="#2-回退" class="headerlink" title="2.回退"></a>2.回退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id </span><br></pre></td></tr></table></figure>

<p>除了–hard参数外，还有–soft，–mixed。</p>
<p><strong>下面详细介绍这三个参数：</strong></p>
<ul>
<li><p>add表示add操作之后的结果</p>
</li>
<li><p>commit表示commit之后的结果</p>
</li>
<li><p>push:表示进行push操作之后的结果</p>
</li>
<li><p>(stash)表示在add前可能存在stash操作（即暂存工作区的操作）</p>
</li>
</ul>
<p>假设某次提交过程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init--(stash1)--add1--commit1--push1--(stash2)--add2--commit2--push2--(stash3)--add3--commit3--push3</span><br></pre></td></tr></table></figure>

<p>举例</p>
<ul>
<li><p>–hard<br>回退到某个版本commit之前的状态，进行1，2，3操作。如现在在commit2，或者add2，可以回到commit3或者commit1</p>
</li>
<li><p>–soft<br>回退到某次commit前的stage状态（即处于暂存状态），进行1操作。如现在在commit2，可以回到add1，或者add3</p>
</li>
<li><p>–mixed<br>回退到add前的状态（即处于工作区，如果有stash，需通过stash pop之后才能真的回到暂存的状态），执行1，2操作。<br>如现在在commit2，可以回退到init–(stash1)，或者commit1-push1–(stash2)，或者</p>
</li>
</ul>
<h3 id="3-HEAD介绍"><a href="#3-HEAD介绍" class="headerlink" title="3.HEAD介绍"></a>3.HEAD介绍</h3><p>HEAD指向的版本就是当前版本，<code>HEAD^</code>,前一个版本，<code>HEAD^^</code>前两个，<code>HEAD~100</code>，前100个版本</p>
<h3 id="4-查看远程log"><a href="#4-查看远程log" class="headerlink" title="4.查看远程log"></a>4.查看远程log</h3><p><code>git fetch --all </code>可以把远程的commit信息拉到本地更新到本部版本库的master<br>HEAD指针上，然后利用<code>git log</code>和<code>git reflog</code>进行查看操作</p>
<p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本，也可以用git reflog。</p>
<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<p>建议都用<code>git reflog</code></p>
<h2 id="四、切换暂存区、工作区"><a href="#四、切换暂存区、工作区" class="headerlink" title="四、切换暂存区、工作区"></a>四、切换暂存区、工作区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git stash   #暂存工作现场</span><br><span class="line"></span><br><span class="line">git stash list #会出现stash@&#123;0&#125;: WIP on dev: 6224937 add mergegit</span><br><span class="line"></span><br><span class="line">git stash pop #将暂存区的环境恢复到工作区</span><br><span class="line"></span><br><span class="line">git stash list  #此时暂存区已经没有数据了</span><br><span class="line"></span><br><span class="line">git diff HEAD -- readme.txt 查看工作区和版本库里面最新版本的区别</span><br><span class="line"></span><br><span class="line">git checkout -- readme.txt</span><br><span class="line">把工作区的修改全部撤销,其中--不能省，否则就变成切换分支了。</span><br><span class="line"></span><br><span class="line">git reset HEAD file_name</span><br><span class="line">可以把暂存区的修改撤销掉（unstage），重新放回工作区</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于git checkout可以看一下这篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuyuecs/p/7111749.html">https://www.cnblogs.com/kuyuecs/p/7111749.html</a></p>
</blockquote>
<p><strong>checkout命令用法如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">git checkout [-q] [&lt;commit&gt;] [--] &lt;paths&gt; ...</span><br><span class="line">#2</span><br><span class="line">git checkout [&lt;branch&gt;]</span><br><span class="line">#3</span><br><span class="line">git checkout [-m] [ [-b | -- orphan ] &lt;new_branch&gt;]</span><br><span class="line"> [start_point] </span><br></pre></td></tr></table></figure>

<p>用法2比用法1的区别在于，用法1包含了路径。为了避免路径和引用（或提交ID）同名而发生冲突，可以在&lt;paths&gt;前用两个连续的连字符作为分隔。用法1的&lt;commit&gt;是可选项，如果省略，则相当于从暂存区进行检出。</p>
<h2 id="五、删除文件"><a href="#五、删除文件" class="headerlink" title="五、删除文件"></a>五、删除文件</h2><h3 id="1-删除本地文件"><a href="#1-删除本地文件" class="headerlink" title="1.删除本地文件"></a>1.删除本地文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file_name</span><br><span class="line"></span><br><span class="line">git commit -m &quot;删除信息&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2，误删"><a href="#2，误删" class="headerlink" title="2，误删"></a>2，误删</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<p>用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。</p>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<ul>
<li><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
</li>
<li><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
</li>
</ul>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<h3 id="3-删除远端文"><a href="#3-删除远端文" class="headerlink" title="3.删除远端文"></a>3.删除远端文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached --force .idea&#x2F; </span><br></pre></td></tr></table></figure>

<p>删除文件不需要加-r，删除文件夹需要-r， 该文件夹路径为本地文件夹所在路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;delete .idea&#x2F;&quot; 提交记录</span><br><span class="line">git push origin master  推到远端</span><br></pre></td></tr></table></figure>


<h2 id="六、本地分支和远程分支"><a href="#六、本地分支和远程分支" class="headerlink" title="六、本地分支和远程分支"></a>六、本地分支和远程分支</h2><h3 id="1-查看本地分支，带星号的表示当前所在本地分支"><a href="#1-查看本地分支，带星号的表示当前所在本地分支" class="headerlink" title="1.查看本地分支，带星号的表示当前所在本地分支"></a>1.查看本地分支，带星号的表示当前所在本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>查看远程和本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p>如果没有成功，先<code>git fetch origin</code>，然后我们在<code>git branch -a</code></p>
<h3 id="2-创建本地分支"><a href="#2-创建本地分支" class="headerlink" title="2.创建本地分支"></a>2.创建本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch dev #创建分支dev</span><br><span class="line"></span><br><span class="line">git checkout dev #切换分支（不要随意切分支，</span><br><span class="line">#如果你在某个分支上面修改了一些东西，但没有stash，那么你切换分支后修改的东西就没有任何保存了，如果想切，请先git stash，然后git checkout dev) stash后没有stash pop，然后reset --hard</span><br><span class="line"></span><br><span class="line">git checkout -b dev #创建并切换分支也可以用于切换已有分支</span><br></pre></td></tr></table></figure>

<h3 id="3-创建远程分支"><a href="#3-创建远程分支" class="headerlink" title="3.创建远程分支"></a>3.创建远程分支</h3><p> 如果想把本地的test分支提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#提本地test支作为远程的master分支</span><br><span class="line">git push origin test:master</span><br><span class="line"></span><br><span class="line">#提交本地test分支作为远程的test分支</span><br><span class="line">git push origin test:test</span><br></pre></td></tr></table></figure>

<p>也可以在github网站直接创建</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage22.png-2020-12-05-16-32-09.png" alt="学习笔记-学习笔记mediaimage22.png-2020-12-05-16-32-09"></p>
<h3 id="4-合并本地分支"><a href="#4-合并本地分支" class="headerlink" title="4.合并本地分支"></a>4.合并本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>

<p>合并当前分支，一般先切换到需要被合并的分支，如切换到master，该命令在master分支上输入会将dev分支合并到master分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>

<p>–no-ff参数，表示禁用Fast<br>forward，用普通模式合并，合并后的历史有分支，能看出来曾经做过合并。</p>
<p>merge和rebase的区别:<a target="_blank" rel="noopener" href="https://blog.csdn.net/wh_19910525/article/details/7554489">https://blog.csdn.net/wh_19910525/article/details/7554489</a></p>
<p>git merge b # 将b分支合并到当前分支</p>
<p>git rebase b，也是把 b分支合并到当前分支</p>
<p>假设目前分支：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image23-2020-12-05-16-34-27.jpeg" alt="学习笔记-image23-2020-12-05-16-34-27"></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image24-2020-12-05-16-34-46.jpeg" alt="学习笔记-image24-2020-12-05-16-34-46"></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image25-2020-12-05-16-35-01.jpeg" alt="学习笔记-image25-2020-12-05-16-35-01"></p>
<h3 id="5-origin"><a href="#5-origin" class="headerlink" title="5.origin"></a>5.origin</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tyyking/article/details/82909099">https://blog.csdn.net/tyyking/article/details/82909099</a></p>
<p>git的服务器端(remote)端包含多个repository，每个repository可以理解为一个项目。而每个repository下有多个branch。”origin”就是指向某一个repository的指针。服务器端的”master”（强调服务器端是因为本地端也有master）就是指向某个repository的一个branch的指针。</p>
<p>这是服务器端(remote)的情况：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image26-2020-12-05-16-35-44.png" alt="学习笔记-image26-2020-12-05-16-35-44"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:JasonDu1993&#x2F;learngit.git</span><br></pre></td></tr></table></figure>

<p>关联远程库，相当于让origin等于后面这个地址</p>
<h3 id="6-git-fetch-更新远程代码到本地仓库"><a href="#6-git-fetch-更新远程代码到本地仓库" class="headerlink" title="6.git fetch 更新远程代码到本地仓库"></a>6.git fetch 更新远程代码到本地仓库</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenlogin/p/6592228.html">https://www.cnblogs.com/chenlogin/p/6592228.html</a></p>
<p>理解 fetch 的关键, 是理解 FETCH_HEAD，FETCH_HEAD指的是:<br>某个branch在服务器上的最新状态</p>
<p>当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支.</p>
<p>一般来说, 存在两种情况:</p>
<p>1）如果没有显式的指定远程分支, 则远程分支的master将作为默认的FETCH_HEAD.</p>
<p>2）如果指定了远程分支, 就将这个远程分支作为FETCH_HEAD.</p>
<p>命令1：<code>git fetch origin branch1</code></p>
<p>设定当前分支的 FETCH_HEAD’ 为远程服务器的branch1分支。这个操作是<code>git pull origin branch1</code>的第一步,<br>而对应的pull操作,并不会在本地创建新的branch。</p>
<p>同时这个命令还可以用来测试远程主机的远程分支branch1是否存在, 如果存在,<br>返回0, 如果不存在, 返回128, 抛出一个异常.</p>
<p>命令2：<code>git fetch origin branch1:branch2</code></p>
<p>使用远程branch1分支在本地创建branch2(但不会切换到该分支),如果本地不存在branch2分支,<br>则会自动创建一个新的branch2分支,</p>
<p>如果本地存在branch2分支, 并且是<code>fast forward</code>, 则自动合并两个分支,<br>否则, 会阻止以上操作.</p>
<h3 id="7-fetch更新本地仓库两种方式"><a href="#7-fetch更新本地仓库两种方式" class="headerlink" title="7.fetch更新本地仓库两种方式"></a>7.fetch更新本地仓库两种方式</h3><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">&#x2F;&#x2F;从远程的origin仓库的master分支下载代码到本地的master分支</span><br><span class="line"></span><br><span class="line">git log -p master origin&#x2F;master &#x2F;&#x2F;比较本地的仓库和远程仓库的区别</span><br><span class="line"></span><br><span class="line">git merge origin&#x2F;master</span><br><span class="line">&#x2F;&#x2F;把远程下载下来的代码合并到本地仓库，远程的和本地的合并</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:temp</span><br><span class="line">&#x2F;&#x2F;从远程的origin仓库的master分支下载到本地并新建一个分支temp</span><br><span class="line"></span><br><span class="line">git diff temp &#x2F;&#x2F;比较本地master分支和本地temp分支的不同</span><br><span class="line"></span><br><span class="line">git merge temp &#x2F;&#x2F;合并本地temp分支到本地master分支</span><br><span class="line"></span><br><span class="line">git branch -d temp &#x2F;&#x2F;删除本地temp分支</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-合并远程分支"><a href="#8-合并远程分支" class="headerlink" title="8.合并远程分支"></a>8.合并远程分支</h3><p>假设这两个分支是a和b，那么fetch a和b，checkout a，将b<br>merge(rebase)到a，push<br>a到远端。这样做，将b和a合到了一起，并且更新了本地和远端的a。如果b不需要了，可以删除远程b和本地b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin a:a #将远程a分支拉到本地a(冒号后面的a表示本地分支a)</span><br><span class="line"></span><br><span class="line">git fetch origin b:b #将远程b分支拉到本地b(冒号后面的b表示本地分支b)</span><br><span class="line"></span><br><span class="line">git checkout a #切到本地a分支</span><br><span class="line"></span><br><span class="line">git merge b   #将本地b分支合并到本地a分支上</span><br><span class="line"></span><br><span class="line">git push origin a #将本地a分支推到远程a分支</span><br><span class="line"></span><br><span class="line">git branch -d b  #删除本地分支</span><br><span class="line"></span><br><span class="line">git push origin --delete b   #删除远程b分支</span><br></pre></td></tr></table></figure>

<h3 id="9-删除本地分支"><a href="#9-删除本地分支" class="headerlink" title="9.删除本地分支"></a>9.删除本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev #删除分支</span><br></pre></td></tr></table></figure>

<h3 id="10-删除远程分支"><a href="#10-删除远程分支" class="headerlink" title="10.删除远程分支"></a>10.删除远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete dev</span><br></pre></td></tr></table></figure>

<h3 id="11-创建本地新分支并将新分支和远程某个分支相关联"><a href="#11-创建本地新分支并将新分支和远程某个分支相关联" class="headerlink" title="11.创建本地新分支并将新分支和远程某个分支相关联"></a>11.创建本地新分支并将新分支和远程某个分支相关联</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -a #查看本地和远程所有分支</span><br><span class="line"></span><br><span class="line">git checkout -b dev &#x2F;origin&#x2F;dev  #创建本地分支dev并和远程dev分支相关联同时切换到本地dev分支</span><br></pre></td></tr></table></figure>

<h3 id="12-修改commit信息"><a href="#12-修改commit信息" class="headerlink" title="12.修改commit信息"></a>12.修改commit信息</h3><p><strong>(1)没有push到远端，修改本地分支commit信息</strong></p>
<p>a. 未执行git push<br>之前可以使用如下的命令进行操作(只能撤销最近一次的commit)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git  reset --soft commit_id # (commit_id可以git reflog查看)</span><br><span class="line"></span><br><span class="line">git commit -m &quot;fix commit&quot;  #重新提交信息</span><br></pre></td></tr></table></figure>

<p>b. 如果要修改前面多出提交的历史信息，可以采用(2)里面的方法，只是不需要执行git push</p>
<p>命令总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line">git rebase -i HEAD~5</span><br></pre></td></tr></table></figure>

<p>把需要修改的commit信息前的pick改成edit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>多次重复执行前面两个命令直到更新</p>
<p><strong>(2) 已经push到远端 ，修改本地分支commit信息和远程分支commit信息</strong></p>
<p>命令总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev  #(切换到dev分支)</span><br><span class="line"></span><br><span class="line">git rebase -i HEAD~5  #(对最近5个提交记录进行rebase操作)</span><br></pre></td></tr></table></figure>

<p>把需要修改的commit信息前的pick改成edit <br>(linux下一般通过vim进行操作，即输入i进入编辑模式，修改对应内容，然后esc，接着输入:wq保存退出)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend  #(输入i进入修改模式，修改commit信息，修改完后使用esc退出修改模式，接着输入:wq保存修改)</span><br><span class="line"></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>多次重复执行前面两个命令直到更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev -f</span><br></pre></td></tr></table></figure>

<p><strong>下面是详细介绍如何修改已经push 的commit 的信息</strong><br>原文链接：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39956074/article/details/83992286">https://blog.csdn.net/qq_39956074/article/details/83992286</a> </p>
<p><strong>如何修改已经push 的commit 的信息</strong><br>A. <code>git rebase -i HEAD~5</code><br>最新提交的版本为倒数第一个版本，5表示倒数第5个版本，这个数字可以修改，如改成2</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage27.png-2020-12-05-16-49-50.png" alt="学习笔记-学习笔记mediaimage27.png-2020-12-05-16-49-50"></p>
<p>前5行即为<code>HEAD～5</code>所提交的信息，第一行为倒数第五个版本的commit信息，第五行为倒数第一个版本commit信息，每行开头是pick，然后是commit id， 然后是commit信息</p>
<p>B.输入i进入修改模式，将需要修改的commit信息前的pick改成edit，修改完后使用esc退出修改模式，接着输入:wq保存修改。</p>
<p>C.命令行输入 <code>git commit --amend</code>，输入i进入修改模式，修改commit信息，修改完后使用esc退出修改模式，接着输入:wq保存修改。</p>
<p>【注】保存之后 <code>git rebase --continue</code>还没有使用之前还可以使用<code>git commit --amend</code>继续修改这条commit信息，但如果提交了就只能从头再来了，即使用<code>git rebase -i HEAD~5 </code>把pick改成edit保存退出，然后<code>git commit --amend</code>，保存修改信息之后屏幕输出以下内容</p>
<p>保存修改后命令行会输出以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[detached HEAD fbe9591] 20190716c, bs 16, lr 0.001, maxiter 60000, steps &quot;(50000, 55000)&quot;, 8000</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Date: Mon Jul 15 18:11:43 2019 +0800</span><br><span class="line"> </span><br><span class="line">1 file changed, 3 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>D.命令行输入<code>git rebase --continue</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git rebase --continue</span><br><span class="line"> </span><br><span class="line">Stopped at 896acbdf7545b0e42ff761376a2cdbca899b445d... 20190715c, bs 8, lr 0.0025, maxiter 60000, steps &quot;(50000, 55000)&quot;, 8000</span><br><span class="line"> </span><br><span class="line">You can amend the commit now, with</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">git commit --amend</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">git rebase --continue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出这些信息是因为我们把多个pick改成了edit，因此继续修改commit信息直到全部修改完成，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git commit --amend</span><br><span class="line"> </span><br><span class="line">[detached HEAD 70929e1] 20190715e, bs 8, lr 0.0025, maxiter 60000, steps &quot;(50000, 55000)&quot;, 8000</span><br><span class="line"> </span><br><span class="line">Date: Mon Jul 15 18:19:56 2019 +0800</span><br><span class="line"> </span><br><span class="line">1 file changed, 4 insertions(+), 4 deletions(-)</span><br><span class="line"> </span><br><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git rebase --continue</span><br><span class="line"> </span><br><span class="line">Successfully rebased and updated refs&#x2F;heads&#x2F;jason.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>E.<code>git push origin dev -f</code><br>将本地更新推送到远程分支上，必须加上-f，否则我们edit的commit会添加到commit后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git push origin dev -f</span><br><span class="line"> </span><br><span class="line">Password for &#39;http:&#x2F;&#x2F;jason@git.sankuai.com&#39;: 输入密码</span><br><span class="line"> </span><br><span class="line">Counting objects: 40, done.</span><br><span class="line"> </span><br><span class="line">Delta compression using up to 12 threads.</span><br><span class="line"> </span><br><span class="line">Compressing objects: 100% (40&#x2F;40), done.</span><br><span class="line"> </span><br><span class="line">Writing objects: 100% (40&#x2F;40), 7.75 KiB | 0 bytes&#x2F;s, done.</span><br><span class="line"> </span><br><span class="line">Total 40 (delta 31), reused 0 (delta 0)</span><br><span class="line"> </span><br><span class="line">remote:</span><br><span class="line"> </span><br><span class="line">remote: Create pull request for jason:</span><br><span class="line"> </span><br><span class="line">remote: http:&#x2F;&#x2F;git.sankuai.com&#x2F;users&#x2F;lvtingxun&#x2F;repos&#x2F;mask-detection&#x2F;compare&#x2F;commits?sourceBranch&#x3D;refs&#x2F;heads&#x2F;dev</span><br><span class="line"> </span><br><span class="line">remote:</span><br><span class="line"> </span><br><span class="line">To http:&#x2F;&#x2F;jason@***.git</span><br><span class="line"> </span><br><span class="line">+ b26a84a...70929e1 dev -&gt; dev (forced update)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-删除commit信息"><a href="#13-删除commit信息" class="headerlink" title="13.删除commit信息"></a>13.删除commit信息</h3><p>git 删除远程分支上的某次提交原文：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/QQxiaoqiang1573/article/details/68074847">https://blog.csdn.net/QQxiaoqiang1573/article/details/68074847</a> </p>
<p><strong>(1) 没有push到远端，删除本地commit信息</strong></p>
<p>A.删除最后一次提交记录</p>
<p>git reflog能查看所有历史操作记录，如果只想看commit信息，可以使用git<br>log，两者都能查到commit id</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-24-7d7b962a0e07f5d49418c4268577902f-image28-614ef5.png" alt="IMG_257">{width=”5.854166666666667in”<br>height=”1.21875in”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> git revert HEAD </span><br></pre></td></tr></table></figure>

<p>将回到倒数第二次提交后的版本，但本次操作会生成commit信息进行提交（输入i进入编辑状态，编辑完信息后按ESC，接着输入:wq保存退出）</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-49-1d7bb19fe4188d6de19a5120f330096e-image29-5332f5.png" alt="IMG_258">{width=”5.822916666666667in”<br>height=”3.53125in”}</p>
<p>保存退出后输出如下，此时已经回退到倒数第二次提交的时候：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-20-1deb9320af5a425d8e1e02ca5c9184e8-image30-40c5b0.png" alt="IMG_259">{width=”5.09375in”<br>height=”0.6354166666666666in”}</p>
<p>通过git<br>log查看提交的记录，发现会生成一次新的commit信息，但是内容已经更新到之前的了</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-33-3d49d3ec358fcd726421df18e3439ff2-image31-e7bed9.png" alt="IMG_260">{width=”5.875in”<br>height=”3.5208333333333335in”}</p>
<p>或者<br><code>git reset --hard HEAD^ </code>注意后面有个^表示将回到倒数第二次提交后的版本</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-47-fc603198cc94a93c22b3c1a4cf86ae01-image32-05ae14.png" alt="IMG_261">{width=”3.3125in”<br>height=”0.3854166666666667in”}</p>
<p>操作前的提交记录</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-55-db53e89c0d0421c1afd2dc1c9e257bec-image33-a0649c.png" alt="IMG_262">{width=”5.802083333333333in”<br>height=”3.4583333333333335in”}</p>
<p>操作后的提交记录</p>
<p><code>git log</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-06-7192d4ded3c4a88a0a438d4c4ae50a64-image34-e57f36.png" alt="IMG_263">{width=”5.84375in”<br>height=”3.5104166666666665in”}</p>
<p>[注] revert会生成一次新的提交，之前commit的信息还在，reset<br>则不会保留之前的提交记录信息</p>
<p>B.删除历史提交中的某次或者多次提交记录</p>
<p>例子：删除最后一次和倒数第三次提交记录</p>
<ol>
<li><code>git log</code> 找到你要删除的最远的<code>commit id</code>，本次测试选择了红色框的commit信息进行删除，也可以通过<code>git reflog</code>查看<code>commit id</code></li>
</ol>
<p><code>git log</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-16-7805d35ac338422bfca0392abf72374d-image35-79c71e.png" alt="IMG_264">{width=”5.854166666666667in”<br>height=”4.5in”}</p>
<p>2)<code> git rebase -i HEAD~5</code><br>最新提交的版本为倒数第一个版本，5表示倒数第5个版本，这个数字可以修改，如改成3进入下面的编辑页面，或者git<br>rebase -i “commit id”^   注意后面有个^符号，加不加””都可以，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3 </span><br></pre></td></tr></table></figure>

<p>(输入i进入编辑状态，删除第一行的内容，编辑完信息后按ESC，接着输入:wq保存退出)</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-29-3787014405122b6bab510595d1f67c8f-image36-58d7e9.png" alt="IMG_265">{width=”5.8125in”<br>height=”3.1979166666666665in”}</p>
<p>删除第一行内容和第三行内容，即删除倒数第三次提交和最后一次提交的内容</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-46-907a7552e60ade951ac68fefd0ae0475-image37-5a4873.png" alt="IMG_266">{width=”4.864583333333333in”<br>height=”1.2083333333333333in”}</p>
<p>保存退出后输出如下，此时回到删除改提交之前的那次提交后的状态，即commit信息为”删除commit信息2”</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-54-7861202049bf28c4e0b02a0e0cfb9646-image38-d2549a.png" alt="IMG_267">{width=”5.854166666666667in”<br>height=”1.6041666666666667in”}</p>
<p>此时<code>git log</code>，回到了要删除commit信息前一次提交的状态</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-01-5f3dd4037789e1471433f7b4c6471dd8-image39-3701ae.png" alt="IMG_268">{width=”5.822916666666667in”<br>height=”3.3541666666666665in”}</p>
<p>但有冲突，需要解决，冲突的文件内容如下所示</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-14-79701861ba33c16dd061af7ab8d9fdb2-image40-3604cf.png" alt="IMG_269">{width=”5.875in”<br>height=”0.9270833333333334in”}</p>
<p>a)，解决冲突文件后内容如下</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-27-8d95fbbaac75e564a6e381a823963be1-image41-b9f423.png" alt="IMG_270">{width=”3.1354166666666665in”<br>height=”0.3541666666666667in”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git rebase --continue  #（直接退出文件，通过:q退出）</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-34-f3588fbd8ff4cc8f57fd7b52145b133d-image42-d1b4a6.png" alt="IMG_271">{width=”5.84375in”<br>height=”2.15625in”}</p>
<p>如果没有使用<code>git add . </code>而直接使用<code>git rebase --continue</code>会提示下面的信息</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-45-0117a0f019fd2f1c5b58c3d84d94fa01-image43-0c7c1c.png" alt="IMG_272">{width=”3.2083333333333335in”<br>height=”0.6979166666666666in”}</p>
<p>此时输出如下：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-52-5e1c6ec87cd49947634dde35b1dbca61-image44-25d6d0.png" alt="IMG_273">{width=”4.020833333333333in”<br>height=”0.6458333333333334in”}</p>
<p><code>git log</code>发现第三次和第五次提交的commit信息已经删除了</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-58-1f3bf58e1d2102553824b87ab13bbd30-image45-3c423b.png" alt="IMG_274">{width=”5.854166666666667in”<br>height=”4.385416666666667in”}</p>
<p>b) 不解决冲突，通过<code>git rebase --skip</code><br>跳过解决冲突，直接回退到第三次提交后的状态。类似于使用git reset回退</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-14-1867d75af9c5dc305130349b6adcbd8f-image46-2d79c2.png" alt="IMG_275">{width=”3.7604166666666665in”<br>height=”0.375in”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-06-ca6d1ccb0acf2b7980d2193ccd72ddc7-image47-6c2615.png" alt="IMG_276">{width=”5.854166666666667in”<br>height=”2.65625in”}</p>
<p>文件中的内容:</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-06-b5ddd5f3cf54db08d07746d951b5039f-image48-9450fb.png" alt="IMG_277">{width=”5.885416666666667in”<br>height=”0.4895833333333333in”}</p>
<p>c)，不解决冲突，通过<code>git rebase --abort</code>回到最新提交的状态，所有东西都回到rebase前，因此此时并没有删除commit信息，要想删除就得解决冲突。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-44-83545c1a9844f53a24e53f3b2bca1aa6-image49-eea995.png" alt="IMG_278">{width=”4.1875in”<br>height=”0.375in”}</p>
<p><code>git log</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-20-53-4c5865f227274bbf92353bbd22b50d65-image50-2cb8e9.png" alt="IMG_279">{width=”5.8125in”<br>height=”4.197916666666667in”}</p>
<p><strong>(2) 已经push到远端，删除本地commit信息和远程commit信息</strong></p>
<p>在(1)完成的基础上，只需要加上<code>git push orgin master -f</code><br>即可将master分支上的commit信息删除</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-23-f398f7bb150853bc40db13154a57314a-image51-93b6f3.png" alt="IMG_280">{width=”5.145833333333333in”<br>height=”1.5104166666666667in”}</p>
<p><code>git push orgin master -f</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-30-80bdcc06dbf6463f2baf0a7387760fb5-image52-dea17a.png" alt="IMG_281">{width=”6.802083333333333in”<br>height=”2.5416666666666665in”}</p>
<p>远程最新的文档内容：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-37-aebe80c876b2d1692544da5a0b26cf4c-image53-1fecda.png" alt="IMG_282">{width=”6.697916666666667in”<br>height=”2.9270833333333335in”}</p>
<h2 id="七、分支策略"><a href="#七、分支策略" class="headerlink" title="七、分支策略"></a>七、分支策略</h2><p><strong>1.在实际开发中，我们应该按照几个基本原则进行分支管理：</strong></p>
<ol>
<li><p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
</li>
<li><p>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
</li>
<li><p>每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了</p>
</li>
</ol>
<p><strong>2.分支是否推送到远程</strong></p>
<ol>
<li><p>master分支是主分支，因此要时刻与远程同步；</p>
</li>
<li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
</li>
<li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
</li>
<li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
</li>
</ol>
<p> </p>
<h2 id="八、bug分支和暂存工作现场"><a href="#八、bug分支和暂存工作现场" class="headerlink" title="八、bug分支和暂存工作现场"></a>八、bug分支和暂存工作现场</h2><h3 id="1-bug分支的用途"><a href="#1-bug分支的用途" class="headerlink" title="1.bug分支的用途"></a>1.bug分支的用途</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成又不想commit时，先把工作现场暂存，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<p> </p>
<h3 id="2-创建bug分支的流程"><a href="#2-创建bug分支的流程" class="headerlink" title="2.创建bug分支的流程"></a>2.创建bug分支的流程</h3><p>假设暂存现场在dev分支，总体流程如下：</p>
<ol>
<li><p>git stash  # 暂存工作现场（去修bug，假设bug在master分支上）</p>
</li>
<li><p>git checkout master</p>
</li>
<li><p>修改bug</p>
</li>
<li><p>git add .</p>
</li>
<li><p>git commit -m “fix bug on master”</p>
</li>
<li><p>git push origin master</p>
</li>
<li><p>git checkout dev  切到dev分支</p>
</li>
<li><p>git stash list 会出现stash@{0}: WIP on dev: 6224937 add mergegit</p>
</li>
<li><p>git stash pop 将之前本地dev分支暂存的环境恢复出来</p>
</li>
<li><p>(还可以通过 git stash apply stash@{0}进行恢复，再删除stask内容git stash drop)</p>
</li>
<li><p>git stash list  再次查看还有暂存现场没有</p>
</li>
</ol>
<p> </p>
<h2 id="九、feature分支"><a href="#九、feature分支" class="headerlink" title="九、feature分支"></a>九、feature分支</h2><p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，用<code>git branch -d &lt;name&gt;</code>，若要强行删除使用-D</p>
<p> </p>
<h2 id="十、github远程仓库"><a href="#十、github远程仓库" class="headerlink" title="十、github远程仓库"></a>十、github远程仓库</h2><h3 id="1-使用ssh创建key"><a href="#1-使用ssh创建key" class="headerlink" title="1.使用ssh创建key"></a>1.使用ssh创建key</h3><p>为了和远程库相关联需要添加key，如果不加好像每次需要输密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;***@qq.com&quot; # 后面的邮箱根据自己的情况修改</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该命令用于<br>创建id_rsa文件和id_rsa.pub文件，id_rsa是私钥，id_rsa.pub是公钥用于添加到github的ssh<br>key里面。文件位于用户目录下的.ssh文件里面</p>
<h3 id="2-本地仓库和远程仓库关联"><a href="#2-本地仓库和远程仓库关联" class="headerlink" title="2.本地仓库和远程仓库关联"></a>2.本地仓库和远程仓库关联</h3><p><strong>第一种情况：远程只有仓库没有内容时，将本地已经写好的代码关联到远程：</strong></p>
<ol>
<li><p>git init</p>
</li>
<li><p>git add .</p>
</li>
<li><p>git commit -m “first commit”</p>
</li>
<li><p>git remote add origin <a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;</a>:JasonDu1993/learngit.git</p>
</li>
<li><p>关联远程库，相当于让origin等于后面这串地址</p>
</li>
<li><p>git push -u origin master</p>
</li>
<li><p>-u只在第一次推送分支时使用，将本地master推到远程master分支上</p>
</li>
<li><p>关联完之后就可以切分支或者创建其他分支了</p>
</li>
<li><p>git checkout master</p>
</li>
<li><p>git push origin master  将到本地master分支内容推到远程master分支上</p>
</li>
<li><p>git checkout -b dev  创建本地dev分支并切换到本地dev分支</p>
</li>
<li><p>git push origin dev  将本地dev分支推到远程dev分支</p>
</li>
</ol>
<p>一般master分支和dev分支都会推到远程</p>
<p><strong>第二种情况：远程仓库有内容，直接克隆到本地</strong></p>
<ol>
<li><p>git clone <a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#111;&#x6d;">&#103;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#111;&#x6d;</a>:JasonDu1993/gitskills.git</p>
</li>
<li><p>git branch -a 查看本地分支和远程分支</p>
</li>
<li><p>git checkout -b dev origin/dev  如果本地没有dev分支将会报错</p>
</li>
<li><p>git add file_name</p>
</li>
<li><p>git commit -m “记录提交信息”</p>
</li>
<li><p>git push origin dev</p>
</li>
</ol>
<p>在GitHub上，可以任意Fork开源仓库，这样拥有fork后的仓库的读写权限，你就可以push到你fork之后的这个仓库了，当然也可以推送pull<br>request给官方仓库来贡献代码。</p>
<p> </p>
<h3 id="3-关联仓库出现问题解决办法"><a href="#3-关联仓库出现问题解决办法" class="headerlink" title="3.关联仓库出现问题解决办法"></a>3.关联仓库出现问题解决办法</h3><p>1）如果<code>git checkout -b dev origin/dev</code>迁出分支出现问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal: Cannot update paths and switch to branch &#39;dev&#39; at the same time.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Did you intend to checkout &#39;orgin&#x2F;dev&#39; which can not be resolved as</span><br><span class="line">commit?</span><br></pre></td></tr></table></figure>

<p>解决办法是先<code>git fetch</code>，再<code>git checkout -b dev origin/dev</code></p>
<p> </p>
<p>2）如果<code>git push</code>失败，先<code>git pull</code></p>
<p>如果<code>git pull</code>失败，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p>
<p><code>git branch --set-upstream dev origin/dev</code>，（现在好像改成<code>git branch --set-upstream-to=origin/dev dev</code>）</p>
<p>然后在<code>git pull</code>，<code>git push origin master</code></p>
<p> </p>
<p>3） <code>git error: RPC failed; result=22, HTTP code = 411</code><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/love_rongrong/article/details/12557347">https://blog.csdn.net/love_rongrong/article/details/12557347</a></p>
<p>解决办法：改一下git的传输字节限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config http.postBuffer  524288000</span><br></pre></td></tr></table></figure>

<p>4）<code>error: RPC failed; result=22, HTTP code = 413</code></p>
<p>fatal: The remote end hung up unexpectedly </p>
<p>fatal: The remote end hung up unexpectedly</p>
<p>Everything up-to-date</p>
<p>这两个错误看上去相似，一个是411，一个是413</p>
<p>下面这个错误添加一下密钥就可以了</p>
<p>首先<code>ssh-keygen -t rsa -C &quot;abc@bupt.edu.cn&quot;</code>生成密钥</p>
<p> </p>
<h3 id="4-有时候不想解决冲突-建议还是解决冲突好）"><a href="#4-有时候不想解决冲突-建议还是解决冲突好）" class="headerlink" title="4.有时候不想解决冲突(建议还是解决冲突好）"></a>4.有时候不想解决冲突(建议还是解决冲突好）</h3><ol>
<li>从远处拉取最新的东西到本地（不想解决冲突直接接受远程仓库内容）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &#x2F;&#x2F;至少下载到本地不进行合并</span><br><span class="line"></span><br><span class="line">git reset --hard origin&#x2F;dev</span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>2)，将本地更新强制推到远程，不想解决和远程的冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin dev 或者git push -f origin dev</span><br></pre></td></tr></table></figure>


<h3 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5.删除分支"></a>5.删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#删除远程分支</span><br><span class="line">git push origin --delete dev</span><br><span class="line"></span><br><span class="line">#删除本地分支</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>

<h3 id="6-创建远程分支"><a href="#6-创建远程分支" class="headerlink" title="6.创建远程分支"></a>6.创建远程分支</h3><p> 如果想把本地的test分支提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin test:master   #提交本地test分支作为远程的master分支</span><br><span class="line"></span><br><span class="line">git push origin test:test  #提交本地test分支作为远程的test分支</span><br></pre></td></tr></table></figure>

<h3 id="7-查看远程分支commit信息用于回退到远程分支的某个版本"><a href="#7-查看远程分支commit信息用于回退到远程分支的某个版本" class="headerlink" title="7.查看远程分支commit信息用于回退到远程分支的某个版本"></a>7.查看远程分支commit信息用于回退到远程分支的某个版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>


<h3 id="8-修改远程仓库名称"><a href="#8-修改远程仓库名称" class="headerlink" title="8.修改远程仓库名称"></a>8.修改远程仓库名称</h3><p>1) 在本地仓库删除远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin 1</span><br></pre></td></tr></table></figure>

<p>2 )修改Github仓库名称： </p>
<p>在Github页面中，进入要修改的仓库，在页面上方选择”Settings”，即可重命名远程仓库。</p>
<ol start="3">
<li>添加新的远程仓库：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;JasonDu1993&#x2F;gitskill.git</span><br></pre></td></tr></table></figure>

<h3 id="9-fork别人的仓库后如何同原仓库保持同步更新"><a href="#9-fork别人的仓库后如何同原仓库保持同步更新" class="headerlink" title="9. fork别人的仓库后如何同原仓库保持同步更新"></a>9. fork别人的仓库后如何同原仓库保持同步更新</h3><p>Github进行fork后如何与原仓库同步l原文链接：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/matrix_google/article/details/80676034">https://blog.csdn.net/matrix_google/article/details/80676034</a> </p>
<p>1）git remote -v #查看远程目录地址</p>
<p>2）git branch -a  #查看所有分支情况</p>
<p>3）git remote add upstream 你fork之前的源仓库地址 #该操作将源仓库和上游代码库upstream相关联（重要1）</p>
<p>4）git remote -v #再次查看远程目录的地址</p>
<p>5）git stash  #暂存自己的工作状态（不是必须的，如果改了代码没有push则需要）</p>
<p>6）git fetch upstream  #抓取源仓库的修改文件（重要2）</p>
<p>7）git branch -a  #再次查看所有分支情况</p>
<p>8）git checkout master #切换到master分支</p>
<p>9）git merge upstream/master #将本地代码和源代码保持同步（最重要3）</p>
<p>10）git stash pop #将暂存区的环境恢复到工作区上传到远程仓库</p>
<p>11）git add .</p>
<p>12）git commit -m “update forked repository at 2019.06.05”</p>
<p>13）git push origin master #上传新的代码到自己的远程master分支</p>
<h3 id="10-git-pull-can’t-update"><a href="#10-git-pull-can’t-update" class="headerlink" title="10. git pull can’t update"></a>10. git pull can’t update</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No tracked branch configured for branch dev or the branch doesn&#39;t</span><br><span class="line">exist. To make your branch track a remote branch call, for example, git</span><br><span class="line">branch --set-upstream-to origin&#x2F;dev dev</span><br></pre></td></tr></table></figure>

<h2 id="十一、多人合作流程"><a href="#十一、多人合作流程" class="headerlink" title="十一、多人合作流程"></a>十一、多人合作流程</h2><p>因此，多人协作的工作模式通常是这样：</p>
<p>首先，可以试图用git push origin branch-name推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p>
<p>如果git pull提示”no tracking<br>information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p> </p>
<h2 id="十二、版本标签"><a href="#十二、版本标签" class="headerlink" title="十二、版本标签"></a>十二、版本标签</h2><p>标签用于发布版本时使用，相当于给某次commit取个名字</p>
<p><strong>1，添加标签</strong></p>
<ul>
<li><p><code>git tag &lt;name&gt; </code>用于新建一个标签一般取名name为v0.1等，默认为HEAD，也可以指定一个<code>commit id</code></p>
</li>
<li><p><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; </code>可以指定标签信息</p>
</li>
<li><p><code>git tag </code>可以查看所有标签</p>
</li>
</ul>
<p> </p>
<p><strong>2，删除标签</strong></p>
<ul>
<li><p><code>git tag -d &lt;tagname&gt; </code>删除一个本地标签</p>
</li>
<li><p><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除一个远程标签</p>
</li>
<li><p><code>git push origin &lt;tagname&gt; </code>推送一个本地标签</p>
</li>
<li><p><code>git push origin --tags</code> 推送全部未推送过的本地标签</p>
</li>
</ul>
<p> </p>
<h2 id="十三，忽略特特殊文件"><a href="#十三，忽略特特殊文件" class="headerlink" title="十三，忽略特特殊文件"></a>十三，忽略特特殊文件</h2><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件，同时提交这个文件到Git。</p>
<p> </p>
<p>例子如下，.gitignore文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line"></span><br><span class="line">Thumbs.db</span><br><span class="line"></span><br><span class="line">ehthumbs.db</span><br><span class="line"></span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line"></span><br><span class="line">*.py[cod]</span><br><span class="line"></span><br><span class="line">*.so</span><br><span class="line"></span><br><span class="line">*.egg</span><br><span class="line"></span><br><span class="line">*.egg-info</span><br><span class="line"></span><br><span class="line">dist</span><br><span class="line"></span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># iead</span><br><span class="line"></span><br><span class="line">.idea</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line"></span><br><span class="line">db.ini</span><br><span class="line"></span><br><span class="line">deploy_key_rsa</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>忽略文件的原则是：</p>
<ol>
<li><p>忽略操作系统自动生成的文件，比如缩略图等；</p>
</li>
<li><p>忽略编译生成的中间文件、可执行文件等，比如Java编译产生的.class文件；</p>
</li>
<li><p>忽略敏感信息的配置文件，比如存放口令的配置文件。</p>
</li>
</ol>
<p> </p>
<h2 id="十四、自定义Git服务器"><a href="#十四、自定义Git服务器" class="headerlink" title="十四、自定义Git服务器"></a>十四、自定义Git服务器</h2><p>假设你已经有sudo权限的用户账号并且该教程是在ubuntu下介绍的</p>
<ol>
<li>安装git：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个git用户，用来运行git服务：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建证书登录：<br>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</li>
<li>初始化Git仓库：</li>
</ol>
<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在/srv目录下输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git init --bare sample.git</span><br></pre></td></tr></table></figure>

<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>禁用shell登录：</li>
</ol>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p>
<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash </code><br>改为：</p>
<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code></p>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<ol start="6">
<li>克隆远程仓库：</li>
</ol>
<p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone git@server:&#x2F;srv&#x2F;sample.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cloning into &#39;sample&#39;...</span><br><span class="line"></span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>管理公钥</strong></p>
<p>如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。</p>
<p><strong>管理权限</strong></p>
<p>使用<strong>Gitolite</strong>就是这个工具管理权限</p>
<h2 id="十五、git常见错误及解决办法"><a href="#十五、git常见错误及解决办法" class="headerlink" title="十五、git常见错误及解决办法"></a>十五、git常见错误及解决办法</h2><p><strong>1.git缓存太小下载不下来大文件</strong></p>
<p>解决：<code>git config --global http.postBuffer 524288000</code></p>
<p><strong>2.有图片文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#39;survivors&#39;...</span><br><span class="line"></span><br><span class="line">remote: Counting objects: 124, done.</span><br><span class="line"></span><br><span class="line">remote: Compressing objects: 100% (120&#x2F;120), done.</span><br><span class="line"></span><br><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data</span><br><span class="line">remaining</span><br><span class="line"></span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line"></span><br><span class="line">fatal: early EOF</span><br><span class="line"></span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<p>解决：<code>git clone http://github.com/large-repository --depth 1</code></p>
<p><strong>3.更完美的解决下载不下来方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data</span><br><span class="line">remaining</span><br><span class="line"></span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line"></span><br><span class="line">fatal: early EOF</span><br><span class="line"></span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>方法一：<code>git config --global http.postBuffer 524288000</code></p>
<p>如果不行</p>
<p>方法二：<code>git clone http://github.com/large-repository --depth 1</code></p>
<p>如果还不行</p>
<p>方法三：一般clone http方式的容易产生此问题，改成SSH的方式也有效，即https://改为git://</p>
<p><strong>4.git remote: HTTP Basic: Access denied 错误解决办法</strong></p>
<p>来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lydiawork/p/10287797.html">https://www.cnblogs.com/lydiawork/p/10287797.html</a></p>
<p>问题描述：<br>git push 报 HTTP Basic: Access denied 错误</p>
<p>原因：本地git配置的用户名、密码与gitlabs上注册的用户名、密码不一致。<br><strong>解决方案：</strong></p>
<ol>
<li>如果账号密码有变动 用这个命令 <code>git config --system --unset credential.helper</code> 重新输入账号密码 应该就能解决了</li>
<li>如果用了第一个命令 还不能解决问题那么 用这个命令：<br><code>  git config --global http.emptyAuth true</code><br>3.如果以上两个方法不起作用，那么采用以下方法：</li>
</ol>
<p>进入控制面板》用户账号》凭据管理器？windows凭据》普通凭据，在里面找到git，点开编辑密码，更新为最新密码之后就可以正常操作了。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>小邝
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kuangyl-max.github.io/2021/11/15/git/" title="Git教程">https://kuangyl-max.github.io/2021/11/15/git/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag"># 工具</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/15/docker/" rel="prev" title="Docker教程">
      <i class="fa fa-chevron-left"></i> Docker教程
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
<div>
    
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------ 本文结束------</div>
    
</div>
    
 </div>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Git"><span class="nav-number">1.</span> <span class="nav-text">Git</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#git%E5%91%BD%E4%BB%A4%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.</span> <span class="nav-text">git命令交互式学习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-ssh-%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">Git ssh 配置：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%96%91%E9%9A%BE"><span class="nav-number">1.3.</span> <span class="nav-text">疑难</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E4%B8%8B%E8%BD%BD%E4%BB%93%E5%BA%93%E5%86%85%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E5%AE%B9"><span class="nav-number">1.3.1.</span> <span class="nav-text">git下载仓库内单个文件夹内容</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">1.3.1.0.0.1.</span> <span class="nav-text">步骤：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-clone-%E5%A4%AA%E6%85%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">git clone 太慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Github%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E8%B6%85%E8%BF%87100M%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.3.</span> <span class="nav-text">Github如何上传超过100M的大文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mac"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Mac</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">Windows</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-lfs%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">git lfs的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFgit-lfs"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1.什么是git lfs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">2.优点是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3.怎么使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8Blfs%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.5.</span> <span class="nav-text">删除远程lfs大文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-clone%E5%A4%A7%E6%96%87%E4%BB%B6EOF%E9%94%99%E8%AF%AF"><span class="nav-number">1.3.6.</span> <span class="nav-text">git clone大文件EOF错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6git%E5%BA%93%E7%9A%84%E8%86%A8%E8%83%80%EF%BC%9F"><span class="nav-number">1.3.7.</span> <span class="nav-text">如何控制git库的膨胀？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#github%E9%87%8D%E7%BD%AE%E4%BB%93%E5%BA%93"><span class="nav-number">1.3.8.</span> <span class="nav-text">github重置仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%B2%BE%E7%AE%80%E4%BD%A0%E7%9A%84-Git-%E4%BB%93%E5%BA%93%EF%BC%9F"><span class="nav-number">1.3.9.</span> <span class="nav-text">如何精简你的 Git 仓库？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-add%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.3.10.</span> <span class="nav-text">git add详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E7%A7%BB%E9%99%A4%E5%B7%B2%E7%BB%8Fadd%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.11.</span> <span class="nav-text">git移除已经add的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GIT%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9-restore"><span class="nav-number">1.3.12.</span> <span class="nav-text">GIT撤销修改 restore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.12.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.13.</span> <span class="nav-text">提交忽略某些文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AE%BE%E7%BD%AE-gitignore"><span class="nav-number">1.3.13.1.</span> <span class="nav-text">1.设置.gitignore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.3.13.2.</span> <span class="nav-text">2.使用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8-git-info-exclude"><span class="nav-number">1.3.13.3.</span> <span class="nav-text">3.使用.git&#x2F;info&#x2F;exclude</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-clean%E6%B8%85%E9%99%A4%E6%9C%AA%E8%B7%9F%E8%B8%AA%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.14.</span> <span class="nav-text">git clean清除未跟踪的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9Acommit"><span class="nav-number">1.3.15.</span> <span class="nav-text">git删除指定commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9Acommit-%E7%BB%AD"><span class="nav-number">1.3.16.</span> <span class="nav-text">git删除指定commit-续</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-rebase-%E5%90%88%E5%B9%B6%E5%A4%9A%E6%AC%A1commit"><span class="nav-number">1.3.17.</span> <span class="nav-text">git rebase 合并多次commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-rebase-Vs-git-revert"><span class="nav-number">1.3.18.</span> <span class="nav-text">git rebase Vs git revert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Git%E4%B8%8A%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">1.3.19.</span> <span class="nav-text">如何删除Git上的远程文件夹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%A9%BAcommits%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95"><span class="nav-number">1.3.20.</span> <span class="nav-text">清空commits历史记录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%EF%BC%8C%E5%88%A0%E9%99%A4-git%E7%9B%AE%E5%BD%95"><span class="nav-number">1.3.20.1.</span> <span class="nav-text">进入本地仓库，删除.git目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%96%B0git%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B9%B6%E6%B7%BB%E5%8A%A0commit"><span class="nav-number">1.3.20.2.</span> <span class="nav-text">重新git初始化并添加commit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%93%BE%E6%8E%A5"><span class="nav-number">1.3.20.3.</span> <span class="nav-text">添加远程仓库链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E6%8F%90%E4%BA%A4%EF%BC%8C%E8%A6%86%E7%9B%96%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84commits%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95"><span class="nav-number">1.3.20.4.</span> <span class="nav-text">强制提交，覆盖远程仓库的commits历史记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD%E8%AE%A8%E8%AE%BA"><span class="nav-number">1.3.20.5.</span> <span class="nav-text">后续讨论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AFbranch%E5%92%8C%E4%BD%BF%E7%94%A8Pull-request"><span class="nav-number">1.3.21.</span> <span class="nav-text">创建分支branch和使用Pull request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GitHub-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%90%8C%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%B9%B6%E4%B8%94%E6%9D%83%E9%99%90%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.22.</span> <span class="nav-text">GitHub 实现多人协同提交代码并且权限分组管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git%E5%A4%9A%E5%88%86%E6%94%AF%E5%B9%B3%E8%A1%8C%E5%8F%91%E5%B1%95%EF%BC%88%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%89"><span class="nav-number">1.3.23.</span> <span class="nav-text">Git多分支平行发展（一个仓库包含多个不同的项目）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git%E4%B8%ADsubmodule%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.24.</span> <span class="nav-text">Git中submodule的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-clone%E7%A7%BB%E5%8A%A8%E6%9C%AC%E5%9C%B0%E5%8E%82%E5%BA%93"><span class="nav-number">1.3.25.</span> <span class="nav-text">git clone移动本地厂库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E8%A3%B8%E5%85%8B%E9%9A%86"><span class="nav-number">1.3.26.</span> <span class="nav-text">git裸克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-pull%E5%92%8Cgit-fetch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.27.</span> <span class="nav-text">git pull和git fetch的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fatal-does-not-appear-to-a-git-repository"><span class="nav-number">1.3.28.</span> <span class="nav-text">fatal: does not appear to a git repository</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-fork%E4%B8%8Eclone%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.3.29.</span> <span class="nav-text">git fork与clone有什么区别及使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#git-clone"><span class="nav-number">1.3.29.1.</span> <span class="nav-text">git clone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#git-fork"><span class="nav-number">1.3.29.2.</span> <span class="nav-text">git fork</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF-git-push-origin"><span class="nav-number">1.3.30.</span> <span class="nav-text">git 推送本地分支到远程分支 git push origin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-remote%E5%85%B3%E8%81%94%E4%BA%86%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E4%BB%93%E5%BA%93"><span class="nav-number">1.3.31.</span> <span class="nav-text">git remote关联了两个或多个仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-add%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.32.</span> <span class="nav-text">git add外部文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-add-%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.33.</span> <span class="nav-text">git add 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-commit-%E6%8F%90%E4%BA%A4%E5%88%B0%E7%89%88%E6%9C%AC%E5%BA%93"><span class="nav-number">1.3.34.</span> <span class="nav-text">git commit 提交到版本库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git-%E5%BB%96%E9%9B%AA%E5%B3%B0%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3"><span class="nav-number">1.4.</span> <span class="nav-text">git 廖雪峰学习文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA"><span class="nav-number">1.4.1.</span> <span class="nav-text">工作区和暂存区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%EF%BC%88Working-Directory%EF%BC%89"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">工作区（Working Directory）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%BA%93%EF%BC%88Repository%EF%BC%89"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">版本库（Repository）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81git%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.</span> <span class="nav-text">一、git初始化本地仓库和配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6"><span class="nav-number">1.6.</span> <span class="nav-text">二、提交文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%9B%9E%E9%80%80"><span class="nav-number">1.7.</span> <span class="nav-text">三、回退</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9F%A5%E7%9C%8Bcommit%E4%BF%A1%E6%81%AF%E5%92%8C%E5%91%BD%E4%BB%A4%E4%BF%A1%E6%81%AF"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.查看commit信息和命令信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9B%9E%E9%80%80"><span class="nav-number">1.7.2.</span> <span class="nav-text">2.回退</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-HEAD%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.7.3.</span> <span class="nav-text">3.HEAD介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8Blog"><span class="nav-number">1.7.4.</span> <span class="nav-text">4.查看远程log</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%88%87%E6%8D%A2%E6%9A%82%E5%AD%98%E5%8C%BA%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8C%BA"><span class="nav-number">1.8.</span> <span class="nav-text">四、切换暂存区、工作区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-number">1.9.</span> <span class="nav-text">五、删除文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6"><span class="nav-number">1.9.1.</span> <span class="nav-text">1.删除本地文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%8C%E8%AF%AF%E5%88%A0"><span class="nav-number">1.9.2.</span> <span class="nav-text">2，误删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%AB%AF%E6%96%87"><span class="nav-number">1.9.3.</span> <span class="nav-text">3.删除远端文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">1.10.</span> <span class="nav-text">六、本地分支和远程分支</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%EF%BC%8C%E5%B8%A6%E6%98%9F%E5%8F%B7%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%93%E5%89%8D%E6%89%80%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">1.10.1.</span> <span class="nav-text">1.查看本地分支，带星号的表示当前所在本地分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">1.10.2.</span> <span class="nav-text">2.创建本地分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">1.10.3.</span> <span class="nav-text">3.创建远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%90%88%E5%B9%B6%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">1.10.4.</span> <span class="nav-text">4.合并本地分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-origin"><span class="nav-number">1.10.5.</span> <span class="nav-text">5.origin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-git-fetch-%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93"><span class="nav-number">1.10.6.</span> <span class="nav-text">6.git fetch 更新远程代码到本地仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-fetch%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.10.7.</span> <span class="nav-text">7.fetch更新本地仓库两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%90%88%E5%B9%B6%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">1.10.8.</span> <span class="nav-text">8.合并远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">1.10.9.</span> <span class="nav-text">9.删除本地分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">1.10.10.</span> <span class="nav-text">10.删除远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%96%B0%E5%88%86%E6%94%AF%E5%B9%B6%E5%B0%86%E6%96%B0%E5%88%86%E6%94%AF%E5%92%8C%E8%BF%9C%E7%A8%8B%E6%9F%90%E4%B8%AA%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3%E8%81%94"><span class="nav-number">1.10.11.</span> <span class="nav-text">11.创建本地新分支并将新分支和远程某个分支相关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF"><span class="nav-number">1.10.12.</span> <span class="nav-text">12.修改commit信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%88%A0%E9%99%A4commit%E4%BF%A1%E6%81%AF"><span class="nav-number">1.10.13.</span> <span class="nav-text">13.删除commit信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5"><span class="nav-number">1.11.</span> <span class="nav-text">七、分支策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81bug%E5%88%86%E6%94%AF%E5%92%8C%E6%9A%82%E5%AD%98%E5%B7%A5%E4%BD%9C%E7%8E%B0%E5%9C%BA"><span class="nav-number">1.12.</span> <span class="nav-text">八、bug分支和暂存工作现场</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-bug%E5%88%86%E6%94%AF%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">1.12.1.</span> <span class="nav-text">1.bug分支的用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BAbug%E5%88%86%E6%94%AF%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.12.2.</span> <span class="nav-text">2.创建bug分支的流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81feature%E5%88%86%E6%94%AF"><span class="nav-number">1.13.</span> <span class="nav-text">九、feature分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81github%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">1.14.</span> <span class="nav-text">十、github远程仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8ssh%E5%88%9B%E5%BB%BAkey"><span class="nav-number">1.14.1.</span> <span class="nav-text">1.使用ssh创建key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94"><span class="nav-number">1.14.2.</span> <span class="nav-text">2.本地仓库和远程仓库关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%85%B3%E8%81%94%E4%BB%93%E5%BA%93%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">1.14.3.</span> <span class="nav-text">3.关联仓库出现问题解决办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9C%89%E6%97%B6%E5%80%99%E4%B8%8D%E6%83%B3%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81-%E5%BB%BA%E8%AE%AE%E8%BF%98%E6%98%AF%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E5%A5%BD%EF%BC%89"><span class="nav-number">1.14.4.</span> <span class="nav-text">4.有时候不想解决冲突(建议还是解决冲突好）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><span class="nav-number">1.14.5.</span> <span class="nav-text">5.删除分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">1.14.6.</span> <span class="nav-text">6.创建远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AFcommit%E4%BF%A1%E6%81%AF%E7%94%A8%E4%BA%8E%E5%9B%9E%E9%80%80%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC"><span class="nav-number">1.14.7.</span> <span class="nav-text">7.查看远程分支commit信息用于回退到远程分支的某个版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%90%8D%E7%A7%B0"><span class="nav-number">1.14.8.</span> <span class="nav-text">8.修改远程仓库名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-fork%E5%88%AB%E4%BA%BA%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8E%E5%A6%82%E4%BD%95%E5%90%8C%E5%8E%9F%E4%BB%93%E5%BA%93%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="nav-number">1.14.9.</span> <span class="nav-text">9. fork别人的仓库后如何同原仓库保持同步更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-git-pull-can%E2%80%99t-update"><span class="nav-number">1.14.10.</span> <span class="nav-text">10. git pull can’t update</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%A4%9A%E4%BA%BA%E5%90%88%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.15.</span> <span class="nav-text">十一、多人合作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E7%89%88%E6%9C%AC%E6%A0%87%E7%AD%BE"><span class="nav-number">1.16.</span> <span class="nav-text">十二、版本标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%EF%BC%8C%E5%BF%BD%E7%95%A5%E7%89%B9%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="nav-number">1.17.</span> <span class="nav-text">十三，忽略特特殊文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Git%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.18.</span> <span class="nav-text">十四、自定义Git服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%94%E3%80%81git%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">1.19.</span> <span class="nav-text">十五、git常见错误及解决办法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小邝"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">小邝</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kuangyl-max" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kuangyl-max" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
</div>
<div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"VldYGbfDFwTUlOKd9hViAlUO-gzGzoHsz","app_key":"6N6QvtWLrytbGARKbo2g3tMS","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'VldYGbfDFwTUlOKd9hViAlUO-gzGzoHsz',
      appKey     : '6N6QvtWLrytbGARKbo2g3tMS',
      placeholder: "无需登录即可评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>



<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
