<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kuangyl-max.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":5},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://kuangyl-max.github.io/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="小邝">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kuangyl-max.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband">
<a target="_blank" rel="noopener" href="https://github.com/kuangyl-max" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kuangyl-max.github.io/2021/11/15/git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="小邝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/git/" class="post-title-link" itemprop="url">Git教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 13:46:40 / 修改时间：20:31:52" itemprop="dateCreated datePublished" datetime="2021-11-15T13:46:40+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
                </span>
            </span>

          
            <span id="/2021/11/15/git/" class="post-meta-item leancloud_visitors" data-flag-title="Git教程" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
	<span>℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/15/git/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/15/git/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git命令交互式学习"><a href="#git命令交互式学习" class="headerlink" title="git命令交互式学习"></a>git命令交互式学习</h2><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014734886/article/details/79527710">https://blog.csdn.net/u014734886/article/details/79527710</a></p>
<p><a target="_blank" rel="noopener" href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p>
<p>示例：<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-17-19-cbcb88da5f3b55ab6a6bb41c1019e995-image15-1fbb47.png">{width=”5.540972222222222in”<br>height=”2.9277777777777776in”}</p>
<h2 id="Git-ssh-配置："><a href="#Git-ssh-配置：" class="headerlink" title="Git ssh 配置："></a>Git ssh 配置：</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anyefrozen/p/6379046.html">https://www.cnblogs.com/anyefrozen/p/6379046.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lqlqlq007/article/details/78983879">https://blog.csdn.net/lqlqlq007/article/details/78983879</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lilygg/article/details/97919376?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/lilygg/article/details/97919376?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
<h2 id="疑难"><a href="#疑难" class="headerlink" title="疑难"></a>疑难</h2><h3 id="git下载仓库内单个文件夹内容"><a href="#git下载仓库内单个文件夹内容" class="headerlink" title="git下载仓库内单个文件夹内容"></a>git下载仓库内单个文件夹内容</h3><blockquote>
<p>git学习之git clone 克隆或下载一个仓库单个文件夹有时候因为需要我们只想gitclone下仓库的单个或多个文件夹，而不是全部的仓库内容，这样就很省事，所以下面就开始教程啦<br>在Git1.7.0以前，这无法实现，但是幸运的是在Git1.7.0以后加入了Sparse Checkout模式，这使得CheckOut指定文件或者文件夹成为可能。</p>
</blockquote>
<p><strong>现有一个test仓库<a target="_blank" rel="noopener" href="https://github.com/mygithub/test">https://github.com/mygithub/test</a></strong><br><strong>你要gitclone里面的 childfile 子目录：</strong><br><strong>在本地文件夹位置打开Git Bash 进行一下步骤</strong></p>
<h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><p>代码直接复制即可用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&#x27;childfile&#x27;</span>替换为自己要下载的文件夹名称</span></span><br><span class="line">git init test &amp;&amp; cd test     #新建仓库并进入文件夹</span><br><span class="line">git config core.sparsecheckout true #设置允许克隆子目录</span><br><span class="line">echo &#x27;childfile*&#x27; &gt;&gt; .git/info/sparse-checkout #设置要克隆的仓库的子目录路径   </span><br><span class="line">git remote add origin git@github.com:mygithub/test.git  #这里换成你要克隆的项目和库</span><br><span class="line">git pull origin master    #下载</span><br></pre></td></tr></table></figure>

<h3 id="git-clone-太慢"><a href="#git-clone-太慢" class="headerlink" title="git clone 太慢"></a>git clone 太慢</h3><p>原有git链接</p>
<p><code>https://github.com/someone/repo.git</code></p>
<p>改为如下链接之一</p>
<ul>
<li><p><code>https://hub.fastgit.org/someone/repo.git</code></p>
</li>
<li><p><code>https://gitclone.com/github.com/someone/repo.git</code></p>
</li>
<li><p><code>https://github.com.cnpmjs.org/someone/repo.git</code></p>
</li>
</ul>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone https://hub.fastgit.org/someone/repo.git</span><br><span class="line"><span class="meta">#</span><span class="bash">或者-空白文件夹</span></span><br><span class="line">git init </span><br><span class="line">git remote add origin https://hub.fastgit.org/someone/repo.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">或者-git文件夹</span></span><br><span class="line">git remote remove origin</span><br><span class="line">git remote add origin https://hub.fastgit.org/someone/repo.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果需要用完再改回到原来的git链接，可以先执行</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="meta">#</span><span class="bash">记录下git链接，之后恢复即可</span></span><br></pre></td></tr></table></figure>



<h3 id="Github如何上传超过100M的大文件"><a href="#Github如何上传超过100M的大文件" class="headerlink" title="Github如何上传超过100M的大文件"></a>Github如何上传超过100M的大文件</h3><blockquote>
<p>注意：安装 Git LFS 需要 Git 的版本不低于 1.8.5</p>
</blockquote>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><em>Linux</em></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a><em>Mac</em></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装HomeBrew </span></span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">brew install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><em>Windows</em></h4><ol>
<li>下载安装 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/github/git-lfs/releases">windows installer</a></li>
<li>运行 windows installer</li>
<li>在命令行执行 <code>git lfs install</code></li>
</ol>
<p>选择您希望Git LFS管理的文件类型（或直接编辑.gitattributes）。您可以随时配置其他文件扩展名。这一步成功后会生成一个gitattributes文件</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180715-2020-12-05-18-07-16.png" alt="学习笔记-20201205180715-2020-12-05-18-07-16"><br> 添加并commit gitattributes文件</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180740-2020-12-05-18-07-40.png" alt="学习笔记-20201205180740-2020-12-05-18-07-40"><br>然后再添加大文件到本地缓存区</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180754-2020-12-05-18-07-55.png" alt="学习笔记-20201205180754-2020-12-05-18-07-55"><br> 这里要注意一点：以上是官网步骤，我没这样走。如果你按照以上步骤走的话会还是会出现push fail(如下图)的情况，可参考我的解决办法。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205180805-2020-12-05-18-08-06.png" alt="学习笔记-20201205180805-2020-12-05-18-08-06"></p>
<p>参考解决办法：</p>
<p>1-2步没变，第3步我是生成.gitattributes后 add并且commit并且把.gitattributes文件push到远程分支，合并完成后，然后再add并且commit然后再push这个大文件.</p>
<p>简单说，就是我先把这个.gitattributes跟踪文件提交上传到远程，再把大文件提交并上传到远程的，这个要注意顺序。</p>
<p>有的同学已经把大文件提交了，但是.gitattributes还没有提交，这种情况需要回滚版本，具体操作可以</p>
<h3 id="git-lfs的使用"><a href="#git-lfs的使用" class="headerlink" title="git lfs的使用"></a>git lfs的使用</h3><p>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/mianbaoshu/p/10972254.html">https://www.cnblogs.com/mianbaoshu/p/10972254.html</a></p>
<h4 id="1-什么是git-lfs"><a href="#1-什么是git-lfs" class="headerlink" title="1.什么是git lfs"></a>1.什么是git lfs</h4><p>Git LFS（Large File Storage, 大文件存储）是可以把音乐、图片、视频等指定的任意文件存在 Git 仓库之外，而在 Git 仓库中用一个占用空间 1KB 不到的文本指针来代替的小工具。通过把大文件存储在 Git 仓库之外，可以减小 Git 仓库本身的体积，使克隆 Git 仓库的速度加快，也使得 Git 不会因为仓库中充满大文件而损失性能。</p>
<h4 id="2-优点是什么"><a href="#2-优点是什么" class="headerlink" title="2.优点是什么"></a>2.优点是什么</h4><p>git每次保存diff，一些大文件发生变化时，整个仓库就会增加很大的体积，导致clone和pull的数据量大增。对于<code>git lfs</code>来说，在使用<code>git lfs track</code>命令后，git push的时候，<code>git lfs</code>会截取要管理的大文件，并将其传至<code>git lfs</code>的服务器中，从而减小仓库的体积</p>
<h4 id="3-怎么使用"><a href="#3-怎么使用" class="headerlink" title="3.怎么使用"></a>3.怎么使用</h4><ol>
<li><p>查看现有的文件追踪模式：<code>git lfs track</code></p>
</li>
<li><p>添加要管理的大文件的文件类型，比如gz文件</p>
</li>
</ol>
<p>运行命令：<code>git lfs track *.gz</code>添加类型后，查看管理文件.gitattributes，可以发现.gitattributes中新增加一行：<code>*.gz filter=lfs diff=lfs merge=lfs -text</code></p>
<ol start="3">
<li><p>将管理文件.gitattributes提交至仓库. 它保存了文件的追踪记录</p>
</li>
<li><p>获取git lfs管理的所有文件列表：git lfs ls-files </p>
</li>
<li><p>添加大文件到git仓库，和其它添加方式一样</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add my.gz</span><br><span class="line">git commit -m &quot;add gz file&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将代码 push 到远程仓库后，LFS 跟踪的文件会以『Git LFS』的形式显示:</li>
<li>clone 时 使用’git clone’ 或 <code>git lfs clone</code>均可</li>
<li>查看Git LFS 的帮助：git lfs help</li>
<li>下载被git lfs管理的文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git lfs fetch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lfs checkout</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lfs pull</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li>删除lfs里的文件</li>
</ol>
<p>如果需要删除lfs里的文件，需要在gitee后台操作，先到后台里查看文件的oid</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/13/09-43-36-1e86b868bb36524bef9ae76be9b53dd3-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RkZGQ2NjY2cXE=,size_16,color_FFFFFF,t_70-c7a109.png" alt="删除lfs"></p>
<p>然后在本地通过下面命令判断是否是能删除的文件，然后在后台操作删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --all -p -S 8a9c160e</span></span><br></pre></td></tr></table></figure>

<p><strong>删除文件后本地分支上传时可能的报错</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unable to find source for object a0ee616e6195bcb5f4136fb36b6b803566cec234f4468bda64e42a34a5f76697 (try running git lfs fetch --all)</span><br><span class="line">Uploading LFS objects:   0% (0/20), 0 B | 0 B/s, done.</span><br></pre></td></tr></table></figure>

<p>查了下这个文件是前面我删除的文件，我想要的结果是忽略这个文件接着上传，可以设置下面这个属性</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config lfs.allowincompletepush <span class="literal">true</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>git lfs track *<em>/</em>.zip 任意子目录的zip文件</p>
</blockquote>
<p><strong>参考文档</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/help/articles/4235#article-header0">Git LFS 操作指南</a></li>
</ul>
<h3 id="删除远程lfs大文件"><a href="#删除远程lfs大文件" class="headerlink" title="删除远程lfs大文件"></a>删除远程lfs大文件</h3><p>一些时候由于开发初期经验不足和贪图方便, 会把一些不应该提交到 Git 的文件上传到 Github, 带来一系列安全问题, 更有可能是把一些大文件上传到 GitHub 上, 导致项目非常臃肿, 每次 pull、push 都要花费很多时间.</p>
<p>这时候就可以寻求一些特殊的工具的帮助, <a target="_blank" rel="noopener" href="https://rtyley.github.io/bfg-repo-cleaner/">BFG Repo-Cleaner by rtyley </a>就是这样一款工具, 可以从 Git 项目中彻底删除某一个文件的历史记录.</p>
<p><strong>下载及运行</strong></p>
<p><a target="_blank" rel="noopener" href="https://rtyley.github.io/bfg-repo-cleaner/">BFG Repo-Cleaner </a>是由 Scala (一种JVM语言) 写成, 所以会被编译成 jar 包, 下载非常方便, 下载地址可在官网或直接点击 <a target="_blank" rel="noopener" href="https://search.maven.org/classic/remote_content?g=com.madgag&a=bfg&v=LATEST">bfg 下载地址 </a>.</p>
<p>但因此运行 <code>bfg.jar</code> 就需要 Java 环境, 关于 Java 环境的安装, macOS可以参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/imzhizi/p/macos-jdk-installation-homebrew.html">macOS 的 JDK 安装问题 </a>, 而 Windows 已经有很多人提过, 不做赘述.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用brew安装配置</span></span><br><span class="line">brew cask install oracle-jdk</span><br><span class="line">brew install bfg</span><br></pre></td></tr></table></figure>

<p><strong>让它完全消失</strong></p>
<ol>
<li>首先需要自行从项目中删除不想要的文件并提交, 这样能最大程度避免误删、误操作.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先需要自行从项目中删除不想要的文件</span></span><br><span class="line">rm file-to-delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交改动, 即最新分支是不包含要被删除的文件</span></span><br><span class="line">git commit -m <span class="string">&quot;删除 file-to-delete&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后使用 <code>--mirror</code> 命令裸克隆(clone)整个项目.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --mirror git@github.com:username/some-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据经验, 如果是包含大文件的项目, 使用 ssh 将会克隆的非常缓慢, 可以改用 https</span></span><br><span class="line">git <span class="built_in">clone</span> --mirror https://github.com/username/some-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候, 你的当前目录下就会产生一个名为 some-project.git 的文件夹</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接着开始删除文件历史.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据情况的不同, bfg 可选择根据文件大小删除</span></span><br><span class="line">java -jar bfg.jar --strip-blobs-bigger-than 100M some-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据情况的不同, bfg 可选择直接根据名字删除</span></span><br><span class="line">java -jar bfg.jar --delete-files name-of-file  some-project.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令中java -jar bfg.jar 可以用bfg代替</p>
</blockquote>
<ol start="4">
<li>任选以上命令执行其中一个后, 执行 <code>git gc</code> 真正删除这些文件并提交.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> some-project.git</span><br><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这时候那个文件就会消失了…</p>
<p>参考链接：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://rtyley.github.io/bfg-repo-cleaner/">https://rtyley.github.io/bfg-repo-cleaner/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/removing-sensitive-data-from-a-repository">git filter-branch：</a></p>
</li>
</ul>
<h3 id="git-clone大文件EOF错误"><a href="#git-clone大文件EOF错误" class="headerlink" title="git clone大文件EOF错误"></a>git clone大文件EOF错误</h3><p>我们常用的<code>git clone https://XXX </code>下载大文件时，加上墙的问题。会出现中断</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.com/xhang/gitlab.git</span><br><span class="line"></span><br><span class="line">正克隆到 &#x27;gitlab&#x27;...</span><br><span class="line"></span><br><span class="line">remote: Counting objects: 451995, done.</span><br><span class="line"></span><br><span class="line">remote: Compressing objects: 100% (96627/96627), done.</span><br><span class="line"></span><br><span class="line">fatal: The remote end hung up unexpectedlyB | 34.00 KiB/s</span><br><span class="line"></span><br><span class="line">fatal: 过早的文件结束符（EOF）</span><br><span class="line"></span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<p><strong>解决一：采用ssh方式</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@gitlab.com:xhang/gitlab.git</span><br></pre></td></tr></table></figure>

<p><strong>解决二：加大https缓存（推荐）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br><span class="line">git config http.postBuffer 524288000</span><br></pre></td></tr></table></figure>

<h3 id="如何控制git库的膨胀？"><a href="#如何控制git库的膨胀？" class="headerlink" title="如何控制git库的膨胀？"></a>如何控制git库的膨胀？</h3><p>根据 Git 的数据存储机制，只要通过命令 git add 将文件存储至暂存区，都会对版本库中的每一个文件，不论是图片、视频、源文件还是二进制文件生成相对应的 Blob 对象（即一段二进制数据。可以类比为<strong>url编码，</strong>通过加解码获得内容信息）。</p>
<p>如果你的项目中不小心打包进来了比较大的 word 文档或视频资源，Git 本身又识别不了该类型文件，只能当作二进制文件全量存储。所以，在其他人拉取该 word 文档更新完后再推远程分支的时候，则会使得 .git 下面的 objects 的文件夹大小迅速膨胀。</p>
<p><strong>注：如果是文本或代码等 Git 可以识别的文件，则只会存储有差异的文件。</strong></p>
<p>上面使用场景中表面上少了500M空间，实则增加了一次至少500M的历史提交记录，仓库容量反而变得更臃肿。</p>
<h3 id="github重置仓库"><a href="#github重置仓库" class="headerlink" title="github重置仓库"></a>github重置仓库</h3><p><strong>执行之前本地要有备份！！！！</strong></p>
<ol>
<li><p>在你的仓库中点击setting</p>
<p><img src="../../../Library/Application%2520Support/typora-user-images/image-20210107132654116.png" alt="image-20210107132654116"></p>
</li>
<li><p>点击Delete this repository<img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/01/07/13-27-58-f6bfb78a8b4aac4ac07cefedd25bdc5c-image-20210107132756513-207804.png" alt="image-20210107132756513"></p>
</li>
<li><p>重新创建个同名厂库</p>
</li>
<li><p>本地执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .git</span><br><span class="line">git init </span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init repos&quot;</span><br><span class="line">git remote addd origin https:&#x2F;&#x2F;hub.fastgit.org&#x2F;yourname&#x2F;your-repos.git</span><br><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注意，如果提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: RPC 失败。HTTP 413 curl 22 The requested URL returned error: 413</span><br><span class="line">fatal: 远端意外挂断了</span><br><span class="line">fatal: 远端意外挂断了</span><br></pre></td></tr></table></figure>

<p>可以尝试以下步骤</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#1.查看http.postbuffer （如果没有设置，默认值是1兆，确认目前值确实较小）</span><br><span class="line">git config --list</span><br><span class="line">#2.设置http.postbuffer ，单位byte</span><br><span class="line">git config http.postBuffer 524288000 #（512MB）</span><br><span class="line">#3.如果还是无法解决问题，将ssl验证禁止</span><br><span class="line">git config http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>禁止ssl也可在克隆时执行<code>env GIT_SSL_NO_VERIFY=true git clone https://&lt;host_name/git/project.git </code></p>
</blockquote>
<ol start="2">
<li>或者更换为ssh链接</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:yourname&#x2F;your-repos.git</span><br></pre></td></tr></table></figure>

<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/babysbreath/p/7118414.html">https://www.cnblogs.com/babysbreath/p/7118414.html</a></p>
<p><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/6b97984d7582d75da2b0bf93.html">https://jingyan.baidu.com/article/6b97984d7582d75da2b0bf93.html</a></p>
<h3 id="如何精简你的-Git-仓库？"><a href="#如何精简你的-Git-仓库？" class="headerlink" title="如何精简你的 Git 仓库？"></a>如何精简你的 Git 仓库？</h3><p><strong>第一种方案：压缩 Git 仓库。</strong></p>
<p>例如，码云项目管理中会提供存储库 GC 功能，用于清理悬空文件，压缩存储库对象，减少存储库磁盘占用。</p>
<p><img src="https://pic1.zhimg.com/v2-fa1b0b20624cd7f8c31f2879e6c2820d_r.jpg?source=1940ef5c" alt="img"></p>
<p><strong>第二种方案（推荐）：删除大文件提交记录。</strong></p>
<p>查看存储库中的大文件：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all | grep -E `git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk &#x27;&#123;print$1&#125;&#x27; | sed &#x27;:a;N;$!ba;s/\n/|/g&#x27;`</span><br></pre></td></tr></table></figure>

<p>改写历史，去除大文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --tree-filter &#x27;rm -f path/to/large/files&#x27; --tag-name-filter cat -- --all</span><br><span class="line">git push origin --tags --force</span><br><span class="line">git push origin --all --force</span><br></pre></td></tr></table></figure>

<p>并告知所有组员，push 代码前需要 pull rebase，而不是 merge，否则会从该组员的本地仓库再次引入到远程库中。</p>
<p><strong>.git文件过大，github仓库瘦身</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luchengtao11/article/details/82531044?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/luchengtao11/article/details/82531044?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
<p><strong>查看git仓库大文件并删除</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wenqibiao8/article/details/81263751">https://blog.csdn.net/wenqibiao8/article/details/81263751</a></p>
<h3 id="git-add详解"><a href="#git-add详解" class="headerlink" title="git add详解"></a>git add详解</h3><p> 一、前言<br>git add命令主要用于把我们要提交的文件的信息添加到索引库中。当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。</p>
<p>查看git add 内容 git status<br>二、基本<br><code>git add &lt;path&gt;</code>表示 add to index only files created or modified and not those deleted<br>我通常是通过<code>git add &lt;path&gt;</code>的形式把我们<code>&lt;path&gt;</code>添加到索引库中，<code>&lt;path&gt;</code>可以是文件也可以是目录。<br>git不仅能判断出<code>&lt;path&gt;</code>中，修改（不包括已删除）的文件，还能判断出新添的文件，并把它们的信息添加到索引库中。<br>三、<code>git add -u</code><br><code>git add -u </code> 表示 add to index only files modified or deleted and not those created<br><code>git add -u [&lt;path&gt;]</code>: 把<path>中所有tracked文件中被修改过或已删除文件的信息添加到索引库。它不会处理untracted的文件。<br>省略<path>表示.,即当前目录。<br>四、<code>git add -A</code><br><code>git add -A: [&lt;path&gt;]</code>表示把<path>中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。<br>省略<path>表示.,即当前目录。<br>五、<code>git add -i</code><br>我们可以通过<code>git add -i [&lt;path&gt;]命</code>令查看<path>中被所有修改过或已删除文件但没有提交的文件，<br>并通过其revert子命令可以查看<code>&lt;path&gt;</code>中所有untracted的文件，同时进入一个子命令系统。<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br><span class="line">     staged   unstaged path</span><br><span class="line">1:    +0&#x2F;-0   nothing branch&#x2F;t.txt</span><br><span class="line">2:    +0&#x2F;-0   nothing branch&#x2F;t2.txt</span><br><span class="line">3:  unchanged    +1&#x2F;-0 readme.txt</span><br></pre></td></tr></table></figure>

<p><strong>* Commands *</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: [s]tatus   2: [u]pdate   3: [r]evert   4: [a]dd untracked</span><br><span class="line">5: [p]atch   6: [d]iff    7: [q]uit    8: [h]elp</span><br></pre></td></tr></table></figure>

<p>What now&gt;<br>这里的t.txt和t2.txt表示已经被执行了git add，待提交。即已经添加到索引库中。<br>readme.txt表示已经处于tracked下，它被修改了，但是还没有被执行了git add。即还没添加到索引库中。<br>5.1、revert子命令<br>可以通过<code>git add -i</code>的revert子命令（3: <code>[r]evert</code>）把已经添加到索引库中的文件从索引库中剔除。<br>（<code>3: [r]evert</code>）表示通过3或r或revert加回车执行该命令。执行该命令后，git会例出索引库中的文件列表.<br>然后通过数字来选择。输入”1”表示git会例出索引库中的文件列表中的第1个文件。<br>“1-15”表示git会例出索引库中的文件列表中的第1个文件到第15个文件.回车将执行。<br>如果我们不输入任何东西，直接回车，将结束revert子命令，返回git add -i的主命令行。<br>5.2、update子命令<br>可以通过update子命令（2: <code>[u]pdate</code>）把已经tracked的文件添加到索引库中。其操作和revert子命令类似。<br>5.3、add untracked子命令<br>通过add untracked子命令（4: <code>[a]dd untracked</code>）可以把还没被git管理的文件添加到索引库中。其操作和revert子命令类似。<br>5.4、diff子命令<br>可以通过diff子命令（6: <code>[d]iff</code>）可以比较索引库中文件和原版本的差异。其操作和revert子命令类似。<br>5.5、status子命令<br>status子命令(1: <code>[s]tatus</code>)功能上和git add -i相似<br>5.6、quit子命令<br>quit子命令（7: <code>[q]uit</code>）用于退出git add -i命令系统<br>六、帮助<br>我们可以通过<code>git add -h</code>命令来看git add命令的帮助文档。</p>
<h3 id="git移除已经add的文件"><a href="#git移除已经add的文件" class="headerlink" title="git移除已经add的文件"></a>git移除已经add的文件</h3><p>使用 git rm 命令即可，有两种选择,<br>一种是 <code>git rm --cached</code> “文件路径”，不删除物理文件，仅将该文件从缓存中删除；<br>一种是 <code>git rm --f “文件路径”</code>，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）。<br><code>[其他] </code>请问 <code>git rm --cache</code> 和 <code>git reset HEAD</code> 的区别到底在哪里呢？<br>如果要删除文件，最好用 <code>git rm file_name</code>，而不应该直接在工作区直接 <code>rm file_name</code>。<br>如果一个文件已经add到暂存区，还没有 commit，此时如果不想要这个文件了，有两种方法：<br>1，用版本库内容清空暂存区，<code>git reset HEAD</code> 但要慎重使用<br>2，只把特定文件从暂存区删除，<code>git rm --cached xxx</code></p>
<h3 id="GIT撤销修改-restore"><a href="#GIT撤销修改-restore" class="headerlink" title="GIT撤销修改 restore"></a>GIT撤销修改 restore</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dcef204dba74">https://www.jianshu.com/p/dcef204dba74</a></p>
<p>GIT 撤销修改，主要利用 <code>git restore</code> 命令。现在，我们来假象一个使用场景。当我们大半夜战至性头时，一上头不小心在文件中写了句不该写的话<code>&quot;老板是个大煞笔&quot;</code>！并且已经 <code>git add</code> 到暂存区(staged) 中了！如果再继续<code>commit</code> 的话，第二天就面临失业的风险！</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be <span class="symbol">committed:</span></span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        <span class="symbol">modified:</span>   READEME.md</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，有一个待提交文件，并且还有一个重要的提示：<strong>use “git restore –staged <file>…” to unstage</strong> ，翻译过来就是，使用 <code>git restore --staged &lt;file&gt;...</code> 可以使文件变成已修改(未执行 <code>add</code> 时  )状态。<br> 好的，是时候展现真正的技术了，命令敲起来ヾ(ﾟ∀ﾟゞ)：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git restore --staged READEME.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="symbol">commit:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        <span class="symbol">modified:</span>   READEME.md</span><br></pre></td></tr></table></figure>

<p>当我们执行 <code>store --staged</code> 命令后，再用 <code>status</code> 查看状态，会发现，文件已经变成 add 执行前的状态了。是的，这样咱们就彻底保住了工作。现在划重点，我们看下执行 <code>git restore --staged READEME.md</code> 到底发生了什么。</p>
<blockquote>
<p><strong><code>git restore --staged [file]</code></strong> : 表示从暂存区将文件的状态修改成 unstage  状态。当然，也可以不指定确切的文件 ，例如：<br><code>git restore --staged *.java</code> 表示将所有暂存区的java文件恢复状态<br><code>git restore --staged .</code> 表示将当前目录所有暂存区文件恢复状态<br>**<code>--staged</code>** 参数就是表示仅仅恢复暂存区的</p>
</blockquote>
<p>问题总结接踵而至，如果我不们不止执行了 <code>add</code> 命令，还执行了 <code>commit</code> 命令。是不是也可以利用 <code>restore</code> 命令返回呢？答案是肯定的。下面，我们介绍几个命令。</p>
<p> 我们又有错别字了，但是已经 <code>commit</code> 了，那么应该怎么办呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git restore -s HEAD~<span class="number">1</span> READEME.md  <span class="comment">// 该命名表示将版本回退到当前快照的前一个版本</span></span><br><span class="line">$ git restore -s <span class="number">91410</span>eb9  READEME.md  <span class="comment">// 改命令指定明确的 commit id ，回退到指定的快照中</span></span><br><span class="line">$ git reset --soft HEAD^  <span class="comment">// 该命令表示撤销 commit 至上一次 commit 的版本</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇文章的所有重点都集中在一个命令上 <code>restore</code> ，该命令主要有三个参数，我重点介绍一下，<code>restore</code> 命令，默认是带着 <code>--worktree</code> 参数的</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>git restore --worktree README.md</code></td>
<td align="center">表示撤销 README.md 文件工作区的的修改</td>
<td align="center">参数等同于 -W</td>
</tr>
<tr>
<td align="center"><code>git restore --staged README.md</code></td>
<td align="center">表示撤销暂存区的修改，将文件状态恢复到未 <code>add</code> 之前</td>
<td align="center">参数等同于 -S</td>
</tr>
<tr>
<td align="center"><code>git restore -s HEAD~1 README.md</code></td>
<td align="center">表示将当前工作区切换到上个 commit 版本</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>git restore -s dbv213 README.md</code></td>
<td align="center">表示将当前工作区切换到指定 commit id 的版本</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="提交忽略某些文件"><a href="#提交忽略某些文件" class="headerlink" title="提交忽略某些文件"></a>提交忽略某些文件</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mafeng/p/7635228.html">https://www.cnblogs.com/mafeng/p/7635228.html</a></p>
<h4 id="1-设置-gitignore"><a href="#1-设置-gitignore" class="headerlink" title="1.设置.gitignore"></a>1.设置.gitignore</h4><p>常用的规则：<br>1）/mtk/        过滤整个文件夹<br>2）*.zip         过滤所有.zip文件<br>3）/mtk/do.c     过滤某个具体文件</p>
<p>被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。<br>需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中：<br>1）!*.zip<br>2）!/mtk/one.txt</p>
<p>唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。<br>为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么我们就需要使用：<br>1）/mtk/<br>2）!/mtk/one.txt<br>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</p>
<p>最后需要强调的一点是，<strong>如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用</strong>，Git仍然会对所有文件进行版本管理。<br>简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。因此一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦。</p>
<h4 id="2-使用命令"><a href="#2-使用命令" class="headerlink" title="2.使用命令"></a>2.使用命令</h4><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<br>正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。<br><code>git update-index --assume-unchanged FILE</code> 在FILE处输入要忽略的文件。<br>如果要还原的话，使用命令：<br><code>git update-index --no-assume-unchanged FILE</code></p>
<h4 id="3-使用-git-info-exclude"><a href="#3-使用-git-info-exclude" class="headerlink" title="3.使用.git/info/exclude"></a>3.使用.git/info/exclude</h4><p>git 还提供了另一种 exclude 的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去。用来保存的是公共的需要排除的文件。而 .git/info/exclude 这里设置的则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。</p>
<h3 id="git-clean清除未跟踪的文件"><a href="#git-clean清除未跟踪的文件" class="headerlink" title="git clean清除未跟踪的文件"></a>git clean清除未跟踪的文件</h3><p>有时做Build会引入很多之前没加入.gitignore的文件。这时你不可能每个目录每个文件地去删。<code>git clean -df </code>可帮你搞定一切。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clean -dn #这个命令可以看看有哪此文件和目录会被删</span><br><span class="line"></span><br><span class="line">git clean -f #只会删文件，不会删目录</span><br></pre></td></tr></table></figure>

<h3 id="git删除指定commit"><a href="#git删除指定commit" class="headerlink" title="git删除指定commit"></a>git删除指定commit</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lwcode6/p/11809973.html">https://www.cnblogs.com/lwcode6/p/11809973.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuluoxingkong/p/9835368.html">https://www.cnblogs.com/yuluoxingkong/p/9835368.html</a></p>
<p>或者采取以下方法</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lwcode6/p/11809973.html">https://www.cnblogs.com/lwcode6/p/11809973.html</a></p>
</blockquote>
<ol>
<li>使用<code>git log </code>命令，查看已提交的记录。例如红色圈出的commit是本次要删除的commit。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182720-2020-12-05-18-27-25.png" alt="学习笔记-20201205182720-2020-12-05-18-27-25"></p>
<ol start="2">
<li><p>先找到此次提交之前的一次提交的commit 1d6b81b138f89735265900b94fcd1ec39375e7b4</p>
</li>
<li><p>执行<code>git rebase -i 1d6b81b138f89735265900b94fcd1ec39375e7b4</code>，弹出如下页面（不包含当前commit）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205182904-2020-12-05-18-29-14.png" alt="学习笔记-20201205182904-2020-12-05-18-29-14"></p>
<p>按字母I键进入编辑模式，将需要删除的commit的pick改为drop，然后按esc退出编辑，：wq保存<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183048-2020-12-05-18-30-50.png" alt="学习笔记-20201205183048-2020-12-05-18-30-50"></p>
<ol start="4">
<li>再次执行git log命令，查看已提交记录，之前红色圈出的commit记录已被删除<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205183149-2020-12-05-18-31-52.png" alt="学习笔记-20201205183149-2020-12-05-18-31-52"></li>
</ol>
<h3 id="git删除指定commit-续"><a href="#git删除指定commit-续" class="headerlink" title="git删除指定commit-续"></a>git删除指定commit-续</h3><p><strong>一、删除文件</strong><br>如果需要删除的 commit 是一个或多个文件，可以进行以下操作。</p>
<ol>
<li>被提交到仓库的某个文件需要删除，可以使用 git rm 命令：<br><code>git rm &lt;file&gt; </code>// 从工作区和暂存区删除某个文件2. <code>git commit -m &quot;&quot;</code> // 再次提交到仓库<br>如果只想从暂存区删除文件，本地工作区不做出改变，可以：<br><code>git rm --cached &lt;file&gt;</code><br>如果在工作区不小心删错了某个文件，可以用 git checkout 将暂存区的文件覆盖工作区的文件，从而把误删的文件恢复：<br><code>git checkout -- &lt;file&gt;</code><br>用 <code>git rm </code>删除文件，同时还会将这个删除操作记录下来；<br>用 <code>rm 删除文件</code>，删除的仅仅是本地物理文件，没有将其从 git 的记录中剔除。</li>
<li><code>git add</code> 和 <code>git rm</code> 有相似的功能，<br>但 <code>git add</code> 仅能记录添加、改动的动作，删除的动作需靠 <code>git rm </code>来完成。<br><strong>二、GitHub 删除某次 commit</strong><br>如果需要删除的不只是某个文件，而是交错的代码，那么有以下三种方法可以删除 commit 。</li>
</ol>
<ul>
<li>git reset</li>
<li>git reset ：回滚到某次提交。</li>
<li>git reset –soft：此次提交之后的修改会被退回到暂存区。</li>
<li>git reset –hard：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的。<br>回滚代码</li>
</ul>
<p>如果需要删除的 commit 是最新的，那么可以通过 <code>git reset </code>命令将代码回滚到之前某次提交的状态，但一定要将现有的代码做好备份，否则回滚之后这些变动都会消失。具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;回滚代码</span><br><span class="line">git log &#x2F;&#x2F; 查询要回滚的 commit_id</span><br><span class="line">git reset --hard commit_id &#x2F;&#x2F; HEAD 就会指向此次的提交记录</span><br><span class="line">git push origin HEAD --force &#x2F;&#x2F; 强制推送到远端</span><br></pre></td></tr></table></figure>

<p>误删恢复</p>
<p>如果回滚代码之后发现复制错了 commit_id，或者误删了某次 commit 记录，也可以通过下方代码恢复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;误删恢复</span><br><span class="line">git relog &#x2F;&#x2F; 复制要恢复操作的前面的 hash 值</span><br><span class="line">git reset --hard hash &#x2F;&#x2F; 将 hash 换成要恢复的历史记录的 hash 值</span><br></pre></td></tr></table></figure>

<p>注意：删除中间某次提交时最好不要用<code> git reset</code> 回退远程库，因为之后其他人提交代码时用<code> git pull</code> 也会把自己的本地仓库回退到之前的版本，容易出现差错进而增加不必要的工作量。</p>
<h3 id="git-rebase-合并多次commit"><a href="#git-rebase-合并多次commit" class="headerlink" title="git rebase 合并多次commit"></a>git rebase 合并多次commit</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdlwzy/article/details/83379546?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/csdlwzy/article/details/83379546?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>
<p><strong>使用rebase命令</strong></p>
<p>想要合并前三个 commit ，使用下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>

<p>进入编辑界面，把要保留的 commit 使用pick，其他的使用squash命令，或者根据命令提示选择自己想用的命令</p>
<p><img src="../../../Library/Application%2520Support/typora-user-images/image-20210415110322574.png" alt="image-20210415110322574"></p>
<h3 id="git-rebase-Vs-git-revert"><a href="#git-rebase-Vs-git-revert" class="headerlink" title="git rebase Vs git revert"></a>git rebase Vs git revert</h3><p>git rebase：当两个分支不在一条线上，需要执行 merge 操作时使用该命令。</p>
<p><strong>撤销提交</strong><br>如果中间的某次 commit 需要删除，可以通过 <code>git rebase </code>命令实现，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;撤销提交</span><br><span class="line">git log &#x2F;&#x2F; 1.查找要删除的前一次提交的 commit_id</span><br><span class="line">git rebase -i commit_id &#x2F;&#x2F; 2.将 commit_id 替换成复制的值</span><br><span class="line">&#x2F;&#x2F;3.进入 Vim 编辑模式将要删除的 commit 前面的 &#96;pick&#96; 改成 &#96;drop&#96;</span><br><span class="line">&#x2F;&#x2F;4.保存并退出 Vim</span><br></pre></td></tr></table></figure>

<p>这样就完成了。<br><strong>解决冲突</strong><br>该命令执行时极有可能出现 reabase 冲突，可以通过以下方法解决：</p>
<ol>
<li>git diff // 查看冲突内容</li>
<li>// 手动解决冲突（冲突位置已在文件中标明）</li>
<li>git add <file> 或 git add -A // 添加</li>
<li>git rebase –continu // 继续 rebase</li>
<li>// 若还在 rebase 状态，则重复 2、3、4，直至 rebase 完成出现 applying 字样</li>
<li>git push<br><strong>git revert</strong></li>
</ol>
<ul>
<li><p>git revert：放弃某次提交。</p>
</li>
<li><p>git revert 之前的提交仍会保留在 git log 中，而此次撤销会做为一次新的提交。</p>
</li>
<li><p>git revert -m：用于对 merge 节点的操作，-m 指定具体某个提交点。<br><strong>撤销提交</strong><br>要撤销中间某次提交时，使用 <code>git revert</code> 也是一个很好的选择：</p>
<ol>
<li>git log // 查找需要撤销的 commit_id</li>
<li>git revert commit_id  // 撤销这次提交<br>撤销 merge 节点提交 如果这次提交是 merge 节点的话，则需要加上 -m 指令：git revert commit_id -m 1 // 第一个提交点</li>
<li>// 手动解决冲突</li>
<li>git add -A</li>
<li>git commit -m “”</li>
<li>git revert commit_id -m 2 // 第二个提交点</li>
<li>// 重复 2，3，4</li>
<li>git push</li>
</ol>
</li>
</ul>
<p>原文链接：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c9f131e22a60">https://www.jianshu.com/p/c9f131e22a60</a></p>
<p><strong>附： git rebase</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41629756/article/details/100731258">https://blog.csdn.net/qq_41629756/article/details/100731258</a></p>
<ol>
<li>git log先找到需要变基(rebase)的Hash ID的下一个ID(不是本身Hash值)</li>
<li>git rebase -i (Hash ID) 此时会出现两种情况<br>1）工作区有变更尚未提交</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i 121f508bc4ac7044c1dda188fc595e7029613f22</span><br><span class="line">不能变基：您有未暂存的变更。</span><br><span class="line">而且您的索引中包含未提交的变更。</span><br><span class="line">请提交或贮藏修改。</span><br></pre></td></tr></table></figure>

<p>遇到这种情况需要将变更缓存，输入git stash 存储变更后再进行第二步操作<br>2）工作区无变更<br>此时直接往下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pick f60514c5 a</span><br><span class="line">pick e52ec2e0 b</span><br><span class="line">pick b2ee5bd4 c</span><br><span class="line">pick 1e3b1ed8 d</span><br><span class="line">pick ac231a7a e</span><br><span class="line">pick 1ddd77c2 f</span><br><span class="line">pick de41e172 g</span><br><span class="line">pick bab63064 h</span><br><span class="line">pick f898eacd i</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 变基 b0279a0c..f898eacd 到 b0279a0c（9 个提交）</span><br><span class="line">#</span><br><span class="line"># 命令:</span><br><span class="line"># p, pick &#x3D; 使用提交</span><br><span class="line"># r, reword &#x3D; 使用提交，但修改提交说明</span><br><span class="line"># e, edit &#x3D; 使用提交，但停止以便进行提交修补</span><br><span class="line"># s, squash &#x3D; 使用提交，但和前一个版本融合</span><br><span class="line"># f, fixup &#x3D; 类似于 &quot;squash&quot;，但丢弃提交说明日志</span><br><span class="line"># x, exec &#x3D; 使用 shell 运行命令（此行剩余部分）</span><br><span class="line"># d, drop &#x3D; 删除提交</span><br><span class="line">#</span><br><span class="line"># 这些行可以被重新排序；它们会被从上至下地执行。</span><br><span class="line">#</span><br><span class="line"># 如果您在这里删除一行，对应的提交将会丢失。</span><br><span class="line">#</span><br><span class="line"># 然而，如果您删除全部内容，变基操作将会终止。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据提示，将pick改为适应需求的关键词即可</li>
<li>退出保存</li>
<li>输入 git stash pop 释放之前保存的缓存然后正常操作即可</li>
</ol>
<h3 id="如何删除Git上的远程文件夹"><a href="#如何删除Git上的远程文件夹" class="headerlink" title="如何删除Git上的远程文件夹"></a>如何删除Git上的远程文件夹</h3><p><strong>方法一</strong></p>
<p>这里以删除 test文件夹为案例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached test //--cached不会把本地的test删除</span><br><span class="line">git commit -m &#x27;delete test dir&#x27;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<p>如果误提交的文件夹比较多，方法一也较繁琐<br>直接修改.gitignore文件,将不需要的文件过滤掉，然后执行命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git push  -u origin master</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm -r -n --cached  */dirs/\*      #把dirs里的全部移除</span><br><span class="line"><span class="meta">#</span><span class="bash"> -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span></span><br></pre></td></tr></table></figure>

<h3 id="清空commits历史记录"><a href="#清空commits历史记录" class="headerlink" title="清空commits历史记录"></a>清空commits历史记录</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/magic-wei/p/9919277.html">https://www.cnblogs.com/magic-wei/p/9919277.html</a></p>
<p>git是当前最常见的版本控制工具，但出现以下情况时，往往需要清空commits历史记录：</p>
<ul>
<li>commits记录占用空间过大甚至远远超过版本控制文件本身大小，进行云端代码管理时会受制于空间限制，无法继续更新</li>
<li>历史记录中存在敏感信息，需要清理</li>
</ul>
<p>清理commits历史记录的核心思想是，直接删除本地的.git目录，重新建立git仓库并与远程仓库建立链接，采用强制提交的方式覆盖远程仓库的commits记录。下面是一段示例脚本。</p>
<p>参数说明：</p>
<ul>
<li>$REPO_DIR 表示需要处理的Git仓库本地目录</li>
<li><a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a>:xxxx/$REPO_DIR.git 表示远程仓库地址</li>
</ul>
<p>则可以按照如下步骤处理：</p>
<h4 id="进入本地仓库，删除-git目录"><a href="#进入本地仓库，删除-git目录" class="headerlink" title="进入本地仓库，删除.git目录"></a>进入本地仓库，删除.git目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$REPO_DIR</span></span><br><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure>

<h4 id="重新git初始化并添加commit"><a href="#重新git初始化并添加commit" class="headerlink" title="重新git初始化并添加commit"></a>重新git初始化并添加commit</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add . <span class="comment"># 重新添加所有的文件</span></span><br><span class="line">git commit -m <span class="string">&quot;restart git commit&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加远程仓库链接"><a href="#添加远程仓库链接" class="headerlink" title="添加远程仓库链接"></a>添加远程仓库链接</h4><p>在添加远程仓库时，需要设置远程仓库的代号，本教程记为<strong>origin</strong>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xxxx/<span class="variable">$REPO_DIR</span>.git</span><br></pre></td></tr></table></figure>

<p>此时，可以用<code>git remote -v</code>检查远程仓库的设置。</p>
<h4 id="强制提交，覆盖远程仓库的commits历史记录"><a href="#强制提交，覆盖远程仓库的commits历史记录" class="headerlink" title="强制提交，覆盖远程仓库的commits历史记录"></a>强制提交，覆盖远程仓库的commits历史记录</h4><p>假设提交到远程仓库的master分支，则强制提交脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master <span class="comment"># 或者 git push --force origin master</span></span><br></pre></td></tr></table></figure>

<p>强制提交之后，再看远程仓库master分支的commits记录就变成1了。</p>
<p>如果需要与上游保持同步检测，可以使用指令<code>--set-upstream origin/master</code>，即</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master --set-upstream origin/master <span class="comment"># 如果指向其他分支，可以修改为 origin/$&#123;指定分支名&#125;</span></span><br></pre></td></tr></table></figure>

<p>至此，大功告成～</p>
<h4 id="后续讨论"><a href="#后续讨论" class="headerlink" title="后续讨论"></a>后续讨论</h4><p>细心的朋友可能会发现，上述操作之后，如果你还记得历史记录中某个commit的链接，你仍然可以通过链接访问到该commit下的文件，甚至可以基于这个commit重新创建新分支。为什么会出现这种情况呢？这其实和Git本身的设计机制有关，主要是为了提高容错率，防止你因为一些误操作弄丢了某些commits进而造成无法挽回的结果。</p>
<p>实际上，这些commits并没有马上被清理掉，仅仅是你的所有分支或标签无法访问到它们，这些commits被称为unreachable commits. 它们通常会被缓存一段时间，这个周期默认是30天，你也可以通过git命令行手动修改缓存周期或者手动清理。由于Github也是建立在Git这个版本管理工具上的网站，所以它也有这个机制。虽然它们在缓存期内仍然可以被访问到，但你clone到本地并不会包含它们，也就是说，你并不能在本地删除Github上已经存在的unreachable commits，因为本地根本访问不到它们（<a target="_blank" rel="noopener" href="https://help.github.com/cn/github/committing-changes-to-your-project/commit-exists-on-github-but-not-in-my-local-clone">存在于 GitHub 上但不存在于本地克隆中的提交</a>）。如果不着急的话，你可以等30天之后再试试看是否还能访问这些unreachable commits的链接；但如果你很着急，你可以联系<a target="_blank" rel="noopener" href="https://support.github.com/">Github Support</a>帮你清理这些你不想保留的commits。</p>
<p>所以，如果你只是维护个人的文件仓库的话，不需要担心这个问题，你在新机器上clone下来的仍然是缩减大小之后的仓库，而Github上的unreachable commit会在缓存期后被清理掉。如果是与他人协作的仓库，还是谨慎使用<code>git push --force</code>这种危险的操作吧，确实遇到需要这个操作的场景时，考虑用更安全的<code>git push --force-with-lease</code>. 如果你强制提交之后发现后悔了，找到想恢复的commit的链接并创建新分支就可以找回那个commit所在历史分支之前的内容啦。</p>
<p>感谢@绿静風 发现了这个问题，促使我进一步查阅资料去完善这篇博文，在此表示感谢！</p>
<p>后续讨论的主要参考内容如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Internals-Maintenance-and-Data-Recovery">Git Internals - Maintenance and Data Recovery</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4367977/how-to-remove-a-dangling-commit-from-github">Stackoverflow - How to remove a dangling commit from GitHub?</a></li>
</ul>
<p>如果只是想删除历史记录中曾经存在（但现在并不需要）的大文件，可以参考这个Issue中的讨论：<a target="_blank" rel="noopener" href="https://github.com/18F/C2/issues/439">Consider cleaning up the .git folder to reduce the large repo size</a>git commit和git push的区别</p>
<p>git commit操作的是本地库，git push操作的是远程库。</p>
<ul>
<li>git commit是将本地修改过的文件提交到本地库中。</li>
<li>git push是将本地库中的最新信息发送给远程库。</li>
</ul>
<h3 id="创建分支branch和使用Pull-request"><a href="#创建分支branch和使用Pull-request" class="headerlink" title="创建分支branch和使用Pull request"></a>创建分支branch和使用Pull request</h3><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-03-e0c1cd706c9becd959756c6b89e22b5f-image17-61c157.png">{width=”6.052777777777778in”<br>height=”3.3958333333333335in”}<br>重点看一下base和compare，Pull request将compare的分支的更新发送给base的分支，如上图所示。点击”Create pull request”，然后填写发送Pull request的原因和描述，再点击点击”Create pull request”，完成发送。</p>
<h3 id="GitHub-实现多人协同提交代码并且权限分组管理"><a href="#GitHub-实现多人协同提交代码并且权限分组管理" class="headerlink" title="GitHub 实现多人协同提交代码并且权限分组管理"></a>GitHub 实现多人协同提交代码并且权限分组管理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34044273/article/details/86394095?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control">https://blog.csdn.net/weixin_34044273/article/details/86394095?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control</a></p>
<h3 id="Git多分支平行发展（一个仓库包含多个不同的项目）"><a href="#Git多分支平行发展（一个仓库包含多个不同的项目）" class="headerlink" title="Git多分支平行发展（一个仓库包含多个不同的项目）"></a>Git多分支平行发展（一个仓库包含多个不同的项目）</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015430066">https://segmentfault.com/a/1190000015430066</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015430066">https://segmentfault.com/a/1190000015430066</a></p>
<h3 id="Git中submodule的使用"><a href="#Git中submodule的使用" class="headerlink" title="Git中submodule的使用"></a>Git中submodule的使用</h3><p><strong>背景</strong></p>
<p>面对比较复杂的项目，我们有可能会将代码根据功能拆解成不同的子模块。主项目对子模块有依赖关系，却又并不关心子模块的内部开发流程细节。</p>
<p>这种情况下，通常不会把所有源码都放在同一个 Git 仓库中。</p>
<p>有一种比较简单的方式，是在当前工作目录下，将子模块文件夹加入到 .gitignore 文件内容中，这样主项目就能够无视子项目的存在。这样做有一个弊端就是，使用主项目的人需要有一个先验知识：需要在当前目录下放置一份某版本的子模块代码。</p>
<p>还有另外一种方式可供借鉴，可以使用 Git的 submodule 功能，也是这篇文章的主题。</p>
<p>实际上 Git<br>工具的 submodule 功能就是建立了当前项目与子模块之间的依赖关系：子模块路径、子模块的远程仓库、子模块的版本号。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87053283">https://zhuanlan.zhihu.com/p/87053283</a></p>
<h3 id="git-clone移动本地厂库"><a href="#git-clone移动本地厂库" class="headerlink" title="git clone移动本地厂库"></a>git clone移动本地厂库</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone d:/SourceRepository d:/DestinationRepository</span><br></pre></td></tr></table></figure>

<p>d:/SourceRepository:想克隆的本地仓库路径，<br>d:/DestinationRepository:想克隆去另一个地方的路径</p>
<p>例如 git clone d:/git e:/git11<br>是将d:/git的仓库（即包含隐藏文件.git的目录）克隆到 e:/git11目录下</p>
<p><img src="../../../workSpace/documentation/%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/media/image18.png">{width=”7.216666666666667in”<br>height=”1.74375in”}</p>
<h3 id="git裸克隆"><a href="#git裸克隆" class="headerlink" title="git裸克隆"></a>git裸克隆</h3><p>myIdea:<strong>尤其是克隆含有超大文件的仓库时，由于工作区含有大文件的缓存，故要用<code>git clone --mirror</code></strong> 以下为–mirror后的：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2020/12/13/10-56-05-d27dfd459ca4a4fc85609d8b0eb6f231-image-20201213105603140-0d55f1.png" alt="image-20201213105603140"></p>
<p>用法1：<code>git clone &lt;repository&gt; &lt;directory&gt;</code></p>
<p>将<code>&lt;repository&gt;</code>指向的版本库创建一个克隆到<code>&lt;directory&gt;</code>目录。目录<code>&lt;directory&gt;</code>相当于克隆版本库的工作区，文件都会检出，版本库位于工作区的.git目录中</p>
<p>用法2：<code>git clone --bare &lt;repository&gt; &lt;directory.git&gt;</code></p>
<p>用法3：<code>git clone --mirror &lt;repository&gt; &lt;directory.git&gt;</code></p>
<p>用法2和用法3创建的克隆版本库都不包含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。一般约定俗成裸版本库的目录名以.git做后缀，所以上面示例中将克隆出来的裸版本库目录名写作&lt;directory.git&gt;。区别在于用法3克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用git fetch命令和上游版本库进行持续同步。</p>
<p>不使用–bare或–mirror创建出来的克隆包含工作区，这样就会产生两个包含工作区的版本库，这两个版本库对等。这两个工作区本质上没有区别，往往提交在一个版本A中进行，另一个B作为备份。只能从B执行git pull命令从A中拉回新的提交实现版本库同步，而不能从版本库A向版本库B执行git push推送操作</p>
<p>还可以通过git init的方式创建裸版本库，需要加–bare参数。</p>
<p>当执行git push命令时，如果没有设定推送的分支，而且当前分支也没有注册到远程的某个分支，将检查远程分支是否有和本地相同的分支名（如master），如果有，则推送，否则报错。</p>
<h3 id="git-pull和git-fetch的区别"><a href="#git-pull和git-fetch的区别" class="headerlink" title="git pull和git fetch的区别"></a>git pull和git fetch的区别</h3><p><strong>前言</strong></p>
<p>在我们使用git的时候用的更新代码是git fetch，git<br>pull这两条指令。但是有没有小伙伴去思考过这两者的区别呢？有经验的人总是说最好用git<br>fetch+git merge，不建议用git pull。也有人说git pull=git fetch+git<br>merge，真的是这样吗？为什么呢？既然如此为什么git还要提供这两种方式呢？</p>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41975655/article/details/82887273">https://blog.csdn.net/weixin_41975655/article/details/82887273</a></li>
</ul>
<h3 id="fatal-does-not-appear-to-a-git-repository"><a href="#fatal-does-not-appear-to-a-git-repository" class="headerlink" title="fatal: does not appear to a git repository"></a>fatal: does not appear to a git repository</h3><p>几周没用git，今天一来托管就报错，下面记录一下解决办法。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git push <span class="literal">-u</span> origin master</span><br><span class="line">fatal: <span class="string">&#x27;git@github.com/zejun_web&#x27;</span> does not appear to be a git repository</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>

<p>这是报错信息，建立了文件夹用了</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>后，也remote了，结果就是push不上去。</p>
<p>后面检查了一下remote内容</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git remote <span class="literal">-v</span></span><br><span class="line">origin  git@github.com/zejun_web (fetch)</span><br><span class="line">origin  git@github.com/zejun_web (push)</span><br></pre></td></tr></table></figure>

<p>敢情是remote命令就错了，里面少了git账号:git-ze,应该是：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:git<span class="literal">-ze</span>/zejun_web.git</span><br></pre></td></tr></table></figure>

<p>这样就知道怎么解决了，<br>先remove掉添加在远程的origin</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></table></figure>

<p>此时再用</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>就会发现没有origin了</p>
<p>再正确输入</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:git<span class="literal">-ze</span>/xxxx.git</span><br></pre></td></tr></table></figure>

<p>就可以了。</p>
<p>然后</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git push <span class="literal">-u</span> origin master</span><br><span class="line">Enumerating objects: <span class="number">7</span>, done.</span><br><span class="line">Counting objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up to 8 threads</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), <span class="number">545</span> bytes | <span class="number">272.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">7</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: Resolving deltas: <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), done.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">&#x27;master&#x27;</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/git<span class="literal">-ze</span>/zejun_web/pull/new/master</span><br><span class="line">remote:</span><br><span class="line">To github.com:git<span class="literal">-ze</span>/zejun_web.git</span><br><span class="line"> * [<span class="type">new</span> <span class="type">branch</span>]      master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里就成功啦。<br>网上查了一下还有的说要重新配置邮箱和姓名等信息的。。如果没有添加公钥的话确实还是要先在GitHub上添加公钥，如果已经添加过了，可以先用git remote<br>-v命令来检查一下添加的origin是不是代码写错了，写少了。</p>
<p>如果错了就先 git remote rm origin<br>然后最后就可以push了。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-23-2e2011e3bb51a81ccbaa15e5a905487e-image19-b07eeb.png">{width=”7.141666666666667in”<br>height=”2.248611111111111in”}</p>
<blockquote>
<p>要注意的就是第一次push的话，要加上 -u<br>在语句里，把本地master分支和远程库的master分支关联起来。</p>
</blockquote>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/python_neophyte/article/details/83381936">https://blog.csdn.net/python_neophyte/article/details/83381936</a></li>
</ul>
<h3 id="git-fork与clone有什么区别及使用场景"><a href="#git-fork与clone有什么区别及使用场景" class="headerlink" title="git fork与clone有什么区别及使用场景"></a>git fork与clone有什么区别及使用场景</h3><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><p>git clone xx 是我们比较熟悉的操作,它类似于Download功能，可以理解为将云端代码下载到我们自己电脑的本地。</p>
<p>正常的话需要我们本机安装了git，然后使用git clone [仓库地址]<br>即可将制定仓库地址代码下载到我们本机。</p>
<h4 id="git-fork"><a href="#git-fork" class="headerlink" title="git fork"></a>git fork</h4><p>我们在github上打开别人的项目，右上角会有一个fork及fork的人数。如下图：</p>
<ul>
<li><p>watch</p>
<p>就类似于关注，后续项目有任何更新都会通知你，如果设置了邮件还会邮件通知。觉得比较好的项目可以通过star进行收藏，并且收藏的同时也点了一个赞，在github中，star越多的项目肯定是越牛逼的项目了。这个也是很多面试官比较在意的，你有没有github开源项目？star多少？就是指这个了</p>
</li>
<li><p>fork<br>就是我们要讲的，我们将开源项目存储到我们自己的云端作为一个分支，我们可以进行一些bug修复或功能修改然后git pull到开源项目，如果开源项目认可，可以将你的修改合并到他们的分支。</p>
</li>
</ul>
<p>根据上面的描述大约可以知道fork的作用了。我们fork完之后，代码存储到了云端并没有下载到本地。</p>
<p>fork之后我们可以通过github账号的repositories 里找到</p>
<p><strong>两者适用场景</strong></p>
<p>Git可以多人协作完成项目，或者我写完一个项目可以开源到GitHub上，看到的小伙伴fork我的代码之后发现有BUG或者有一个地方有更好的算法可以解决，他可以在他自己的仓库里面修改源码，修改好之后他可以pull request，这样我就可以看到什么地方修改了，如果我觉得他的算法可行就可以把他的代码Merge到我的项目里面，简单说就帮我修复bug了，不用我自己动手。</p>
<p>git clone 就是他们clone到本地进行修改，然后他可以提交到clone的源码中。</p>
<h3 id="git-推送本地分支到远程分支-git-push-origin"><a href="#git-推送本地分支到远程分支-git-push-origin" class="headerlink" title="git 推送本地分支到远程分支 git push origin"></a>git 推送本地分支到远程分支 git push origin</h3><p>推送本地分支local_branch到远程分支 remote_branch并建立关联关系</p>
<p>a.远程已有remote_branch分支并且已经关联本地分支local_branch且本地已经切换到local_branch</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p> b.远程已有remote_branch分支但未关联本地分支local_branch且本地已经切换到local_branch</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="literal">-u</span> origin/remote_branch</span><br></pre></td></tr></table></figure>

<p>c.远程没有remote_branch分支并，本地已经切换到local_branch</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin local_branch:remote_branch</span><br></pre></td></tr></table></figure>

<h3 id="git-remote关联了两个或多个仓库"><a href="#git-remote关联了两个或多个仓库" class="headerlink" title="git remote关联了两个或多个仓库"></a>git remote关联了两个或多个仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看远程仓库的数量（简单信息）</span></span><br><span class="line">git remote -v</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个远程仓库的具体信息，以origin为例：</span></span><br><span class="line">git remote show origin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如关联两个仓库: github 和码云</span></span><br><span class="line"> </span><br><span class="line">git remote add origin github-url</span><br><span class="line"> </span><br><span class="line">git remote add gitee gitee-url</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支有两个：master ，test-branch</span></span><br></pre></td></tr></table></figure>

<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41287260/article/details/89743120">https://blog.csdn.net/weixin_41287260/article/details/89743120</a></li>
</ul>
<h3 id="git-add外部文件"><a href="#git-add外部文件" class="headerlink" title="git add外部文件"></a>git add外部文件</h3><p>需要把外部文件复制到仓库目录下：<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-18-44-729f65c734788aa782d054c4bded528d-image20-dee2cb.png">{width=”8.770833333333334in”<br>height=”2.45625in”}</p>
<h3 id="git-add-文件"><a href="#git-add-文件" class="headerlink" title="git add 文件"></a>git add 文件</h3><p>方法一 git add 添加多个文件，文件之间以空格隔开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add file1 file2 file3</span><br></pre></td></tr></table></figure>

<p>方法二 多次git add</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add file1</span><br><span class="line"></span><br><span class="line">git add file2</span><br><span class="line"></span><br><span class="line">git add file2</span><br></pre></td></tr></table></figure>

<p>方法三 添加指定目录下的文件<br>config目录下及子目录下所有文件，home目录下的所有.php文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config/*</span><br><span class="line"></span><br><span class="line">git home/*.php</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法四 git add . 添加所有的文件， 或者 git add --all 添加所有的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git add --all</span><br></pre></td></tr></table></figure>

<p>方法五 添加所有子目录(**/)下的所有.zip文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add **/*.zip </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="git-commit-提交到版本库"><a href="#git-commit-提交到版本库" class="headerlink" title="git commit 提交到版本库"></a>git commit 提交到版本库</h3><p>git add 目的是将修改文件由工作区提交到暂存区，可以多次提交<br>然后commit操作，将文件从暂存区提交到版本库</p>
<p>git commit -m &quot;add new file&quot;</p>
<h2 id="git-廖雪峰学习文档"><a href="#git-廖雪峰学习文档" class="headerlink" title="git 廖雪峰学习文档"></a>git 廖雪峰学习文档</h2><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p>先来看名词解释。</p>
<h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：<img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-30-06-2012268feac886848fd1c027c8329c5d--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-f0ea7f.png" alt="working-dir"></p>
<h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/21/12-48-38-701e02bf0b2d71ab51b7e2b6aa973d52-0-9b8ebd.jpeg" alt="git-repo"></p>
<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure>

<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>
<p>先用<code>git status</code>查看一下状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   LICENSE</span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>现在，暂存区的状态就变成这样了：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-07-3140921b12cc7d9a949076b2bb80d637--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-ec896c.jpeg" alt="git-stage"></p>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;understand how stage works&quot;</span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>

<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/05/15-32-41-f6ddf40f921f9953b6f84d107a11f689--var-folders-84-tzfvcm9s5wlc1gcjq2qpqygw0000gn-T-abnerworks.Typora-0-20201205153241447-d86c8b.jpeg" alt="git-stage-after-commit"></p>
<p>git-stage视频：</p>
<p><video id="video" controls="" preload="none" poster="http://media.w3.org/2010/05/sintel/poster.png">   <source id="mp4" src="https://www.bilibili.com/video/av51227250?zw " type="video/mp4"> </video></p>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576">https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576</a></li>
</ul>
<blockquote>
<p>他人整理如下： <a target="_blank" rel="noopener" href="https://blog.csdn.net/u014734886/article/details/79527710">https://blog.csdn.net/u014734886/article/details/79527710</a></p>
</blockquote>
<h2 id="一、git初始化本地仓库和配置"><a href="#一、git初始化本地仓库和配置" class="headerlink" title="一、git初始化本地仓库和配置"></a>一、git初始化本地仓库和配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;想输入到文件的内容，一般为# 库名字&quot; &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>如果没有配置需要配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;abc@bupt.edu.cn&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;xy&quot;</span><br><span class="line"></span><br><span class="line">git config --list</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还可以配置git显示颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置别名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status 使用git st 代替 git status</span><br><span class="line"></span><br><span class="line">git config --global alias.co checkout 使用git co 代替 git checkout</span><br><span class="line"></span><br><span class="line">git config --global alias.ci commit 使用git ci 代替 git commit</span><br><span class="line"></span><br><span class="line">git config --global alias.br branch 使用git br 代替 git branch</span><br></pre></td></tr></table></figure>

<p>有人丧心病狂地把lg配置成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph</span><br><span class="line">--pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)</span><br><span class="line">%C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二、提交文件"><a href="#二、提交文件" class="headerlink" title="二、提交文件"></a>二、提交文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git status  查看当前仓库的状态</span><br><span class="line"></span><br><span class="line">git diff file_name</span><br><span class="line"></span><br><span class="line">git add file2.txt file3.txt 想添加所有的文件git add .</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git commit -m &quot;提交记录文字&quot;</span><br><span class="line"></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Fixes bug&quot;</span><br></pre></td></tr></table></figure>

<p>如果发现commit信息写错了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &quot;Fixes bug #42&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、回退"><a href="#三、回退" class="headerlink" title="三、回退"></a>三、回退</h2><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-20201205155858-2020-12-05-15-58-59.png" alt="学习笔记-20201205155858-2020-12-05-15-58-59"></p>
<h3 id="1-查看commit信息和命令信息"><a href="#1-查看commit信息和命令信息" class="headerlink" title="1.查看commit信息和命令信息"></a>1.查看commit信息和命令信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log（查看当前状态下的commit信息，不能查看以后的信息）</span><br><span class="line"></span><br><span class="line">git reflog（查看所有的命令信息）</span><br><span class="line"></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">git log -p --graph</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/98c473fb0ee2">https://www.jianshu.com/p/98c473fb0ee2</a></p>
<p>通过 git pull更新后，会显示别人修改了哪些文件。此时你想要查看某个文件的具体修改的内容，可通过下面的命令去查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log -p   + 文件名 （可查看该文件以前每一次push的修改内容）</span><br><span class="line">git log - p -1   + 文件名 （只查看该文件当前这一次的push内容）</span><br><span class="line"></span><br><span class="line">git log --graph 看到分支合并图</span><br><span class="line"></span><br><span class="line">git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-回退"><a href="#2-回退" class="headerlink" title="2.回退"></a>2.回退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id </span><br></pre></td></tr></table></figure>

<p>除了–hard参数外，还有–soft，–mixed。</p>
<p><strong>下面详细介绍这三个参数：</strong></p>
<ul>
<li><p>add表示add操作之后的结果</p>
</li>
<li><p>commit表示commit之后的结果</p>
</li>
<li><p>push:表示进行push操作之后的结果</p>
</li>
<li><p>(stash)表示在add前可能存在stash操作（即暂存工作区的操作）</p>
</li>
</ul>
<p>假设某次提交过程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init--(stash1)--add1--commit1--push1--(stash2)--add2--commit2--push2--(stash3)--add3--commit3--push3</span><br></pre></td></tr></table></figure>

<p>举例</p>
<ul>
<li><p>–hard<br>回退到某个版本commit之前的状态，进行1，2，3操作。如现在在commit2，或者add2，可以回到commit3或者commit1</p>
</li>
<li><p>–soft<br>回退到某次commit前的stage状态（即处于暂存状态），进行1操作。如现在在commit2，可以回到add1，或者add3</p>
</li>
<li><p>–mixed<br>回退到add前的状态（即处于工作区，如果有stash，需通过stash pop之后才能真的回到暂存的状态），执行1，2操作。<br>如现在在commit2，可以回退到init–(stash1)，或者commit1-push1–(stash2)，或者</p>
</li>
</ul>
<h3 id="3-HEAD介绍"><a href="#3-HEAD介绍" class="headerlink" title="3.HEAD介绍"></a>3.HEAD介绍</h3><p>HEAD指向的版本就是当前版本，<code>HEAD^</code>,前一个版本，<code>HEAD^^</code>前两个，<code>HEAD~100</code>，前100个版本</p>
<h3 id="4-查看远程log"><a href="#4-查看远程log" class="headerlink" title="4.查看远程log"></a>4.查看远程log</h3><p><code>git fetch --all </code>可以把远程的commit信息拉到本地更新到本部版本库的master<br>HEAD指针上，然后利用<code>git log</code>和<code>git reflog</code>进行查看操作</p>
<p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本，也可以用git reflog。</p>
<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<p>建议都用<code>git reflog</code></p>
<h2 id="四、切换暂存区、工作区"><a href="#四、切换暂存区、工作区" class="headerlink" title="四、切换暂存区、工作区"></a>四、切换暂存区、工作区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git stash   #暂存工作现场</span><br><span class="line"></span><br><span class="line">git stash list #会出现stash@&#123;0&#125;: WIP on dev: 6224937 add mergegit</span><br><span class="line"></span><br><span class="line">git stash pop #将暂存区的环境恢复到工作区</span><br><span class="line"></span><br><span class="line">git stash list  #此时暂存区已经没有数据了</span><br><span class="line"></span><br><span class="line">git diff HEAD -- readme.txt 查看工作区和版本库里面最新版本的区别</span><br><span class="line"></span><br><span class="line">git checkout -- readme.txt</span><br><span class="line">把工作区的修改全部撤销,其中--不能省，否则就变成切换分支了。</span><br><span class="line"></span><br><span class="line">git reset HEAD file_name</span><br><span class="line">可以把暂存区的修改撤销掉（unstage），重新放回工作区</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于git checkout可以看一下这篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuyuecs/p/7111749.html">https://www.cnblogs.com/kuyuecs/p/7111749.html</a></p>
</blockquote>
<p><strong>checkout命令用法如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">git checkout [-q] [&lt;commit&gt;] [--] &lt;paths&gt; ...</span><br><span class="line">#2</span><br><span class="line">git checkout [&lt;branch&gt;]</span><br><span class="line">#3</span><br><span class="line">git checkout [-m] [ [-b | -- orphan ] &lt;new_branch&gt;]</span><br><span class="line"> [start_point] </span><br></pre></td></tr></table></figure>

<p>用法2比用法1的区别在于，用法1包含了路径。为了避免路径和引用（或提交ID）同名而发生冲突，可以在&lt;paths&gt;前用两个连续的连字符作为分隔。用法1的&lt;commit&gt;是可选项，如果省略，则相当于从暂存区进行检出。</p>
<h2 id="五、删除文件"><a href="#五、删除文件" class="headerlink" title="五、删除文件"></a>五、删除文件</h2><h3 id="1-删除本地文件"><a href="#1-删除本地文件" class="headerlink" title="1.删除本地文件"></a>1.删除本地文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file_name</span><br><span class="line"></span><br><span class="line">git commit -m &quot;删除信息&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2，误删"><a href="#2，误删" class="headerlink" title="2，误删"></a>2，误删</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<p>用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。</p>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<ul>
<li><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
</li>
<li><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
</li>
</ul>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<h3 id="3-删除远端文"><a href="#3-删除远端文" class="headerlink" title="3.删除远端文"></a>3.删除远端文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached --force .idea&#x2F; </span><br></pre></td></tr></table></figure>

<p>删除文件不需要加-r，删除文件夹需要-r， 该文件夹路径为本地文件夹所在路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;delete .idea&#x2F;&quot; 提交记录</span><br><span class="line">git push origin master  推到远端</span><br></pre></td></tr></table></figure>


<h2 id="六、本地分支和远程分支"><a href="#六、本地分支和远程分支" class="headerlink" title="六、本地分支和远程分支"></a>六、本地分支和远程分支</h2><h3 id="1-查看本地分支，带星号的表示当前所在本地分支"><a href="#1-查看本地分支，带星号的表示当前所在本地分支" class="headerlink" title="1.查看本地分支，带星号的表示当前所在本地分支"></a>1.查看本地分支，带星号的表示当前所在本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>查看远程和本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p>如果没有成功，先<code>git fetch origin</code>，然后我们在<code>git branch -a</code></p>
<h3 id="2-创建本地分支"><a href="#2-创建本地分支" class="headerlink" title="2.创建本地分支"></a>2.创建本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch dev #创建分支dev</span><br><span class="line"></span><br><span class="line">git checkout dev #切换分支（不要随意切分支，</span><br><span class="line">#如果你在某个分支上面修改了一些东西，但没有stash，那么你切换分支后修改的东西就没有任何保存了，如果想切，请先git stash，然后git checkout dev) stash后没有stash pop，然后reset --hard</span><br><span class="line"></span><br><span class="line">git checkout -b dev #创建并切换分支也可以用于切换已有分支</span><br></pre></td></tr></table></figure>

<h3 id="3-创建远程分支"><a href="#3-创建远程分支" class="headerlink" title="3.创建远程分支"></a>3.创建远程分支</h3><p> 如果想把本地的test分支提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#提本地test支作为远程的master分支</span><br><span class="line">git push origin test:master</span><br><span class="line"></span><br><span class="line">#提交本地test分支作为远程的test分支</span><br><span class="line">git push origin test:test</span><br></pre></td></tr></table></figure>

<p>也可以在github网站直接创建</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage22.png-2020-12-05-16-32-09.png" alt="学习笔记-学习笔记mediaimage22.png-2020-12-05-16-32-09"></p>
<h3 id="4-合并本地分支"><a href="#4-合并本地分支" class="headerlink" title="4.合并本地分支"></a>4.合并本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>

<p>合并当前分支，一般先切换到需要被合并的分支，如切换到master，该命令在master分支上输入会将dev分支合并到master分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>

<p>–no-ff参数，表示禁用Fast<br>forward，用普通模式合并，合并后的历史有分支，能看出来曾经做过合并。</p>
<p>merge和rebase的区别:<a target="_blank" rel="noopener" href="https://blog.csdn.net/wh_19910525/article/details/7554489">https://blog.csdn.net/wh_19910525/article/details/7554489</a></p>
<p>git merge b # 将b分支合并到当前分支</p>
<p>git rebase b，也是把 b分支合并到当前分支</p>
<p>假设目前分支：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image23-2020-12-05-16-34-27.jpeg" alt="学习笔记-image23-2020-12-05-16-34-27"></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image24-2020-12-05-16-34-46.jpeg" alt="学习笔记-image24-2020-12-05-16-34-46"></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image25-2020-12-05-16-35-01.jpeg" alt="学习笔记-image25-2020-12-05-16-35-01"></p>
<h3 id="5-origin"><a href="#5-origin" class="headerlink" title="5.origin"></a>5.origin</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tyyking/article/details/82909099">https://blog.csdn.net/tyyking/article/details/82909099</a></p>
<p>git的服务器端(remote)端包含多个repository，每个repository可以理解为一个项目。而每个repository下有多个branch。”origin”就是指向某一个repository的指针。服务器端的”master”（强调服务器端是因为本地端也有master）就是指向某个repository的一个branch的指针。</p>
<p>这是服务器端(remote)的情况：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-image26-2020-12-05-16-35-44.png" alt="学习笔记-image26-2020-12-05-16-35-44"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:JasonDu1993&#x2F;learngit.git</span><br></pre></td></tr></table></figure>

<p>关联远程库，相当于让origin等于后面这个地址</p>
<h3 id="6-git-fetch-更新远程代码到本地仓库"><a href="#6-git-fetch-更新远程代码到本地仓库" class="headerlink" title="6.git fetch 更新远程代码到本地仓库"></a>6.git fetch 更新远程代码到本地仓库</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenlogin/p/6592228.html">https://www.cnblogs.com/chenlogin/p/6592228.html</a></p>
<p>理解 fetch 的关键, 是理解 FETCH_HEAD，FETCH_HEAD指的是:<br>某个branch在服务器上的最新状态</p>
<p>当前分支指向的FETCH_HEAD, 就是这个文件第一行对应的那个分支.</p>
<p>一般来说, 存在两种情况:</p>
<p>1）如果没有显式的指定远程分支, 则远程分支的master将作为默认的FETCH_HEAD.</p>
<p>2）如果指定了远程分支, 就将这个远程分支作为FETCH_HEAD.</p>
<p>命令1：<code>git fetch origin branch1</code></p>
<p>设定当前分支的 FETCH_HEAD’ 为远程服务器的branch1分支。这个操作是<code>git pull origin branch1</code>的第一步,<br>而对应的pull操作,并不会在本地创建新的branch。</p>
<p>同时这个命令还可以用来测试远程主机的远程分支branch1是否存在, 如果存在,<br>返回0, 如果不存在, 返回128, 抛出一个异常.</p>
<p>命令2：<code>git fetch origin branch1:branch2</code></p>
<p>使用远程branch1分支在本地创建branch2(但不会切换到该分支),如果本地不存在branch2分支,<br>则会自动创建一个新的branch2分支,</p>
<p>如果本地存在branch2分支, 并且是<code>fast forward</code>, 则自动合并两个分支,<br>否则, 会阻止以上操作.</p>
<h3 id="7-fetch更新本地仓库两种方式"><a href="#7-fetch更新本地仓库两种方式" class="headerlink" title="7.fetch更新本地仓库两种方式"></a>7.fetch更新本地仓库两种方式</h3><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">&#x2F;&#x2F;从远程的origin仓库的master分支下载代码到本地的master分支</span><br><span class="line"></span><br><span class="line">git log -p master origin&#x2F;master &#x2F;&#x2F;比较本地的仓库和远程仓库的区别</span><br><span class="line"></span><br><span class="line">git merge origin&#x2F;master</span><br><span class="line">&#x2F;&#x2F;把远程下载下来的代码合并到本地仓库，远程的和本地的合并</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master:temp</span><br><span class="line">&#x2F;&#x2F;从远程的origin仓库的master分支下载到本地并新建一个分支temp</span><br><span class="line"></span><br><span class="line">git diff temp &#x2F;&#x2F;比较本地master分支和本地temp分支的不同</span><br><span class="line"></span><br><span class="line">git merge temp &#x2F;&#x2F;合并本地temp分支到本地master分支</span><br><span class="line"></span><br><span class="line">git branch -d temp &#x2F;&#x2F;删除本地temp分支</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-合并远程分支"><a href="#8-合并远程分支" class="headerlink" title="8.合并远程分支"></a>8.合并远程分支</h3><p>假设这两个分支是a和b，那么fetch a和b，checkout a，将b<br>merge(rebase)到a，push<br>a到远端。这样做，将b和a合到了一起，并且更新了本地和远端的a。如果b不需要了，可以删除远程b和本地b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin a:a #将远程a分支拉到本地a(冒号后面的a表示本地分支a)</span><br><span class="line"></span><br><span class="line">git fetch origin b:b #将远程b分支拉到本地b(冒号后面的b表示本地分支b)</span><br><span class="line"></span><br><span class="line">git checkout a #切到本地a分支</span><br><span class="line"></span><br><span class="line">git merge b   #将本地b分支合并到本地a分支上</span><br><span class="line"></span><br><span class="line">git push origin a #将本地a分支推到远程a分支</span><br><span class="line"></span><br><span class="line">git branch -d b  #删除本地分支</span><br><span class="line"></span><br><span class="line">git push origin --delete b   #删除远程b分支</span><br></pre></td></tr></table></figure>

<h3 id="9-删除本地分支"><a href="#9-删除本地分支" class="headerlink" title="9.删除本地分支"></a>9.删除本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev #删除分支</span><br></pre></td></tr></table></figure>

<h3 id="10-删除远程分支"><a href="#10-删除远程分支" class="headerlink" title="10.删除远程分支"></a>10.删除远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete dev</span><br></pre></td></tr></table></figure>

<h3 id="11-创建本地新分支并将新分支和远程某个分支相关联"><a href="#11-创建本地新分支并将新分支和远程某个分支相关联" class="headerlink" title="11.创建本地新分支并将新分支和远程某个分支相关联"></a>11.创建本地新分支并将新分支和远程某个分支相关联</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -a #查看本地和远程所有分支</span><br><span class="line"></span><br><span class="line">git checkout -b dev &#x2F;origin&#x2F;dev  #创建本地分支dev并和远程dev分支相关联同时切换到本地dev分支</span><br></pre></td></tr></table></figure>

<h3 id="12-修改commit信息"><a href="#12-修改commit信息" class="headerlink" title="12.修改commit信息"></a>12.修改commit信息</h3><p><strong>(1)没有push到远端，修改本地分支commit信息</strong></p>
<p>a. 未执行git push<br>之前可以使用如下的命令进行操作(只能撤销最近一次的commit)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git  reset --soft commit_id # (commit_id可以git reflog查看)</span><br><span class="line"></span><br><span class="line">git commit -m &quot;fix commit&quot;  #重新提交信息</span><br></pre></td></tr></table></figure>

<p>b. 如果要修改前面多出提交的历史信息，可以采用(2)里面的方法，只是不需要执行git push</p>
<p>命令总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line">git rebase -i HEAD~5</span><br></pre></td></tr></table></figure>

<p>把需要修改的commit信息前的pick改成edit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>多次重复执行前面两个命令直到更新</p>
<p><strong>(2) 已经push到远端 ，修改本地分支commit信息和远程分支commit信息</strong></p>
<p>命令总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev  #(切换到dev分支)</span><br><span class="line"></span><br><span class="line">git rebase -i HEAD~5  #(对最近5个提交记录进行rebase操作)</span><br></pre></td></tr></table></figure>

<p>把需要修改的commit信息前的pick改成edit <br>(linux下一般通过vim进行操作，即输入i进入编辑模式，修改对应内容，然后esc，接着输入:wq保存退出)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend  #(输入i进入修改模式，修改commit信息，修改完后使用esc退出修改模式，接着输入:wq保存修改)</span><br><span class="line"></span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>多次重复执行前面两个命令直到更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev -f</span><br></pre></td></tr></table></figure>

<p><strong>下面是详细介绍如何修改已经push 的commit 的信息</strong><br>原文链接：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39956074/article/details/83992286">https://blog.csdn.net/qq_39956074/article/details/83992286</a> </p>
<p><strong>如何修改已经push 的commit 的信息</strong><br>A. <code>git rebase -i HEAD~5</code><br>最新提交的版本为倒数第一个版本，5表示倒数第5个版本，这个数字可以修改，如改成2</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0mediaimage27.png-2020-12-05-16-49-50.png" alt="学习笔记-学习笔记mediaimage27.png-2020-12-05-16-49-50"></p>
<p>前5行即为<code>HEAD～5</code>所提交的信息，第一行为倒数第五个版本的commit信息，第五行为倒数第一个版本commit信息，每行开头是pick，然后是commit id， 然后是commit信息</p>
<p>B.输入i进入修改模式，将需要修改的commit信息前的pick改成edit，修改完后使用esc退出修改模式，接着输入:wq保存修改。</p>
<p>C.命令行输入 <code>git commit --amend</code>，输入i进入修改模式，修改commit信息，修改完后使用esc退出修改模式，接着输入:wq保存修改。</p>
<p>【注】保存之后 <code>git rebase --continue</code>还没有使用之前还可以使用<code>git commit --amend</code>继续修改这条commit信息，但如果提交了就只能从头再来了，即使用<code>git rebase -i HEAD~5 </code>把pick改成edit保存退出，然后<code>git commit --amend</code>，保存修改信息之后屏幕输出以下内容</p>
<p>保存修改后命令行会输出以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[detached HEAD fbe9591] 20190716c, bs 16, lr 0.001, maxiter 60000, steps &quot;(50000, 55000)&quot;, 8000</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Date: Mon Jul 15 18:11:43 2019 +0800</span><br><span class="line"> </span><br><span class="line">1 file changed, 3 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>D.命令行输入<code>git rebase --continue</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git rebase --continue</span><br><span class="line"> </span><br><span class="line">Stopped at 896acbdf7545b0e42ff761376a2cdbca899b445d... 20190715c, bs 8, lr 0.0025, maxiter 60000, steps &quot;(50000, 55000)&quot;, 8000</span><br><span class="line"> </span><br><span class="line">You can amend the commit now, with</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">git commit --amend</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">git rebase --continue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出这些信息是因为我们把多个pick改成了edit，因此继续修改commit信息直到全部修改完成，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git commit --amend</span><br><span class="line"> </span><br><span class="line">[detached HEAD 70929e1] 20190715e, bs 8, lr 0.0025, maxiter 60000, steps &quot;(50000, 55000)&quot;, 8000</span><br><span class="line"> </span><br><span class="line">Date: Mon Jul 15 18:19:56 2019 +0800</span><br><span class="line"> </span><br><span class="line">1 file changed, 4 insertions(+), 4 deletions(-)</span><br><span class="line"> </span><br><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git rebase --continue</span><br><span class="line"> </span><br><span class="line">Successfully rebased and updated refs&#x2F;heads&#x2F;jason.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>E.<code>git push origin dev -f</code><br>将本地更新推送到远程分支上，必须加上-f，否则我们edit的commit会添加到commit后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(py3) jason@jason:~&#x2F;workspace&#x2F;mask-detection$ git push origin dev -f</span><br><span class="line"> </span><br><span class="line">Password for &#39;http:&#x2F;&#x2F;jason@git.sankuai.com&#39;: 输入密码</span><br><span class="line"> </span><br><span class="line">Counting objects: 40, done.</span><br><span class="line"> </span><br><span class="line">Delta compression using up to 12 threads.</span><br><span class="line"> </span><br><span class="line">Compressing objects: 100% (40&#x2F;40), done.</span><br><span class="line"> </span><br><span class="line">Writing objects: 100% (40&#x2F;40), 7.75 KiB | 0 bytes&#x2F;s, done.</span><br><span class="line"> </span><br><span class="line">Total 40 (delta 31), reused 0 (delta 0)</span><br><span class="line"> </span><br><span class="line">remote:</span><br><span class="line"> </span><br><span class="line">remote: Create pull request for jason:</span><br><span class="line"> </span><br><span class="line">remote: http:&#x2F;&#x2F;git.sankuai.com&#x2F;users&#x2F;lvtingxun&#x2F;repos&#x2F;mask-detection&#x2F;compare&#x2F;commits?sourceBranch&#x3D;refs&#x2F;heads&#x2F;dev</span><br><span class="line"> </span><br><span class="line">remote:</span><br><span class="line"> </span><br><span class="line">To http:&#x2F;&#x2F;jason@***.git</span><br><span class="line"> </span><br><span class="line">+ b26a84a...70929e1 dev -&gt; dev (forced update)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-删除commit信息"><a href="#13-删除commit信息" class="headerlink" title="13.删除commit信息"></a>13.删除commit信息</h3><p>git 删除远程分支上的某次提交原文：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/QQxiaoqiang1573/article/details/68074847">https://blog.csdn.net/QQxiaoqiang1573/article/details/68074847</a> </p>
<p><strong>(1) 没有push到远端，删除本地commit信息</strong></p>
<p>A.删除最后一次提交记录</p>
<p>git reflog能查看所有历史操作记录，如果只想看commit信息，可以使用git<br>log，两者都能查到commit id</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-24-7d7b962a0e07f5d49418c4268577902f-image28-614ef5.png" alt="IMG_257">{width=”5.854166666666667in”<br>height=”1.21875in”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> git revert HEAD </span><br></pre></td></tr></table></figure>

<p>将回到倒数第二次提交后的版本，但本次操作会生成commit信息进行提交（输入i进入编辑状态，编辑完信息后按ESC，接着输入:wq保存退出）</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-58-49-1d7bb19fe4188d6de19a5120f330096e-image29-5332f5.png" alt="IMG_258">{width=”5.822916666666667in”<br>height=”3.53125in”}</p>
<p>保存退出后输出如下，此时已经回退到倒数第二次提交的时候：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-20-1deb9320af5a425d8e1e02ca5c9184e8-image30-40c5b0.png" alt="IMG_259">{width=”5.09375in”<br>height=”0.6354166666666666in”}</p>
<p>通过git<br>log查看提交的记录，发现会生成一次新的commit信息，但是内容已经更新到之前的了</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-33-3d49d3ec358fcd726421df18e3439ff2-image31-e7bed9.png" alt="IMG_260">{width=”5.875in”<br>height=”3.5208333333333335in”}</p>
<p>或者<br><code>git reset --hard HEAD^ </code>注意后面有个^表示将回到倒数第二次提交后的版本</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-47-fc603198cc94a93c22b3c1a4cf86ae01-image32-05ae14.png" alt="IMG_261">{width=”3.3125in”<br>height=”0.3854166666666667in”}</p>
<p>操作前的提交记录</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/16-59-55-db53e89c0d0421c1afd2dc1c9e257bec-image33-a0649c.png" alt="IMG_262">{width=”5.802083333333333in”<br>height=”3.4583333333333335in”}</p>
<p>操作后的提交记录</p>
<p><code>git log</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-06-7192d4ded3c4a88a0a438d4c4ae50a64-image34-e57f36.png" alt="IMG_263">{width=”5.84375in”<br>height=”3.5104166666666665in”}</p>
<p>[注] revert会生成一次新的提交，之前commit的信息还在，reset<br>则不会保留之前的提交记录信息</p>
<p>B.删除历史提交中的某次或者多次提交记录</p>
<p>例子：删除最后一次和倒数第三次提交记录</p>
<ol>
<li><code>git log</code> 找到你要删除的最远的<code>commit id</code>，本次测试选择了红色框的commit信息进行删除，也可以通过<code>git reflog</code>查看<code>commit id</code></li>
</ol>
<p><code>git log</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-16-7805d35ac338422bfca0392abf72374d-image35-79c71e.png" alt="IMG_264">{width=”5.854166666666667in”<br>height=”4.5in”}</p>
<p>2)<code> git rebase -i HEAD~5</code><br>最新提交的版本为倒数第一个版本，5表示倒数第5个版本，这个数字可以修改，如改成3进入下面的编辑页面，或者git<br>rebase -i “commit id”^   注意后面有个^符号，加不加””都可以，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3 </span><br></pre></td></tr></table></figure>

<p>(输入i进入编辑状态，删除第一行的内容，编辑完信息后按ESC，接着输入:wq保存退出)</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-29-3787014405122b6bab510595d1f67c8f-image36-58d7e9.png" alt="IMG_265">{width=”5.8125in”<br>height=”3.1979166666666665in”}</p>
<p>删除第一行内容和第三行内容，即删除倒数第三次提交和最后一次提交的内容</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-46-907a7552e60ade951ac68fefd0ae0475-image37-5a4873.png" alt="IMG_266">{width=”4.864583333333333in”<br>height=”1.2083333333333333in”}</p>
<p>保存退出后输出如下，此时回到删除改提交之前的那次提交后的状态，即commit信息为”删除commit信息2”</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-00-54-7861202049bf28c4e0b02a0e0cfb9646-image38-d2549a.png" alt="IMG_267">{width=”5.854166666666667in”<br>height=”1.6041666666666667in”}</p>
<p>此时<code>git log</code>，回到了要删除commit信息前一次提交的状态</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-01-5f3dd4037789e1471433f7b4c6471dd8-image39-3701ae.png" alt="IMG_268">{width=”5.822916666666667in”<br>height=”3.3541666666666665in”}</p>
<p>但有冲突，需要解决，冲突的文件内容如下所示</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-14-79701861ba33c16dd061af7ab8d9fdb2-image40-3604cf.png" alt="IMG_269">{width=”5.875in”<br>height=”0.9270833333333334in”}</p>
<p>a)，解决冲突文件后内容如下</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-27-8d95fbbaac75e564a6e381a823963be1-image41-b9f423.png" alt="IMG_270">{width=”3.1354166666666665in”<br>height=”0.3541666666666667in”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git rebase --continue  #（直接退出文件，通过:q退出）</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-34-f3588fbd8ff4cc8f57fd7b52145b133d-image42-d1b4a6.png" alt="IMG_271">{width=”5.84375in”<br>height=”2.15625in”}</p>
<p>如果没有使用<code>git add . </code>而直接使用<code>git rebase --continue</code>会提示下面的信息</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-45-0117a0f019fd2f1c5b58c3d84d94fa01-image43-0c7c1c.png" alt="IMG_272">{width=”3.2083333333333335in”<br>height=”0.6979166666666666in”}</p>
<p>此时输出如下：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-52-5e1c6ec87cd49947634dde35b1dbca61-image44-25d6d0.png" alt="IMG_273">{width=”4.020833333333333in”<br>height=”0.6458333333333334in”}</p>
<p><code>git log</code>发现第三次和第五次提交的commit信息已经删除了</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-01-58-1f3bf58e1d2102553824b87ab13bbd30-image45-3c423b.png" alt="IMG_274">{width=”5.854166666666667in”<br>height=”4.385416666666667in”}</p>
<p>b) 不解决冲突，通过<code>git rebase --skip</code><br>跳过解决冲突，直接回退到第三次提交后的状态。类似于使用git reset回退</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-14-1867d75af9c5dc305130349b6adcbd8f-image46-2d79c2.png" alt="IMG_275">{width=”3.7604166666666665in”<br>height=”0.375in”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-06-ca6d1ccb0acf2b7980d2193ccd72ddc7-image47-6c2615.png" alt="IMG_276">{width=”5.854166666666667in”<br>height=”2.65625in”}</p>
<p>文件中的内容:</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-06-b5ddd5f3cf54db08d07746d951b5039f-image48-9450fb.png" alt="IMG_277">{width=”5.885416666666667in”<br>height=”0.4895833333333333in”}</p>
<p>c)，不解决冲突，通过<code>git rebase --abort</code>回到最新提交的状态，所有东西都回到rebase前，因此此时并没有删除commit信息，要想删除就得解决冲突。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-21-44-83545c1a9844f53a24e53f3b2bca1aa6-image49-eea995.png" alt="IMG_278">{width=”4.1875in”<br>height=”0.375in”}</p>
<p><code>git log</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-20-53-4c5865f227274bbf92353bbd22b50d65-image50-2cb8e9.png" alt="IMG_279">{width=”5.8125in”<br>height=”4.197916666666667in”}</p>
<p><strong>(2) 已经push到远端，删除本地commit信息和远程commit信息</strong></p>
<p>在(1)完成的基础上，只需要加上<code>git push orgin master -f</code><br>即可将master分支上的commit信息删除</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-23-f398f7bb150853bc40db13154a57314a-image51-93b6f3.png" alt="IMG_280">{width=”5.145833333333333in”<br>height=”1.5104166666666667in”}</p>
<p><code>git push orgin master -f</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-30-80bdcc06dbf6463f2baf0a7387760fb5-image52-dea17a.png" alt="IMG_281">{width=”6.802083333333333in”<br>height=”2.5416666666666665in”}</p>
<p>远程最新的文档内容：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-02-37-aebe80c876b2d1692544da5a0b26cf4c-image53-1fecda.png" alt="IMG_282">{width=”6.697916666666667in”<br>height=”2.9270833333333335in”}</p>
<h2 id="七、分支策略"><a href="#七、分支策略" class="headerlink" title="七、分支策略"></a>七、分支策略</h2><p><strong>1.在实际开发中，我们应该按照几个基本原则进行分支管理：</strong></p>
<ol>
<li><p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
</li>
<li><p>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
</li>
<li><p>每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了</p>
</li>
</ol>
<p><strong>2.分支是否推送到远程</strong></p>
<ol>
<li><p>master分支是主分支，因此要时刻与远程同步；</p>
</li>
<li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
</li>
<li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
</li>
<li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
</li>
</ol>
<p> </p>
<h2 id="八、bug分支和暂存工作现场"><a href="#八、bug分支和暂存工作现场" class="headerlink" title="八、bug分支和暂存工作现场"></a>八、bug分支和暂存工作现场</h2><h3 id="1-bug分支的用途"><a href="#1-bug分支的用途" class="headerlink" title="1.bug分支的用途"></a>1.bug分支的用途</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成又不想commit时，先把工作现场暂存，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<p> </p>
<h3 id="2-创建bug分支的流程"><a href="#2-创建bug分支的流程" class="headerlink" title="2.创建bug分支的流程"></a>2.创建bug分支的流程</h3><p>假设暂存现场在dev分支，总体流程如下：</p>
<ol>
<li><p>git stash  # 暂存工作现场（去修bug，假设bug在master分支上）</p>
</li>
<li><p>git checkout master</p>
</li>
<li><p>修改bug</p>
</li>
<li><p>git add .</p>
</li>
<li><p>git commit -m “fix bug on master”</p>
</li>
<li><p>git push origin master</p>
</li>
<li><p>git checkout dev  切到dev分支</p>
</li>
<li><p>git stash list 会出现stash@{0}: WIP on dev: 6224937 add mergegit</p>
</li>
<li><p>git stash pop 将之前本地dev分支暂存的环境恢复出来</p>
</li>
<li><p>(还可以通过 git stash apply stash@{0}进行恢复，再删除stask内容git stash drop)</p>
</li>
<li><p>git stash list  再次查看还有暂存现场没有</p>
</li>
</ol>
<p> </p>
<h2 id="九、feature分支"><a href="#九、feature分支" class="headerlink" title="九、feature分支"></a>九、feature分支</h2><p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，用<code>git branch -d &lt;name&gt;</code>，若要强行删除使用-D</p>
<p> </p>
<h2 id="十、github远程仓库"><a href="#十、github远程仓库" class="headerlink" title="十、github远程仓库"></a>十、github远程仓库</h2><h3 id="1-使用ssh创建key"><a href="#1-使用ssh创建key" class="headerlink" title="1.使用ssh创建key"></a>1.使用ssh创建key</h3><p>为了和远程库相关联需要添加key，如果不加好像每次需要输密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;***@qq.com&quot; # 后面的邮箱根据自己的情况修改</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该命令用于<br>创建id_rsa文件和id_rsa.pub文件，id_rsa是私钥，id_rsa.pub是公钥用于添加到github的ssh<br>key里面。文件位于用户目录下的.ssh文件里面</p>
<h3 id="2-本地仓库和远程仓库关联"><a href="#2-本地仓库和远程仓库关联" class="headerlink" title="2.本地仓库和远程仓库关联"></a>2.本地仓库和远程仓库关联</h3><p><strong>第一种情况：远程只有仓库没有内容时，将本地已经写好的代码关联到远程：</strong></p>
<ol>
<li><p>git init</p>
</li>
<li><p>git add .</p>
</li>
<li><p>git commit -m “first commit”</p>
</li>
<li><p>git remote add origin <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;</a>:JasonDu1993/learngit.git</p>
</li>
<li><p>关联远程库，相当于让origin等于后面这串地址</p>
</li>
<li><p>git push -u origin master</p>
</li>
<li><p>-u只在第一次推送分支时使用，将本地master推到远程master分支上</p>
</li>
<li><p>关联完之后就可以切分支或者创建其他分支了</p>
</li>
<li><p>git checkout master</p>
</li>
<li><p>git push origin master  将到本地master分支内容推到远程master分支上</p>
</li>
<li><p>git checkout -b dev  创建本地dev分支并切换到本地dev分支</p>
</li>
<li><p>git push origin dev  将本地dev分支推到远程dev分支</p>
</li>
</ol>
<p>一般master分支和dev分支都会推到远程</p>
<p><strong>第二种情况：远程仓库有内容，直接克隆到本地</strong></p>
<ol>
<li><p>git clone <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#109;</a>:JasonDu1993/gitskills.git</p>
</li>
<li><p>git branch -a 查看本地分支和远程分支</p>
</li>
<li><p>git checkout -b dev origin/dev  如果本地没有dev分支将会报错</p>
</li>
<li><p>git add file_name</p>
</li>
<li><p>git commit -m “记录提交信息”</p>
</li>
<li><p>git push origin dev</p>
</li>
</ol>
<p>在GitHub上，可以任意Fork开源仓库，这样拥有fork后的仓库的读写权限，你就可以push到你fork之后的这个仓库了，当然也可以推送pull<br>request给官方仓库来贡献代码。</p>
<p> </p>
<h3 id="3-关联仓库出现问题解决办法"><a href="#3-关联仓库出现问题解决办法" class="headerlink" title="3.关联仓库出现问题解决办法"></a>3.关联仓库出现问题解决办法</h3><p>1）如果<code>git checkout -b dev origin/dev</code>迁出分支出现问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal: Cannot update paths and switch to branch &#39;dev&#39; at the same time.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Did you intend to checkout &#39;orgin&#x2F;dev&#39; which can not be resolved as</span><br><span class="line">commit?</span><br></pre></td></tr></table></figure>

<p>解决办法是先<code>git fetch</code>，再<code>git checkout -b dev origin/dev</code></p>
<p> </p>
<p>2）如果<code>git push</code>失败，先<code>git pull</code></p>
<p>如果<code>git pull</code>失败，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p>
<p><code>git branch --set-upstream dev origin/dev</code>，（现在好像改成<code>git branch --set-upstream-to=origin/dev dev</code>）</p>
<p>然后在<code>git pull</code>，<code>git push origin master</code></p>
<p> </p>
<p>3） <code>git error: RPC failed; result=22, HTTP code = 411</code><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/love_rongrong/article/details/12557347">https://blog.csdn.net/love_rongrong/article/details/12557347</a></p>
<p>解决办法：改一下git的传输字节限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config http.postBuffer  524288000</span><br></pre></td></tr></table></figure>

<p>4）<code>error: RPC failed; result=22, HTTP code = 413</code></p>
<p>fatal: The remote end hung up unexpectedly </p>
<p>fatal: The remote end hung up unexpectedly</p>
<p>Everything up-to-date</p>
<p>这两个错误看上去相似，一个是411，一个是413</p>
<p>下面这个错误添加一下密钥就可以了</p>
<p>首先<code>ssh-keygen -t rsa -C &quot;abc@bupt.edu.cn&quot;</code>生成密钥</p>
<p> </p>
<h3 id="4-有时候不想解决冲突-建议还是解决冲突好）"><a href="#4-有时候不想解决冲突-建议还是解决冲突好）" class="headerlink" title="4.有时候不想解决冲突(建议还是解决冲突好）"></a>4.有时候不想解决冲突(建议还是解决冲突好）</h3><ol>
<li>从远处拉取最新的东西到本地（不想解决冲突直接接受远程仓库内容）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &#x2F;&#x2F;至少下载到本地不进行合并</span><br><span class="line"></span><br><span class="line">git reset --hard origin&#x2F;dev</span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>2)，将本地更新强制推到远程，不想解决和远程的冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin dev 或者git push -f origin dev</span><br></pre></td></tr></table></figure>


<h3 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5.删除分支"></a>5.删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#删除远程分支</span><br><span class="line">git push origin --delete dev</span><br><span class="line"></span><br><span class="line">#删除本地分支</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>

<h3 id="6-创建远程分支"><a href="#6-创建远程分支" class="headerlink" title="6.创建远程分支"></a>6.创建远程分支</h3><p> 如果想把本地的test分支提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin test:master   #提交本地test分支作为远程的master分支</span><br><span class="line"></span><br><span class="line">git push origin test:test  #提交本地test分支作为远程的test分支</span><br></pre></td></tr></table></figure>

<h3 id="7-查看远程分支commit信息用于回退到远程分支的某个版本"><a href="#7-查看远程分支commit信息用于回退到远程分支的某个版本" class="headerlink" title="7.查看远程分支commit信息用于回退到远程分支的某个版本"></a>7.查看远程分支commit信息用于回退到远程分支的某个版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>


<h3 id="8-修改远程仓库名称"><a href="#8-修改远程仓库名称" class="headerlink" title="8.修改远程仓库名称"></a>8.修改远程仓库名称</h3><p>1) 在本地仓库删除远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin 1</span><br></pre></td></tr></table></figure>

<p>2 )修改Github仓库名称： </p>
<p>在Github页面中，进入要修改的仓库，在页面上方选择”Settings”，即可重命名远程仓库。</p>
<ol start="3">
<li>添加新的远程仓库：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;JasonDu1993&#x2F;gitskill.git</span><br></pre></td></tr></table></figure>

<h3 id="9-fork别人的仓库后如何同原仓库保持同步更新"><a href="#9-fork别人的仓库后如何同原仓库保持同步更新" class="headerlink" title="9. fork别人的仓库后如何同原仓库保持同步更新"></a>9. fork别人的仓库后如何同原仓库保持同步更新</h3><p>Github进行fork后如何与原仓库同步l原文链接：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/matrix_google/article/details/80676034">https://blog.csdn.net/matrix_google/article/details/80676034</a> </p>
<p>1）git remote -v #查看远程目录地址</p>
<p>2）git branch -a  #查看所有分支情况</p>
<p>3）git remote add upstream 你fork之前的源仓库地址 #该操作将源仓库和上游代码库upstream相关联（重要1）</p>
<p>4）git remote -v #再次查看远程目录的地址</p>
<p>5）git stash  #暂存自己的工作状态（不是必须的，如果改了代码没有push则需要）</p>
<p>6）git fetch upstream  #抓取源仓库的修改文件（重要2）</p>
<p>7）git branch -a  #再次查看所有分支情况</p>
<p>8）git checkout master #切换到master分支</p>
<p>9）git merge upstream/master #将本地代码和源代码保持同步（最重要3）</p>
<p>10）git stash pop #将暂存区的环境恢复到工作区上传到远程仓库</p>
<p>11）git add .</p>
<p>12）git commit -m “update forked repository at 2019.06.05”</p>
<p>13）git push origin master #上传新的代码到自己的远程master分支</p>
<h3 id="10-git-pull-can’t-update"><a href="#10-git-pull-can’t-update" class="headerlink" title="10. git pull can’t update"></a>10. git pull can’t update</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No tracked branch configured for branch dev or the branch doesn&#39;t</span><br><span class="line">exist. To make your branch track a remote branch call, for example, git</span><br><span class="line">branch --set-upstream-to origin&#x2F;dev dev</span><br></pre></td></tr></table></figure>

<h2 id="十一、多人合作流程"><a href="#十一、多人合作流程" class="headerlink" title="十一、多人合作流程"></a>十一、多人合作流程</h2><p>因此，多人协作的工作模式通常是这样：</p>
<p>首先，可以试图用git push origin branch-name推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p>
<p>如果git pull提示”no tracking<br>information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p> </p>
<h2 id="十二、版本标签"><a href="#十二、版本标签" class="headerlink" title="十二、版本标签"></a>十二、版本标签</h2><p>标签用于发布版本时使用，相当于给某次commit取个名字</p>
<p><strong>1，添加标签</strong></p>
<ul>
<li><p><code>git tag &lt;name&gt; </code>用于新建一个标签一般取名name为v0.1等，默认为HEAD，也可以指定一个<code>commit id</code></p>
</li>
<li><p><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; </code>可以指定标签信息</p>
</li>
<li><p><code>git tag </code>可以查看所有标签</p>
</li>
</ul>
<p> </p>
<p><strong>2，删除标签</strong></p>
<ul>
<li><p><code>git tag -d &lt;tagname&gt; </code>删除一个本地标签</p>
</li>
<li><p><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除一个远程标签</p>
</li>
<li><p><code>git push origin &lt;tagname&gt; </code>推送一个本地标签</p>
</li>
<li><p><code>git push origin --tags</code> 推送全部未推送过的本地标签</p>
</li>
</ul>
<p> </p>
<h2 id="十三，忽略特特殊文件"><a href="#十三，忽略特特殊文件" class="headerlink" title="十三，忽略特特殊文件"></a>十三，忽略特特殊文件</h2><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件，同时提交这个文件到Git。</p>
<p> </p>
<p>例子如下，.gitignore文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line"></span><br><span class="line">Thumbs.db</span><br><span class="line"></span><br><span class="line">ehthumbs.db</span><br><span class="line"></span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line"></span><br><span class="line">*.py[cod]</span><br><span class="line"></span><br><span class="line">*.so</span><br><span class="line"></span><br><span class="line">*.egg</span><br><span class="line"></span><br><span class="line">*.egg-info</span><br><span class="line"></span><br><span class="line">dist</span><br><span class="line"></span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># iead</span><br><span class="line"></span><br><span class="line">.idea</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line"></span><br><span class="line">db.ini</span><br><span class="line"></span><br><span class="line">deploy_key_rsa</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>忽略文件的原则是：</p>
<ol>
<li><p>忽略操作系统自动生成的文件，比如缩略图等；</p>
</li>
<li><p>忽略编译生成的中间文件、可执行文件等，比如Java编译产生的.class文件；</p>
</li>
<li><p>忽略敏感信息的配置文件，比如存放口令的配置文件。</p>
</li>
</ol>
<p> </p>
<h2 id="十四、自定义Git服务器"><a href="#十四、自定义Git服务器" class="headerlink" title="十四、自定义Git服务器"></a>十四、自定义Git服务器</h2><p>假设你已经有sudo权限的用户账号并且该教程是在ubuntu下介绍的</p>
<ol>
<li>安装git：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个git用户，用来运行git服务：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建证书登录：<br>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</li>
<li>初始化Git仓库：</li>
</ol>
<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在/srv目录下输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git init --bare sample.git</span><br></pre></td></tr></table></figure>

<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>禁用shell登录：</li>
</ol>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p>
<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash </code><br>改为：</p>
<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code></p>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<ol start="6">
<li>克隆远程仓库：</li>
</ol>
<p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone git@server:&#x2F;srv&#x2F;sample.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cloning into &#39;sample&#39;...</span><br><span class="line"></span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>管理公钥</strong></p>
<p>如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。</p>
<p><strong>管理权限</strong></p>
<p>使用<strong>Gitolite</strong>就是这个工具管理权限</p>
<h2 id="十五、git常见错误及解决办法"><a href="#十五、git常见错误及解决办法" class="headerlink" title="十五、git常见错误及解决办法"></a>十五、git常见错误及解决办法</h2><p><strong>1.git缓存太小下载不下来大文件</strong></p>
<p>解决：<code>git config --global http.postBuffer 524288000</code></p>
<p><strong>2.有图片文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#39;survivors&#39;...</span><br><span class="line"></span><br><span class="line">remote: Counting objects: 124, done.</span><br><span class="line"></span><br><span class="line">remote: Compressing objects: 100% (120&#x2F;120), done.</span><br><span class="line"></span><br><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data</span><br><span class="line">remaining</span><br><span class="line"></span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line"></span><br><span class="line">fatal: early EOF</span><br><span class="line"></span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<p>解决：<code>git clone http://github.com/large-repository --depth 1</code></p>
<p><strong>3.更完美的解决下载不下来方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data</span><br><span class="line">remaining</span><br><span class="line"></span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line"></span><br><span class="line">fatal: early EOF</span><br><span class="line"></span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>方法一：<code>git config --global http.postBuffer 524288000</code></p>
<p>如果不行</p>
<p>方法二：<code>git clone http://github.com/large-repository --depth 1</code></p>
<p>如果还不行</p>
<p>方法三：一般clone http方式的容易产生此问题，改成SSH的方式也有效，即https://改为git://</p>
<p><strong>4.git remote: HTTP Basic: Access denied 错误解决办法</strong></p>
<p>来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lydiawork/p/10287797.html">https://www.cnblogs.com/lydiawork/p/10287797.html</a></p>
<p>问题描述：<br>git push 报 HTTP Basic: Access denied 错误</p>
<p>原因：本地git配置的用户名、密码与gitlabs上注册的用户名、密码不一致。<br><strong>解决方案：</strong></p>
<ol>
<li>如果账号密码有变动 用这个命令 <code>git config --system --unset credential.helper</code> 重新输入账号密码 应该就能解决了</li>
<li>如果用了第一个命令 还不能解决问题那么 用这个命令：<br><code>  git config --global http.emptyAuth true</code><br>3.如果以上两个方法不起作用，那么采用以下方法：</li>
</ol>
<p>进入控制面板》用户账号》凭据管理器？windows凭据》普通凭据，在里面找到git，点开编辑密码，更新为最新密码之后就可以正常操作了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
<div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kuangyl-max.github.io/2021/11/15/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="小邝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/linux/" class="post-title-link" itemprop="url">Linux命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-15 13:46:40" itemprop="dateCreated datePublished" datetime="2021-11-15T13:46:40+08:00">2021-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-20 18:38:32" itemprop="dateModified" datetime="2021-11-20T18:38:32+08:00">2021-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          
            <span id="/2021/11/15/linux/" class="post-meta-item leancloud_visitors" data-flag-title="Linux命令" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
	<span>℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/15/linux/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/15/linux/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>ssh教程</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wangdoc/ssh-tutorial">https://github.com/wangdoc/ssh-tutorial</a></p>
<h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>打印文档树</p>
<p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;mac</span><br><span class="line">brew install tree</span><br><span class="line">&#x2F;&#x2F;centos</span><br><span class="line">yum install tree</span><br><span class="line">&#x2F;&#x2F;ubuntu</span><br><span class="line">apt-get install tree</span><br></pre></td></tr></table></figure>



<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>打包压缩</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf myimages.gzip myimages</span><br></pre></td></tr></table></figure>

<p>分卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -b 50m myimages.gzip filePrefix #每个50m</span><br></pre></td></tr></table></figure>

<p>合并</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filePrefix* &gt; myimages.gzip</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf myimages.gzip</span><br></pre></td></tr></table></figure>

<h3 id="tar-bz"><a href="#tar-bz" class="headerlink" title="tar.bz"></a>tar.bz</h3><p>Linux下压缩比率较tgz大，即压缩后占用更小的空间，使得压缩包看起来更小。<br>但同时在压缩，解压的过程却是非常耗费CPU时间。</p>
<p>(1)打包压缩格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar -jcvf examples.tar.bz2 examples   (examples为当前执行路径下的目录)</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">-j, --bzip2 filter the archive through bzip2 通过bzip2压缩的形式对文件进行归档</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">tar -jcvf file.tar.bz2 dir #dir目录</span><br></pre></td></tr></table></figure>

<p>(2)释放解压：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -jxvf examples.tar.bz2 （解压至当前执行目录下）</span><br><span class="line">tar -jxvf examples.tar.bz2  -C &#x2F;path (&#x2F;path 解压至其它路径)</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">tar -jxvf file.tar.bz2</span><br><span class="line">tar -jxvf file.tar.bz2 -C &#x2F;temp</span><br></pre></td></tr></table></figure>

<h3 id="并行压缩"><a href="#并行压缩" class="headerlink" title="并行压缩"></a>并行压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pigz (gzip 并行版)</span><br><span class="line"></span><br><span class="line">lbzip2 (bzip2 ) yes</span><br><span class="line"></span><br><span class="line">pbzip2 (bzip2) yes</span><br><span class="line"></span><br><span class="line">pxz (xz )</span><br><span class="line"></span><br><span class="line">pixz (xz)</span><br></pre></td></tr></table></figure>

<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/weiji100/p/3964582.html">https://www.cnblogs.com/weiji100/p/3964582.html</a></p>
<p>如果你想查看一条命令（比如 ls）到底执行了多长时间，我们可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ time ls</span><br><span class="line">program  public_html  repo  rocscm</span><br><span class="line"> </span><br><span class="line">real    0m0.002s</span><br><span class="line">user    0m0.002s</span><br><span class="line">sys 0m0.000s</span><br></pre></td></tr></table></figure>

<p>我们可以使用一个 -v 选项，这样可以打印出更详细的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@roclinux &#x2F;]# \time -v ls</span><br></pre></td></tr></table></figure>

<p><code>\</code>不能少</p>
<h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p>tee：工具从标准输入读取并写入标准输出和文件，即：双向覆盖重定向&lt;屏幕输出|文本输入&gt;</p>
<p>区别：tee可以把一份数据同时写入几个文件中，而&gt;&gt;只能把一份数据写入到一个文件中；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste 1.txt 2.txt | tee 3.txt 4.txt</span><br></pre></td></tr></table></figure>

<h3 id="parallel"><a href="#parallel" class="headerlink" title="parallel"></a>parallel</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">parallel [options] [<span class="built_in">command</span> [arguments]] &lt; list_of_arguments</span><br><span class="line">parallel [options] [<span class="built_in">command</span> [arguments]] (::: arguments|:::: argfile(s))...</span><br><span class="line">cat ... | parallel --pipe [options] [<span class="built_in">command</span> [arguments]]</span><br><span class="line"></span><br><span class="line">常用选项：</span><br><span class="line">::: 后面接参数</span><br><span class="line">:::: 后面接文件</span><br><span class="line">-j、--<span class="built_in">jobs</span>   并行任务数</span><br><span class="line">-N  每次输入的参数数量</span><br><span class="line">--xargs会在一行中输入尽可能多的参数</span><br><span class="line">-xapply 从每一个源获取一个参数（或文件一行）</span><br><span class="line">--header  把每一行输入中的第一个值做为参数名</span><br><span class="line">-m   表示每个job不重复输出“背景”（context）</span><br><span class="line">-X   与-m相反，会重复输出“背景文本”</span><br><span class="line">-q  保护后面的命令</span><br><span class="line">--trim  lr 去除参数两头的空格，只能去除空格，换行符和tab都不能去除</span><br><span class="line">--keep-order/-k   强制使输出与参数保持顺序 --keep-order/-k</span><br><span class="line">--tmpdir/ --results   都是保存文件，但是后者可以有结构的保存</span><br><span class="line">--delay  延迟每个任务启动时间</span><br><span class="line">--halt  终止任务</span><br><span class="line">--pipe    该参数使得我们可以将输入（stdin）分为多块（block）</span><br><span class="line">--block  参数可以指定每块的大小</span><br></pre></td></tr></table></figure>

<h4 id="1-1输入源"><a href="#1-1输入源" class="headerlink" title="1.1输入源"></a><strong>1.1输入源</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令行单输入源</span></span><br><span class="line">$ parallel <span class="built_in">echo</span> ::: a b c d e | tee a.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line"><span class="comment"># stdin（标准输入）作为输入源</span></span><br><span class="line">$ cat a.txt | parallel <span class="built_in">echo</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line"><span class="comment"># GNU Parallel支持通过命令行指定多个输入源，它会生成所有的组合。这在某些需要组合时非常好用</span></span><br><span class="line">$ parallel <span class="built_in">echo</span> ::: A B C ::: D E F | tee b.txt</span><br><span class="line">A D</span><br><span class="line">A E</span><br><span class="line">A F</span><br><span class="line">B D</span><br><span class="line">B E</span><br><span class="line">B F</span><br><span class="line">C D</span><br><span class="line">C E</span><br><span class="line">C F</span><br><span class="line"><span class="comment"># 多个文件作为输入，此时多个文件中的内容也会像上面那样进行组合</span></span><br><span class="line">$ parallel -a a.txt -a b.txt <span class="built_in">echo</span></span><br><span class="line">a A D</span><br><span class="line">a A E</span><br><span class="line">a A F</span><br><span class="line">a B D</span><br><span class="line">a B E</span><br><span class="line">a B F</span><br><span class="line">a C D</span><br><span class="line">a C E</span><br><span class="line">a C F</span><br><span class="line">b A D</span><br><span class="line">b A E</span><br><span class="line">b A F</span><br><span class="line">b B D</span><br><span class="line">b B E</span><br><span class="line">b B F</span><br><span class="line">b C D</span><br><span class="line">b C E</span><br><span class="line">b C F</span><br><span class="line">c A D</span><br><span class="line">c A E</span><br><span class="line">...</span><br><span class="line"><span class="comment"># stdin（标准输入）作为文件源中的一个，使用 -， 输出结果同上</span></span><br><span class="line">$ cat a.txt |parallel -a - -a b.txt <span class="built_in">echo</span></span><br><span class="line"><span class="comment"># 可以使用::::代替-a，后面可接多个文件名,输出结果同上</span></span><br><span class="line">$ cat a.txt | parallel <span class="built_in">echo</span> :::: - b.txt</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，若不想像上面那样进行组合，可使用<code>--xapply</code>参数从每一个源获取一个参数（或文件一行），这个参数有些类似R中的函数，具有广播作用——如果其中一个输入源的长度比较短，它的值会被重复。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$  parallel --xapply <span class="built_in">echo</span> ::: A B C ::: D E F</span><br><span class="line">A D</span><br><span class="line">B E</span><br><span class="line">C F</span><br><span class="line">$ parallel --xapply <span class="built_in">echo</span> ::: A B C ::: D E F G H I</span><br><span class="line">A D</span><br><span class="line">B E</span><br><span class="line">C F</span><br><span class="line">A G</span><br><span class="line">B H</span><br><span class="line">C I</span><br></pre></td></tr></table></figure>

<h4 id="1-8-多参数"><a href="#1-8-多参数" class="headerlink" title="1.8 多参数"></a>1.8 多参数</h4><p><code>--xargs</code>会在一行中输入尽可能多的参数（与参数字符串长度有关），通过<code>-s</code>可指定一行中参数的上限。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) kuangyilun@dev-<span class="number">003</span><span class="symbol">:~/parallel_test</span>$ perl -e <span class="string">&#x27;for(1..30000)&#123;print &quot;$_\n&quot;&#125;&#x27;</span> &gt; num3000<span class="number">0</span></span><br><span class="line">(base) kuangyilun@dev-<span class="number">003</span><span class="symbol">:~/parallel_test</span>$ cat num3000<span class="number">0</span> <span class="params">| parallel --xargs echo |</span> wc -l</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">(base) kuangyilun@dev-<span class="number">003</span><span class="symbol">:~/parallel_test</span>$ cat num3000<span class="number">0</span> <span class="params">| parallel --xargs -s 10000 echo |</span> wc -l</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>为了获得更好的并发性，GNU Parallel会在文件读取结束后再分发参数。<br> GNU Parallel 在读取完最后一个参数之后，才开始第二个任务，此时会把所有的参数平均分配到4个任务（如果指定了4个任务）。<br> 第一个任务与上面使用 <code>--xargs</code> 的例子一样，但是第二个任务会被平均的分成4个任务，最终一共5个任务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat num30000 | parallel --<span class="built_in">jobs</span> 4 -m <span class="built_in">echo</span> | wc -l</span><br><span class="line">6</span><br><span class="line">$ parallel --<span class="built_in">jobs</span> 4 -m <span class="built_in">echo</span> ::: &#123;1..10&#125;</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h5 id="1-81-控制输出"><a href="#1-81-控制输出" class="headerlink" title="1.81 控制输出"></a>1.81 控制输出</h5><p>使用<code>--tag</code>以参数做为输出前缀，使用<code>--tagstring</code>修改输出前缀：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> parallel --tag echo foo-&#123;&#125; <span class="symbol">:</span><span class="symbol">:</span>: A B C</span><br><span class="line">A   foo-A</span><br><span class="line">B   foo-B</span><br><span class="line">C   foo-C</span><br><span class="line">$ parallel --tagstring &#123;&#125;-bar echo foo-&#123;&#125; <span class="symbol">:</span><span class="symbol">:</span>: A B C</span><br><span class="line">A-bar   foo-A</span><br><span class="line">B-bar   foo-B</span><br><span class="line">C-bar   foo-C</span><br></pre></td></tr></table></figure>

<p>使用 <code>-N</code> 限制每行参数的个数，其中<code>-N0</code>表示一次只读取一个参数，且不输入这个参数（作为计数器来使用）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -N4 <span class="built_in">echo</span> 1=&#123;1&#125; 2=&#123;2&#125; 3=&#123;3&#125; ::: A B C D E F G H</span><br><span class="line">1=A 2=B 3=C</span><br><span class="line">1=E 2=F 3=G</span><br><span class="line">$ parallel -N0 <span class="built_in">echo</span> foo ::: 1 2 3</span><br><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>



<p><code>--verbose</code>则在运行之前先打印命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --verbose <span class="built_in">echo</span> &#123;&#125; ::: A B C</span><br><span class="line"><span class="built_in">echo</span> A</span><br><span class="line"><span class="built_in">echo</span> B</span><br><span class="line"><span class="built_in">echo</span> C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<p>一般来说，GNU Parallel 会延迟输出，直到一组命令执行完成。使用<code>--ungroup</code>，可立刻打印输出已完成部分。(主进程不阻塞)</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -j2 <span class="string">&#x27;printf &quot;%s-start\n%s&quot; &#123;&#125; &#123;&#125;;sleep &#123;&#125;;printf &quot;%s\n&quot; -middle;echo &#123;&#125;-end&#x27;</span> <span class="symbol">:</span><span class="symbol">:</span>: <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span>-start</span><br><span class="line"><span class="number">2</span>-middle</span><br><span class="line"><span class="number">2</span>-<span class="keyword">end</span></span><br><span class="line"><span class="number">1</span>-start</span><br><span class="line"><span class="number">1</span>-middle</span><br><span class="line"><span class="number">1</span>-<span class="keyword">end</span></span><br><span class="line"><span class="number">4</span>-start</span><br><span class="line"><span class="number">4</span>-middle</span><br><span class="line"><span class="number">4</span>-<span class="keyword">end</span></span><br><span class="line">$ parallel -j2 --ungroup <span class="string">&#x27;printf &quot;%s-start\n%s&quot; &#123;&#125; &#123;&#125;;sleep &#123;&#125;;printf &quot;%s\n&quot; -middle;echo &#123;&#125;-end&#x27;</span> <span class="symbol">:</span><span class="symbol">:</span>: <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span>-start</span><br><span class="line"><span class="number">42</span>-start</span><br><span class="line"><span class="number">2</span>-middle</span><br><span class="line"><span class="number">2</span>-<span class="keyword">end</span></span><br><span class="line"><span class="number">1</span>-start</span><br><span class="line"><span class="number">1</span>-middle</span><br><span class="line"><span class="number">1</span>-<span class="keyword">end</span></span><br><span class="line">-middle</span><br><span class="line"><span class="number">4</span>-<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>强制使输出与参数保持顺序 <code>--keep-order/-k</code>：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ parallel -j2 -k <span class="string">&#x27;printf &quot;%s-start\n%s&quot; &#123;&#125; &#123;&#125;;sleep &#123;&#125;;printf &quot;%s\n&quot; -middle;echo &#123;&#125;-end&#x27;</span> <span class="symbol">:</span><span class="symbol">:</span>: <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span>-start</span><br><span class="line"><span class="number">4</span>-middle</span><br><span class="line"><span class="number">4</span>-<span class="keyword">end</span></span><br><span class="line"><span class="number">2</span>-start</span><br><span class="line"><span class="number">2</span>-middle</span><br><span class="line"><span class="number">2</span>-<span class="keyword">end</span></span><br><span class="line"><span class="number">1</span>-start</span><br><span class="line"><span class="number">1</span>-middle</span><br><span class="line"><span class="number">1</span>-<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="1-82-将输出保存到文件"><a href="#1-82-将输出保存到文件" class="headerlink" title="1.82 将输出保存到文件"></a>1.82 将输出保存到文件</h5><p>GNU Parallel可以把每一个任务的输出保存到文件中，临时文件默认保存在 /tmp 中，可以使用 –tmpdir改变（或者修改 $TMPDIR）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --files ::: A B C</span><br><span class="line">/tmp/parfmNTJ.par</span><br><span class="line">/tmp/parmioFz.par</span><br><span class="line">/tmp/pargaTxf.par</span><br><span class="line">$ parallel --tmpdir ~ --files ::: A B C</span><br><span class="line">/home/demo/parLEXH7.par</span><br><span class="line">/home/demo/parXsKsR.par</span><br><span class="line">/home/demo/parZxytI.par</span><br><span class="line">$ TMPDIR=~ parallel --files ::: A B C</span><br><span class="line">/home/demo/par2tX6C.par</span><br><span class="line">/home/demo/parorPJy.par</span><br><span class="line">/home/demo/pari5TkI.par</span><br></pre></td></tr></table></figure>

<p>输出文件可以有结构的保存 <code>--results</code>，输出文件不仅包含标准输出（stdout）也会包含标准错误输出（stderr）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --results outdir <span class="built_in">echo</span> ::: A B C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">$ tree outdir/</span><br><span class="line">outdir/</span><br><span class="line">└── 1</span><br><span class="line">    ├── A</span><br><span class="line">    │   ├── seq</span><br><span class="line">    │   ├── stderr</span><br><span class="line">    │   └── stdout</span><br><span class="line">    ├── B</span><br><span class="line">    │   ├── seq</span><br><span class="line">    │   ├── stderr</span><br><span class="line">    │   └── stdout</span><br><span class="line">    └── C</span><br><span class="line">        ├── seq</span><br><span class="line">        ├── stderr</span><br><span class="line">        └── stdout</span><br><span class="line"></span><br><span class="line">4 directories, 9 files</span><br></pre></td></tr></table></figure>

<h5 id="1-83-控制执行"><a href="#1-83-控制执行" class="headerlink" title="1.83 控制执行"></a>1.83 控制执行</h5><p>使用 –jobs/-j 指定并行任务数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用64个任务执行128个休眠命令</span></span><br><span class="line">$ time parallel -N0 -j64 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m2.759s</span><br><span class="line">user    0m0.657s</span><br><span class="line">sys 0m1.345s</span><br><span class="line"><span class="comment"># 默认情况下并行任务数与cpu核心数相同, 所以这条命令会比每个cpu两个任务的耗时多一倍</span></span><br><span class="line">$ time parallel -N0 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m3.478s</span><br><span class="line">user    0m0.656s</span><br><span class="line">sys 0m1.344s</span><br><span class="line"><span class="comment"># 每个cpu两个任务</span></span><br><span class="line">$ time parallel -N0 --<span class="built_in">jobs</span> 200% sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m2.659s</span><br><span class="line">user    0m0.734s</span><br><span class="line">sys 0m1.423s</span><br><span class="line"><span class="comment"># 使用 --jobs 0 表示执行尽可能多的并行任务</span></span><br><span class="line">$ time parallel -N0 --<span class="built_in">jobs</span> 0 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    0m2.135s</span><br><span class="line">user    0m0.651s</span><br><span class="line">sys 0m1.477s</span><br><span class="line"><span class="comment"># 除了基于cpu使用率之外，也可以基于cpu数</span></span><br><span class="line">$ time parallel --use-cpus-instead-of-cores -N0 sleep 1 ::: &#123;1..128&#125;</span><br><span class="line"></span><br><span class="line">real    1m5.499s</span><br><span class="line">user    0m0.950s</span><br><span class="line">sys 0m1.897s</span><br></pre></td></tr></table></figure>

<h5 id="1-15-耗时"><a href="#1-15-耗时" class="headerlink" title="1.15 耗时"></a>1.15 耗时</h5><p>当job有大量的IO操作时，为避免“惊群效应”，可使用<code>--delay</code>参数指定各个job开始的时间间隔。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --delay 2.5 <span class="built_in">echo</span> Starting &#123;&#125;\;date ::: 1 2 3</span><br><span class="line">Starting 1</span><br><span class="line">Thu Jul  1 10:42:29 CST 2021</span><br><span class="line">Starting 2</span><br><span class="line">Thu Jul  1 10:42:31 CST 2021</span><br><span class="line">Starting 3</span><br><span class="line">Thu Jul  1 10:42:34 CST 2021</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>惊群效应</strong></p>
<p>当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到食物的鸽子只好回去继续睡觉， 等待下一块食物到来。这样，每扔一块食物，都会惊动所有的鸽子，即为惊群。</p>
<p>简单地说：就是扔一块食物，所有鸽子来抢，但最终只一个鸽子抢到了食物。</p>
<p>语义分析：食物只有一块，最终只有一个鸽子抢到，但是惊动了所有鸽子，每个鸽子都跑过来，消耗了每个鸽子的能量。（这个很符合达尔文的进化论，物种之间的竞争，适者生存。）</p>
<p>在多进程/多线程等待同一资源时，也会出现惊群。即当某一资源可用时，多个进程/线程会惊醒，竞争资源。这就是操作系统中的惊群</p>
<p>坏处：</p>
<ol>
<li>惊醒所有进程/线程，导致n-1个进程/线程做了无效的调度，上下文切换，cpu瞬时增高</li>
<li>多个进程/线程争抢资源，所以涉及到同步问题，需对资源进行加锁保护，加解锁加大系统CPU开销</li>
</ol>
</blockquote>
<p>若已知任务超过一定时间未反应则为失败则可以通过<code>--timeout</code>指定等待时间避免无谓的等待。GNU parallel能计算所有任务运行时间的中位数，因此可以指定时间为中位数的倍数关系。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --timeout <span class="number">4.1</span> sleep &#123;&#125;\; echo &#123;&#125; <span class="symbol">:</span><span class="symbol">:</span>: <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">$ parallel --timeout <span class="number">200</span>% sleep &#123;&#125;\; echo &#123;&#125; <span class="symbol">:</span><span class="symbol">:</span>: <span class="number">2.1</span> <span class="number">2.2</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2.3</span></span><br><span class="line"><span class="number">2.1</span></span><br><span class="line"><span class="number">2.2</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="1-16-显示任务进度信息"><a href="#1-16-显示任务进度信息" class="headerlink" title="1.16 显示任务进度信息"></a>1.16 显示任务进度信息</h5><p>略</p>
<h5 id="1-18-资源限制"><a href="#1-18-资源限制" class="headerlink" title="1.18 资源限制"></a>1.18 资源限制</h5><p>GNU parallel能够在开始一个新的任务前检查系统的负载情况防止过载（通过<code>--load</code>可指定负载），同时还能检查系统是否使用了交换空间（swap）（通过<code>--noswap</code>限制使用swap）。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --load <span class="number">100</span>% echo load <span class="keyword">is</span> less than &#123;&#125; job per cpu ::: <span class="number">1</span></span><br><span class="line">load <span class="keyword">is</span> less than <span class="number">1</span> job per cpu</span><br><span class="line">$ parallel --noswap echo the system <span class="keyword">is</span> not swapping ::: now</span><br><span class="line">the system <span class="keyword">is</span> not swapping now</span><br></pre></td></tr></table></figure>

<p>同时，对于某些占用内存较多的程序，parallel会检查内存只有内存满足时才启动任务（通过<code>--memfree</code>指定需要内存大小），而且在启动任务后内存不够50%时会杀掉最新开始的任务，直到这个任务完成再重新开始那些杀死的任务。</p>
<blockquote>
<p>swap space是磁盘上的一块区域，可以是一个分区，也可以是一个文件，或者是他们的组合。简单点说，当系统物理内存吃紧时，Linux会将内存中不常访问的数据保存到swap上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问swap上存储的内容时，再将swap上的数据加载到内存中，这就是我们常说的swap out和swap in。</p>
<p>swap是存放在磁盘上的，磁盘的速度和内存比较起来慢了好几个数量级，如果不停的读写swap，那么对系统的性能肯定有影响，尤其是当系统内存很吃紧的时候，读写swap空间发生的频率会很高，导致系统运行很慢。</p>
<p>并不是swap空间占用多就一定性能下降，真正影响性能是swap in和out的频率，频率越高，对系统的性能影响越大，我们可以通过vmstat命令来查看swap in/out的频率</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36838191/article/details/86539058">https://blog.csdn.net/qq_36838191/article/details/86539058</a></p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --memfree <span class="number">1</span>G echo will run <span class="keyword">if</span> more than <span class="number">1</span> GB <span class="keyword">is</span> ::: free</span><br><span class="line">will run <span class="keyword">if</span> more than <span class="number">1</span> GB <span class="keyword">is</span> free</span><br></pre></td></tr></table></figure>

<p>还可以通过<code>--nice</code>来指定任务的优先级。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ parallel --nice <span class="number">17</span> echo <span class="keyword">this</span> <span class="keyword">is</span> being run <span class="keyword">with</span> nice -n ::: <span class="number">17</span></span><br><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> being run <span class="keyword">with</span> nice -n <span class="number">17</span></span><br></pre></td></tr></table></figure>

<h5 id="1-19-远程操作"><a href="#1-19-远程操作" class="headerlink" title="1.19 远程操作"></a>1.19 远程操作</h5><p>可使用<code>-S host</code>来进行远程登陆：<br> <code>parallel -S username@$SERVER1 echo running on ::: username@$SERVER1</code></p>
<h5 id="1-20-文件传输"><a href="#1-20-文件传输" class="headerlink" title="1.20 文件传输"></a>1.20 文件传输</h5><p>GNU parallel 文件传输使用的是rsync。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> This is input_file &gt; input_file</span><br><span class="line">parallel -S <span class="variable">$SERVER1</span> --transferfile &#123;&#125; cat ::: input_file</span><br></pre></td></tr></table></figure>



<p>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cc54a72616a1">https://www.jianshu.com/p/cc54a72616a1</a></p>
<h4 id="测试举例"><a href="#测试举例" class="headerlink" title="测试举例"></a>测试举例</h4><h5 id="EXAMPLE-Inserting-multiple-arguments"><a href="#EXAMPLE-Inserting-multiple-arguments" class="headerlink" title="EXAMPLE: Inserting multiple arguments"></a>EXAMPLE: Inserting multiple arguments</h5><p>​       When moving a lot of files like this: mv *.log destdir you will sometimes get the error:</p>
<pre><code>     bash: /bin/mv: Argument list too long

   because there are too many files. You can instead do:

     ls | grep -E &#39;\.log$&#39; | parallel mv &#123;&#125; destdir

   This will run mv for each file. It can be done faster if mv gets as many arguments that will fit on the line:

     ls | grep -E &#39;\.log$&#39; | parallel -m mv &#123;&#125; destdir</code></pre>
<h5 id="EXAMPLE-Parallelizing-rsync"><a href="#EXAMPLE-Parallelizing-rsync" class="headerlink" title="EXAMPLE: Parallelizing rsync"></a>EXAMPLE: Parallelizing rsync</h5><p>​       rsync is a great tool, but sometimes it will not fill up the available bandwidth. This is often a problem when copying several big files over high speed<br>​       connections.</p>
<pre><code>   The following will start one rsync per big file in src-dir to dest-dir on the server fooserver:

     cd src-dir; find . -type f -size +100000 | \
       parallel -v ssh fooserver mkdir -p /dest-dir/&#123;//&#125;\; \
         rsync -s -Havessh &#123;&#125; fooserver:/dest-dir/&#123;&#125;
c
   The dirs created may end up with wrong permissions and smaller files are not being transferred. To fix those run rsync a final time:

     rsync -Havessh src-dir/ fooserver:/dest-dir/

   If you are unable to push data, but need to pull them and the files are called digits.png (e.g. 000000.png) you might be able to do:

     seq -w 0 99 | parallel rsync -Havessh fooserver:src-path/*&#123;&#125;.png destdir/</code></pre>
<h5 id="EXAMPLE-Processing-a-big-file-using-more-cores"><a href="#EXAMPLE-Processing-a-big-file-using-more-cores" class="headerlink" title="EXAMPLE: Processing a big file using more cores"></a><strong>EXAMPLE: Processing a big file using more cores</strong></h5><p>​       To process a big file or some output you can use –pipe to split up the data into blocks and pipe the blocks into the processing program.</p>
<pre><code>   If the program is gzip -9 you can do:

     cat bigfile | parallel --pipe --recend &#39;&#39; -k gzip -9 &gt; bigfile.gz

   This will split bigfile into blocks of 1 MB and pass that to gzip -9 in parallel. One gzip will be run per CPU core. The output of gzip -9 will be kept in order and
   saved to bigfile.gz

   gzip works fine if the output is appended, but some processing does not work like that - for example sorting. For this GNU parallel can put the output of each
   command into a file. This will sort a big file in parallel:

     cat bigfile | parallel --pipe --files sort |\
       parallel -Xj1 sort -m &#123;&#125; &#39;;&#39; rm &#123;&#125; &gt;bigfile.sort

   Here bigfile is split into blocks of around 1MB, each block ending in &#39;\n&#39; (which is the default for --recend). Each block is passed to sort and the output from
   sort is saved into files. These files are passed to the second parallel that runs sort -m on the files before it removes the files. The output is saved to
   bigfile.sort.

   GNU parallel&#39;s --pipe maxes out at around 100 MB/s because every byte has to be copied through GNU parallel. But if bigfile is a real (seekable) file GNU parallel
   can by-pass the copying and send the parts directly to the program:

     parallel --pipepart --block 100m -a bigfile --files sort |\
       parallel -Xj1 sort -m &#123;&#125; &#39;;&#39; rm &#123;&#125; &gt;bigfile.sort</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#并行传输文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f | parallel <span class="string">&#x27;mkdir -p /hadoop/&#123;//&#125;; rsync -a &#123;&#125; /hadoop/&#123;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>并行化处理文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F<span class="string">&quot;\t&quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> ~/download/20190916 |iconv -f gb18030 -t utf-8 | parallel --pipe --j 8 --N 1000 python ./models.py  &gt; ./nn.tsv</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>-j 8 : 表示并行jobs的数量, 不想并行执行可以设置为 1. 也可以不加 -j 选项, 则默认为每个CPU核运行一个job.</p>
<p>–pipe: 表示从stdin 读取一块数据, 并将每块数据分给各个jobs</p>
<p>-L N: 一次最多读取N行数据</p>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>&nbsp;&nbsp;从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3</span><br><span class="line"></span><br><span class="line">scp -r www.runoob.com:/home/root/others/ /home/space/music/</span><br></pre></td></tr></table></figure>
<p>原文链接如下</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/?s=scp">https://www.runoob.com/?s=scp</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-scp.html">https://www.runoob.com/linux/linux-comm-scp.html</a></li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#远程下载到本地</span></span><br><span class="line">scp kuangyilun@152.136.25.14:/home/kuangyilun/renren/result-data.csv</span><br><span class="line">/Users/foo/Desktop/workspace/work/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地上传到远程</span></span><br><span class="line">scp /Users/foo/Desktop/workspace/work/data</span><br><span class="line">kuangyilun@152.136.25.14:/home/kuangyilun</span><br></pre></td></tr></table></figure>

<h4 id="scp在命令行中带密码远程下载文件"><a href="#scp在命令行中带密码远程下载文件" class="headerlink" title="scp在命令行中带密码远程下载文件"></a>scp在命令行中带密码远程下载文件</h4><ol>
<li><strong>sshpass安装</strong></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013015301/article/details/89468461">https://blog.csdn.net/u013015301/article/details/89468461</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;nchc.dl.sourceforge.net&#x2F;project&#x2F;sshpass&#x2F;sshpass&#x2F;1.06&#x2F;sshpass-1.06.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>scp 在脚本中使用输入密码的解决方法</strong></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/farces/blog/326860">https://my.oschina.net/farces/blog/326860</a></p>
<h3 id="rsync断点续传"><a href="#rsync断点续传" class="headerlink" title="rsync断点续传"></a>rsync断点续传</h3><p>rsync支持断点传送，可以继续上次未完成的任务。</p>
<p><strong>rsync上传数据：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -rsh=<span class="string">&#x27;ssh -p 22&#x27;</span> -P path_local username@IP:remote_path      <span class="comment">#上传单个文件</span></span><br><span class="line">rsync -rsh=<span class="string">&#x27;ssh -p 22&#x27;</span> -r -P path_local username@IP:remote_path   <span class="comment">#上传文件夹内所有文件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>-rsh=’ssh -p 22’ ssh的连接方式，端口号22。 -P代表支持断点传输和显示进度条。</p>
</li>
<li><p>-P：代表支持断点传输和显示进度条。综合了–partial –progress两个参数<br>–partial</p>
<pre><code>       如果在拷贝文件的过程中，传输被中断，rsync的默认操作是撤消前操作，即从目标机上删除已拷贝的部分文件。
      如果想在下次拷贝时续传文件,不需要重新拷贝所有文件的话,可以使用-partial选项阻止rsync在传输中断时删除已拷贝部分</code></pre>
<p> –progress 显示进度条</p>
</li>
</ul>
</blockquote>
<p><strong>rsync下载数据：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -rsh=&#x27;ssh -p 22&#x27; -P username@IP:remote_path path_local    #下载单个文件</span><br><span class="line">rsync -rsh=&#x27;ssh -p 22&#x27; -r -P username@IP:remote_path path_local  #下载文件夹内所有文件</span><br></pre></td></tr></table></figure>

<p><strong>例如</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rsync -P --rsh=ssh /tmp/test.tar 192.168.1.190:/home/test.tar</span><br><span class="line"><span class="meta">#</span><span class="bash">拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号<span class="string">&quot;:&quot;</span>分隔符时就启动这种工作模式。如：</span></span><br><span class="line">rsync -a /data /backup</span><br><span class="line"><span class="meta">#</span><span class="bash">使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号<span class="string">&quot;:&quot;</span>分隔符时启动该模式。如：</span></span><br><span class="line">rsync -avz *.c foo:src</span><br><span class="line"><span class="meta">#</span><span class="bash">使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号<span class="string">&quot;:&quot;</span>分隔符时启动该模式。如：</span></span><br><span class="line">rsync -avz foo:src/bar /data</span><br><span class="line"><span class="meta">#</span><span class="bash">从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含<span class="string">&quot;::&quot;</span>分隔符时启动该模式。如：</span></span><br><span class="line">rsync -av root@192.168.78.192::www /databack</span><br><span class="line"><span class="meta">#</span><span class="bash">从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含<span class="string">&quot;::&quot;</span>分隔符时启动该模式。如：</span></span><br><span class="line">rsync -av /databack root@192.168.78.192::www</span><br><span class="line"><span class="meta">#</span><span class="bash">列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：</span></span><br><span class="line">rsync -v rsync://192.168.78.192/www</span><br></pre></td></tr></table></figure>

<h4 id="在后台运行-退出shell进程不会退出"><a href="#在后台运行-退出shell进程不会退出" class="headerlink" title="在后台运行,  退出shell进程不会退出"></a>在后台运行,  退出shell进程不会退出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup  &#x2F;tmp&#x2F;test.tar root@192.168.1.190:&#x2F;home&#x2F;test.tar</span><br><span class="line">Ctrl+Z</span><br></pre></td></tr></table></figure>



<h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><ol>
<li>创建一个新的窗口</li>
</ol>
<p>安装完成后，直接敲命令screen就可以启动它。但是这样启动的screen会话没有名字，实践上推荐为每个screen会话取一个名字，方便分辨：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S david</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入screen</li>
</ol>
<p>&nbsp;&nbsp;screen启动后，会创建第一个窗口，并在其中打开一个系统默认的shell，一般都会是bash。所以你敲入命令screen之后，会立刻又返回到命令提示符，仿佛什么也没有发生似的，其实你已经进入Screen的世界了。当然，也可以在screen命令之后加入你喜欢的参数，使之直接打开你指定的程序，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen vi david.txt</span><br></pre></td></tr></table></figure>
<p>screen创建一个执行vi david.txt的单窗口会话，退出vi 将退出该窗口/会话。</p>
<ol start="3">
<li>查看窗口和窗口名称</li>
</ol>
<p>打开多个窗口后，可以使用快捷键C-a w列出当前所有窗口。<br>如果使用文本终端，这个列表会列在屏幕左下角，如果使用X环境下的终端模拟器，这个列表会列在标题栏里。窗口列表的样子一般是这样：</p>
<p>0$ bash 1-$ bash 2*$ bash</p>
<p>这个例子中我开启了三个窗口，其中*号表示当前位于窗口2，-号表示上一次切换窗口时位于窗口1。</p>
<hr/>
screen默认会为窗口命名为编号和窗口中运行程序名的组合，上面的例子中窗口都是默认名字。练习了上面查看窗口的方法，你可能就希望各个窗口可以有不同的名字以方便区分了。可以使用快捷键C-A来为当前窗口重命名，按下快捷键后，screen会允许你为当前窗口输入新的名字，回车确认。

<ol start="4">
<li>会话分离与恢复</li>
</ol>
<p>你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个screen窗口编辑/tmp/david.txt文件：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen vi /tmp/david.txt</span><br></pre></td></tr></table></figure>
<p>之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入C-a d，screen会给出detached提示：</p>
<ol start="5">
<li>暂时中断会话</li>
</ol>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/2020/11/26/18-05-02-c75faa9d75cb4643d8657525e516d96b--Users-foo-Desktop-workspace-BayesGit-document-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-media-image1-407fd3.jpeg" alt="IMG_256">{width=”9.375in”<br>height=”4.260416666666667in”}</p>
<p>半个小时之后回来了，找到该screen会话：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen <span class="literal">-ls</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/2020/11/26/18-08-06-71d9605f41d12dc20061272dffff4f98-workspace-BayesGit-document-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-media-image2-9bb1c9.jpeg" alt="IMG_257">{width=”7.291666666666667in”<br>height=”0.9479166666666666in”}</p>
<ol start="6">
<li>重新连接会话：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen <span class="literal">-r</span> <span class="number">12865</span></span><br></pre></td></tr></table></figure>
<h4 id="常用screen命令"><a href="#常用screen命令" class="headerlink" title="常用screen命令"></a>常用screen命令</h4></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">screen -S yourname           # 新建一个叫yourname的session</span><br><span class="line">screen -ls                   # 列出当前所有的session</span><br><span class="line">screen -r yourname           # 回到yourname这个session</span><br><span class="line">screen -d yourname           # 远程detach某个session    # detach快捷键 ctrl a + d</span><br><span class="line">screen -d -r yourname        # 结束当前session并回到yourname这个session</span><br><span class="line">screen -S yourname -X quit   # 删除叫yourname的session</span><br></pre></td></tr></table></figure>

<p><strong>重名的怎么删，如下图：</strong></p>
<ol>
<li>没有重名的直接可以<code>screen -S session_name -X quit</code></li>
<li>重名的，需要带上id删，<code>screen -S id.session_name -X quit</code></li>
</ol>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangliheng/p/6173530.html">https://www.cnblogs.com/yangliheng/p/6173530.html</a><h3 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h3></li>
</ul>
<p>Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">http://www.ruanyifeng.com/blog/2019/10/tmux.html</a></p>
<h3 id="yum安装指定目录"><a href="#yum安装指定目录" class="headerlink" title="yum安装指定目录"></a>yum安装指定目录</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -c <span class="regexp">/etc/</span>yum.conf --installroot=<span class="regexp">/usr/</span>local --releasever=/  install love</span><br></pre></td></tr></table></figure>

<p>该命令简单解释如下：</p>
<p>-c /etc/yum.conf         表示指定yum配置文件地址</p>
<p>–installroot=/usr/local    表示指定自定义的安装目录</p>
<h3 id="wc-统计行数"><a href="#wc-统计行数" class="headerlink" title="wc 统计行数"></a>wc 统计行数</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wc <span class="literal">-l</span> test1.sh</span><br><span class="line"></span><br><span class="line">lines =`wc <span class="literal">-l</span> <span class="variable">$</span>&#123;bid_origin_file&#125; | awk <span class="operator">-F</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br></pre></td></tr></table></figure>
<h3 id="ImageMagick"><a href="#ImageMagick" class="headerlink" title="ImageMagick"></a>ImageMagick</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/beyang/p/7597819.html">https://www.cnblogs.com/beyang/p/7597819.html</a></p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ImageMagick</span><br></pre></td></tr></table></figure>



<h3 id="crontab定时任务"><a href="#crontab定时任务" class="headerlink" title="crontab定时任务"></a>crontab定时任务</h3><p>crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<p>Linux下的任务调度分为两类，系统任务调度和用户任务调度。</p>
<p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p>
<p>/etc/crontab文件包括下面几行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/crontab</span><br><span class="line"></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line"></span><br><span class="line">MAILTO=HOME=/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> run-parts</span></span><br><span class="line"></span><br><span class="line">51 * * * * root run-parts /etc/cron.hourly</span><br><span class="line"></span><br><span class="line">24 7 * * * root run-parts /etc/cron.daily</span><br><span class="line"></span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly</span><br><span class="line"></span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly</span><br></pre></td></tr></table></figure>


<p>前四行是用来配置crond任务运行的环境变量</p>
<ul>
<li>第一行SHELL变量指定了系统要使用哪个shell，这里是bash，</li>
<li>第二行PATH变量指定了系统执行命令的路径，</li>
<li>第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户，</li>
<li>第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。</li>
</ul>
<p><strong>用户任务调度</strong>：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p>
<p>使用者权限文件：</p>
<ul>
<li><p>/etc/cron.deny</p>
<p>说明：该文件中所列用户不允许使用crontab命令</p>
</li>
<li><p>/etc/cron.allow</p>
<p>该文件中所列用户允许使用crontab命令</p>
</li>
<li><p>/var/spool/cron/</p>
<p>所有用户crontab文件存放的目录,以用户名命名</p>
</li>
</ul>
<p><strong>crontab文件的含义：</strong></p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute hour day month week command</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>minute： 表示分钟，可以是从0到59之间的任何整数。</p>
<p>hour：表示小时，可以是从0到23之间的任何整数。</p>
<p>day：表示日期，可以是从1到31之间的任何整数。</p>
<p>month：表示月份，可以是从1到12之间的任何整数。</p>
<p>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</p>
<p>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/18/10-38-25-9ed0f2c2e2292e28a824d57791052b73-20201218103825-d38026.png" alt="fix-dir/picgo/2020/12/18/10-38-25-9ed0f2c2e2292e28a824d57791052b73-20201218103825-d38026"></p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/intval/p/5763929.html">https://www.cnblogs.com/intval/p/5763929.html</a></p>
<h3 id="crontab命令"><a href="#crontab命令" class="headerlink" title="crontab命令"></a>crontab命令</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ftl1012/p/crontab.html">https://www.cnblogs.com/ftl1012/p/crontab.html</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usage: crontab [-u user] file</span><br><span class="line">    crontab [-u user] [ -e | -l | -r ]</span><br><span class="line">        (default operation is replace, per 1003.2)</span><br><span class="line">    -e   (edit user&#x27;s ``crontab``)</span><br><span class="line">    -l   (list user&#x27;s ``crontab``)</span><br><span class="line">    -r   (delete user&#x27;s ``crontab``)</span><br><span class="line">    -i   (prompt before deleting user&#x27;s ``crontab``)</span><br><span class="line">    -s   (selinux context)</span><br></pre></td></tr></table></figure>

<h3 id="autojump的安装和简单使用-环境-ubuntu14-04"><a href="#autojump的安装和简单使用-环境-ubuntu14-04" class="headerlink" title="autojump的安装和简单使用(环境:ubuntu14.04)"></a>autojump的安装和简单使用(环境:ubuntu14.04)</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010286751/article/details/48899531?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control">https://blog.csdn.net/u010286751/article/details/48899531?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control</a></p>
<h3 id="du-查看占用空间"><a href="#du-查看占用空间" class="headerlink" title="du 查看占用空间"></a>du 查看占用空间</h3><p>常用命令举例：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看某个目录下哪个文件最大\</span></span><br><span class="line">du <span class="literal">-sh</span> \*\|grep G\</span><br><span class="line"><span class="comment">#查看某个目录下文件的大小\</span></span><br><span class="line">du <span class="literal">-ha</span> xxx.csv\</span><br><span class="line"><span class="comment">#查看某个目录下所有文件的大小\</span></span><br><span class="line">du <span class="literal">-ha</span>\</span><br><span class="line"><span class="comment">#查看所有目录使用空间\</span></span><br><span class="line">df <span class="literal">-h</span></span><br><span class="line"><span class="comment">#查看linux目录剩余空间大小\</span></span><br><span class="line"><span class="comment">#df命令是linux系统以磁盘分区为单位查看文件系统，可以加上参数查看磁盘剩余空间信息，命令格式：\</span></span><br><span class="line">df <span class="literal">-hl</span></span><br></pre></td></tr></table></figure>
<p>详细参数：</p>
<p>du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X<br>&lt;文件&gt;][--block-size][--exclude=&lt;目录或文件&gt;][--max-depth=&lt;目录层数&gt;][--help][--version][目录或文件]</p>
<p>参数说明：</p>
<ul>
<li>-a或-all 显示目录中个别文件的大小。</li>
<li>-b或-bytes 显示目录或文件大小时，以byte为单位。</li>
<li>-c或--total<br>除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</li>
<li>-D或--dereference-args 显示指定符号连接的源文件大小。</li>
<li>-h或--human-readable 以K，M，G为单位，提高信息的可读性。</li>
<li>-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。</li>
<li>-k或--kilobytes 以1024 bytes为单位。</li>
<li>-l或--count-links 重复计算硬件连接的文件。</li>
<li>-L&lt;符号连接&gt;或--dereference&lt;符号连接&gt;<br>显示选项中所指定符号连接的源文件大小。</li>
<li>-m或--megabytes 以1MB为单位。</li>
<li>-s或--summarize 仅显示总计。</li>
<li>-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</li>
<li>-x或--one-file-xystem<br>以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</li>
<li>-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。</li>
<li>--exclude=&lt;目录或文件&gt; 略过指定的目录或文件。</li>
<li>--max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。</li>
<li>--help 显示帮助。</li>
<li>--version 显示版本信息。</li>
</ul>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>查看整个磁盘还剩多少空间，可以使用命令 ：<code>df -h</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-29-30-52998d84f183f42a3527e52b3a07034c-20201217092929-8c62e8.png" alt="fix-dir/picgo/2020/12/17/09-29-30-52998d84f183f42a3527e52b3a07034c-20201217092929-8c62e8"></p>
<ol>
<li>如果并不关心磁盘还剩余多少空间，只是需要知道当前的文件夹下的磁盘使用情况，可以使用如下命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du --max-depth&#x3D;1 -h</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-32-11-60c68d68ff6c4d21d31c5870883a5102-20201217093211-51046e.png" alt="fix-dir/picgo/2020/12/17/09-32-11-60c68d68ff6c4d21d31c5870883a5102-20201217093211-51046e"></p>
<ol start="2">
<li>使用 <code>du --max-depth=1 -h </code>命令来查找磁盘的使用情况，默认是当前的路径。</li>
</ol>
<p>-h：为了方便读懂每个文件的大小，如果没有这个参数显示的文件大小就没有k,M,G等。</p>
<p>得到结果中，前面n-1行的是该目录下每个文件夹的大小。最后一行显示的是该目录总的大小。</p>
<ol start="3">
<li>如果并不关心该目录下每个文件的大小，只想知道其中某一个文件（文件夹）的大小，需要使用下面命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-32-57-bc8010be0c642e2c43700273cdf74a91-20201217093257-f77065.png" alt="fix-dir/picgo/2020/12/17/09-32-57-bc8010be0c642e2c43700273cdf74a91-20201217093257-f77065"></p>
<ol start="4">
<li>还有另外一个命令，也可以得到得到同样的效果：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du --max-depth&#x3D;0 -h</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/picgo/2020/12/17/09-33-29-621923843fa32b4724058a3b104407ce-20201217093329-d78398.png" alt="fix-dir/picgo/2020/12/17/09-33-29-621923843fa32b4724058a3b104407ce-20201217093329-d78398"></p>
<p>其实在man手册里面已经告诉了我们：–max-depth=0的功能和-s的功能是一样的。</p>
<h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h3><p><strong>安装</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install htop</span></span><br><span class="line"><span class="meta">#</span><span class="bash">或者</span></span><br><span class="line"><span class="meta">#</span><span class="bash">安装epel源</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install epel-release</span></span><br><span class="line"><span class="meta">#</span><span class="bash">安装htop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install -y htop</span></span><br><span class="line"><span class="meta">#</span><span class="bash">安装完毕后命令行输入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> htop</span></span><br></pre></td></tr></table></figure>

<p><strong>htop最详细解释说明</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34672033/article/details/89735983">https://blog.csdn.net/qq_34672033/article/details/89735983</a></p>
<p>top命令升级版本htop</p>
<ul>
<li>htop的介绍<br><code>htop</code>是Linux系统中的一个互动的进程查看器,与Linux传统的top比较的话,<code>htop</code>更<code>人性化</code>并且还<code>支持鼠标</code>操作!</li>
<li>htop的优势</li>
</ul>
<blockquote>
<p>(1) 在htop中，可以垂直和水平滚动列表，查看所有进程和完整的命令行。<br>(2) 在top中，您按下的每个未分配的键都有延迟(尤其是当多键转义序列意外触发时)。<br>(3) htop启动得更快(top似乎在显示任何东西之前会收集一段时间的数据)。<br>(4) 在htop中，您不需要输入进程号来终止进程，而在top中，您需要这样做。<br>(5) 在htop中，您不需要输入进程编号或优先级值来重新分配进程，而在top中，您需要这样做。<br>(6) 在htop中，您可以同时杀死多个进程。<br>(7) top更老，因此更容易测试。</p>
</blockquote>
<ul>
<li>htop的安装<br><a target="_blank" rel="noopener" href="https://github.com/hishamhm/htop">htop:项目地址</a></li>
</ul>
<blockquote>
<p>可以通过<code>源码包编译</code>安装<br>也可以<code>配置epel源</code>后<code>yum安装</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/25/18-20-14-df805883048ee737db36f968e7a6b5be-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjcyMDMz,size_16,color_FFFFFF,t_70-a30f38.png" alt="Alt text"><br>说明:</p>
<blockquote>
<p>从上面的截图中可以看到,<code>htop</code>命令输出总共分成了五个展示区:<br>(1)CPU状态区域<br>(2)整体状态区域<br>(3)内存状态区域<br>(4)进程状态区域<br>(5)管理控制区域</p>
</blockquote>
<p><strong>htop的众多输出信息的详解</strong></p>
<p>htop通过进度条展示每个CPU逻辑核心的使用百分比,并使用不同的颜色进行区分:</p>
<ul>
<li>CPU usage bar<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/25/18-20-29-ee60be7959b9c315390186b4bc118f7e-20190501103818280-08e5bb.png" alt="Alt text"></li>
</ul>
<blockquote>
<p>该行主要显示CPU使用情况,htop还为将不同颜色来区分是使用情况:<br>(1)蓝色的表示low-prority(低优先级)使用<br>(2)绿色的表示normal(标准)使用情况<br>(3)红色的表示kernel(内核)使用情况<br>(4)青色的表示virtuality(虚拟性)使用情况</p>
</blockquote>
<ul>
<li>Memory bar<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/25/18-20-42-24f501d0727d65466e56c847a09120b1-20190501103825503-dc1494.png" alt="Alt text"></li>
</ul>
<blockquote>
<p>该行主要表示内存使用情况，同样的htop使用了不同颜色来区分是使用情况:<br>(1)绿色的表示已经使用内存情况<br>(2)蓝色的表示用于缓冲的内存使用情况<br>(3)黄色的表示用于缓存的内存使用情况</p>
</blockquote>
<ul>
<li>Swap bar</li>
</ul>
<blockquote>
<p>该行主要显示交换分区使用情况，当你发现你的<code>交换分区(swap)已经派上用场</code>的时候，说明你的物理<strong>内存已经不足</strong>，需要考虑增加内存了。</p>
</blockquote>
<ul>
<li>整体状态区域<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/25/18-21-29-4fcd228dfd97f07bf29f62918b18f6a1-20190501103830388-923e8d.png" alt="Alt text"></li>
</ul>
<blockquote>
<p>(1)Tasks显示进程总数,当前运行的进程数<br>(2)Load average显示的是系统的1分钟,5分钟,10分钟的平均负载情况<br>(3)Uptime显示系统运行了多长时间</p>
</blockquote>
<ul>
<li>进程状态区域</li>
</ul>
<blockquote>
<p>PID：表示进程号,是非零正整数<br>USER：发起该进程的用户名<br>PRI：进程优先级<br>NI：(nice)进程的优先级别数值<br>VIRT：进程占用的虚拟内存<br>RES：进程占用的物理内存<br>SHR：进程使用的共享内存<br>S：进程的运行状况</p>
<blockquote>
<p>(1) R 表示正在运行<br>(2) S 表示休眠<br>(3) Z 表示僵死状态<br>(4) N 表示该进程优先值是负数</p>
</blockquote>
<p>CPU%：进程占用的CPU使用率<br>MEM%：此进程占用的物理内存和总内存的百分比<br>TIME%：启动进程后占用CPU的累计时长<br>Command：进程启动的启动命令名称即路径</p>
</blockquote>
<ul>
<li>管理控制台</li>
</ul>
<blockquote>
<p>F1;查看htop说明<br>F2;htop设定<br>F3;搜索进程<br>F4;进程过滤器<br>F5;显示属性结构<br>F6;折叠或展开(新版本里的),或选择排序方式(旧版本里的)<br>F7; 减少nice值,提高进程优先级<br>F8; 增加nice值,降低进程优先级<br>F9; 可对进程传递信号<br>F10; 退出</p>
</blockquote>
<ul>
<li>F2进入设置界面<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/25/18-21-43-0227adb9f9a128995147b0ea01b3bea6-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjcyMDMz,size_16,color_FFFFFF,t_70-20201225182143301-034e61.png" alt="Alt text"><br>针对每项进行设置可以切换输出的形式</li>
</ul>
<ol>
<li>切换主题颜色<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/25/18-21-56-818a3ef5258c2aba303e19e97dec0696-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjcyMDMz,size_16,color_FFFFFF,t_70-20201225182156523-3ff21e.png" alt="Alt text"></li>
<li>显示选项<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/25/18-22-05-c958d9da683b95b412f84f46994d21c1-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjcyMDMz,size_16,color_FFFFFF,t_70-20201225182205946-5a6554.png" alt="Alt text"></li>
<li>为了更能清楚确认进程和线程的关系<br>按F2进入打开colimns设定<br><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/abnerworks.Typora/2020/12/25/18-22-17-c6555646216fb3845e3e9cebcb7943b3-watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjcyMDMz,size_16,color_FFFFFF,t_70-20201225182217399-a79c32.png" alt="Alt text"><br>找到<code>TGID</code>后,<br>按<code>F5</code>安装<br>卸载是<code>F9</code><br>保存<code>F10</code></li>
</ol>
<ul>
<li>F3是搜索进程</li>
</ul>
<blockquote>
<p>不区分大小写,可输入进程名搜索,</p>
</blockquote>
<ul>
<li>F4 是类似于过滤的功能</li>
</ul>
<blockquote>
<p>输入的筛选条件会一直保存,可以按<code>ESC</code>键清除!</p>
</blockquote>
<p><strong>htop使用详解</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/programmer-tlh/p/11726016.html">https://www.cnblogs.com/programmer-tlh/p/11726016.html</a></p>
<h3 id="history-查看历史命令"><a href="#history-查看历史命令" class="headerlink" title="history 查看历史命令"></a>history 查看历史命令</h3><h3 id="coscmd文档v1-8-3-0"><a href="#coscmd文档v1-8-3-0" class="headerlink" title="coscmd文档v1.8.3.0"></a>coscmd文档v1.8.3.0</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/35906f1b854b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">https://www.jianshu.com/p/35906f1b854b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>
<h3 id="usr-bin-expect"><a href="#usr-bin-expect" class="headerlink" title="/usr/bin/expect"></a>/usr/bin/expect</h3><p>项目中遇到/usr/bin/expect 使用：login.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># expect超过超时时间没有监测到要找的字符串，则不执行</span></span><br><span class="line"><span class="built_in">set</span> timeout 30</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取传入的三个参数</span></span><br><span class="line"><span class="built_in">set</span> host [lindex <span class="variable">$argv</span> 0]</span><br><span class="line"><span class="built_in">set</span> code [lindex <span class="variable">$argv</span> 1]</span><br><span class="line"><span class="built_in">set</span> passwd [lindex <span class="variable">$argv</span> 2]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 运行ssh连接命令</span></span><br><span class="line">spawn ssh <span class="variable">$host</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 自动输入验证码&amp;密码</span></span><br><span class="line">expect &#123;</span><br><span class="line">  <span class="string">&quot;Verification code:&quot;</span> &#123; send <span class="string">&quot;<span class="variable">$code</span>\n&quot;</span>; exp_continue&#125;</span><br><span class="line">  <span class="string">&quot;Password:&quot;</span> &#123; send <span class="string">&quot;<span class="variable">$passwd</span>\n&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 退出expect返回终端，可以继续输入，否则将一直在expect不能退出到终端</span></span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>执行脚本<code>./ssh.exp host code passwd</code></p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><ul>
<li>spawn : expect脚本中用于向机器发出首个linux命令用，该命令将在系统中创建一个进程</li>
<li>expect : expect脚本中用于等待和分析机器执行结果用</li>
<li>send : expect脚本中用于模仿“人”向机器进程发出linux命令用</li>
<li>interact : expect脚本中用于将交互双方由expect脚本和机器内核改为——&gt;字符终端和机器内核（即为正常人和机器交互的模式）</li>
</ul>
<h5 id="sh脚本调用expect"><a href="#sh脚本调用expect" class="headerlink" title="sh脚本调用expect"></a>sh脚本调用expect</h5><p>   expect只能用来代替人向终端输入指令。有时候在此之前还需要运行一些shell脚本的命令。所有就需要使用sh脚本来调用expect。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 登录信息</span></span><br><span class="line">host=<span class="string">&quot;这里是主机地址&quot;</span></span><br><span class="line">passwd=<span class="string">&quot;这里是密码&quot;</span></span><br><span class="line">secret=<span class="string">&quot;这个是用来计算code的加密串，无视它&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获得动态码</span></span><br><span class="line">code=`这里是计算code的命令，继续无视它`</span><br><span class="line"> </span><br><span class="line"><span class="comment"># expect调用login脚本</span></span><br><span class="line">expect login.sh <span class="variable">$host</span> <span class="variable">$code</span> <span class="variable">$passwd</span></span><br></pre></td></tr></table></figure>

<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>-r 就是向下递归，不管有多少级目录，一并删除<br>-f 就是直接强行删除，不作任何提示的意思</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除文件夹实例：</span></span><br><span class="line"><span class="built_in">rm</span> <span class="literal">-rf</span> /var/log/httpd/access</span><br><span class="line"><span class="comment">#将会删除/var/log/httpd/access目录以及其下所有文件、文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除文件使用实例：</span></span><br><span class="line"><span class="built_in">rm</span> <span class="operator">-f</span> /var/log/httpd/access.log</span><br><span class="line"><span class="comment">#将会强制删除/var/log/httpd/access.log这个文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="save-rm"><a href="#save-rm" class="headerlink" title="save-rm"></a>save-rm</h3><p><code>safe-rm</code> 是一个开源软件工具，这名字听起来就很安全嘛，所以它是用来替代不太安全的 <code>rm</code>。</p>
<p>它可以在 <code>/etc/safe-rm.conf</code> 中配置路径黑名单，定义哪些不能被 <code>safe-rm</code> 删除。</p>
<p>我们可以将 <code>safe-rm</code> 更名为 <code>rm</code>，假设定义了 <code>/etc/</code> 无能被删除，那么删除 <code>/etc</code>时就会报错：</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#mac</span><br><span class="line">brew install save-rm </span><br></pre></td></tr></table></figure>

<p>Linux</p>
<p>原文<a target="_blank" rel="noopener" href="https://www.techgrow.cn/posts/8ac517c2.html">https://www.techgrow.cn/posts/8ac517c2.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 下载文件</span><br><span class="line"># wget https:&#x2F;&#x2F;launchpadlibrarian.net&#x2F;188958703&#x2F;safe-rm-0.12.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压文件</span><br><span class="line"># tar -xvf safe-rm-0.12.tar.gz</span><br><span class="line"></span><br><span class="line"># 拷贝可执行文件</span><br><span class="line"># cd safe-rm</span><br><span class="line"># cp safe-rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line"># 建立软链接</span><br><span class="line"># ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;safe-rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;rm</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>配置 PATH 环境变量（按需配置）</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 确保PATH环境变量中，存在&#x2F;usr&#x2F;local&#x2F;bin路径，且&#x2F;usr&#x2F;local&#x2F;bin路径排在&#x2F;usr&#x2F;bin路径前面</span><br><span class="line"># 一些脚本中使用完全路径&#x2F;bin&#x2F;rm或者&#x2F;usr&#x2F;bin&#x2F;rm则不会受safe-rm影响</span><br><span class="line"># echo $PATH</span><br><span class="line">.. &#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;bin ...</span><br><span class="line"></span><br><span class="line"># 如果PATH环境变量不符合上面说的要求，则手动配置PATH环境变量</span><br><span class="line"># vim &#x2F;etc&#x2F;profile</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line"># 如果修改了PATH环境变量，执行命令使修改生效</span><br><span class="line"># source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>创建 safe-rm 配置文件，添加保护名单</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 默认的safe-rm配置文件有以下两个，需要自行创建</span><br><span class="line">全局配置：&#x2F;etc&#x2F;safe-rm.conf</span><br><span class="line">用户配置：~&#x2F;.safe-rm</span><br><span class="line"></span><br><span class="line"># 创建全局配置文件</span><br><span class="line"># touch &#x2F;etc&#x2F;safe-rm.conf</span><br><span class="line"></span><br><span class="line"># 添加保护名单</span><br><span class="line"># vim &#x2F;etc&#x2F;safe-rm.conf</span><br><span class="line">&#x2F;</span><br><span class="line">&#x2F;bin</span><br><span class="line">&#x2F;boot</span><br><span class="line">&#x2F;dev</span><br><span class="line">&#x2F;etc</span><br><span class="line">&#x2F;home</span><br><span class="line">&#x2F;initrd</span><br><span class="line">&#x2F;lib</span><br><span class="line">&#x2F;lib32</span><br><span class="line">&#x2F;lib64</span><br><span class="line">&#x2F;proc</span><br><span class="line">&#x2F;root</span><br><span class="line">&#x2F;sbin</span><br><span class="line">&#x2F;sys</span><br><span class="line">&#x2F;usr</span><br><span class="line">&#x2F;usr&#x2F;bin</span><br><span class="line">&#x2F;usr&#x2F;include</span><br><span class="line">&#x2F;usr&#x2F;lib</span><br><span class="line">&#x2F;usr&#x2F;local</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;include</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;sbin</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;share</span><br><span class="line">&#x2F;usr&#x2F;sbin</span><br><span class="line">&#x2F;usr&#x2F;share</span><br><span class="line">&#x2F;usr&#x2F;src</span><br><span class="line">&#x2F;var</span><br><span class="line">&#x2F;etc&#x2F;safe-rm.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>测试 save-rm 是否生效</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建测试文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> touch /home/test.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 追加需要保护的文件路径到配置文件中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/safe-rm.conf</span></span><br><span class="line">/home/test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试删除受保护的文件路径，如果输出skipping日志代表safe-rm生效</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rm /home/test.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rm -rf /home/test.txt</span></span><br><span class="line">safe-rm: skipping /home/test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置文件里面的/etc只能保证执行<span class="string">&quot;rm -rf /etc&quot;</span>命令的时候不能删除，但是如果执行<span class="string">&quot;rm -rf /etc/app&quot;</span>，还是可以删除app文件的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果想保证某个目录下面的所有文件都不被删除，则配置文件里可以写成/etc/*，但使用通配符的方式无法避免/etc目录下链接文件被删除</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如/lib或/lib64这种目录，下面会有很多库文件对应的链接文件，使用safe-rm并不能保护链接文件被删除</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议将/etc/safe-rm.conf加入到保护名单中，防止/etc/safe-rm.conf被删后配置失效</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用系统默认的删除命令</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用系统默认的删除命令，此时safe-rm的保护作用将失效</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/bin/rm -rf /etc/app</span></span><br></pre></td></tr></table></figure>

<h3 id="source、sh、bash、-执行脚本的区别"><a href="#source、sh、bash、-执行脚本的区别" class="headerlink" title="source、sh、bash、./执行脚本的区别"></a>source、sh、bash、./执行脚本的区别</h3><p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/128918.htm">https://www.jb51.net/article/128918.htm</a></p>
<h3 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(cd \&#96;dirname \$0\&#96;;pwd)</span><br></pre></td></tr></table></figure>
<p>在命令行状态下单纯执行 $ cd `dirname $0`<br>是毫无意义的。因为他返回当前路径的&quot;.&quot;。</p>
<p>这个命令写在脚本文件里才有作用，他返回这个脚本文件放置的目录，并可以根据这个目录来定位所要运行程序的相对位置（绝对位置除外）。</p>
<p>以上命令 $(dirname &quot;$0&quot;)<br>将返回该文件当前的上一层路径，通过cd到该路径，通过pwd获得当前路径</p>
<blockquote>
<p>另一个写法是：cd `dirname $0` 其中反引号··等同于$()。</p>
</blockquote>
<h3 id="！-n］和［！-d］"><a href="#！-n］和［！-d］" class="headerlink" title="[ ！-n］和［！-d］"></a>[ ！-n］和［！-d］</h3><ul>
<li>! 一般在shell脚本中表示取反</li>
<li>[] 这个叫条件表达式 简易版的if\</li>
<li>n 用于判断变量是否为空,注意只要有一个符号就不为空,空格也不行\</li>
<li>d directory意思 用于判断目录是否存在</li>
<li>[ ! -n ] [ ! -d ] 的意思你应该懂了<br>[ ! -n ] 判断变量如果不为空则条件成立<br>[ ! -d ] 判断变量如果不是目录则条件成立</li>
</ul>
<p>Eg:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ! -d \<span class="variable">$&#123;split_tmp_path&#125;</span> ];<span class="keyword">then</span></span><br><span class="line">  mkdir -p \<span class="variable">$&#123;split_tmp_path&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><p>测试：文件是否存在，文件属性，访问权限等</p>
<table>
<thead>
<tr>
<th><strong>[</strong> <strong>-f</strong> <strong>fname</strong> <strong>]</strong></th>
<th><strong>fname</strong> 存在且是普通文件时，返回真 ( 即返回 <strong>0</strong> )</th>
</tr>
</thead>
<tbody><tr>
<td><strong>[</strong> <strong>-L</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong> 存在且是链接文件时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-d</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong> 存在且是一个目录时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-e</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong>（文件或目录）存在时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-s</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong> 存在且大小大于 <strong>0</strong> 时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-r</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong>（文件或目录）存在且可读时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-w</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong>（文件或目录）存在且可写时，返回真</td>
</tr>
<tr>
<td><strong>[</strong> <strong>-x</strong> <strong>fname</strong> <strong>]</strong></td>
<td><strong>fname</strong>（文件或目录）存在且可执行时，返回真</td>
</tr>
</tbody></table>
<h3 id="参数用法"><a href="#参数用法" class="headerlink" title="$参数用法"></a>$参数用法</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>当前脚本的文件名（间接运行时还包括绝对路径）</td>
</tr>
<tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数</td>
</tr>
<tr>
<td>$@</td>
<td><code>$*</code>和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号 (“”) 包含时，都以”<code>$1</code>“ “<code>$2</code>“ … “<code>$n</code>“ 的形式输出所有参数。但是当它们被双引号 (“”) 包含时，”<code>\$*</code>“会将所有的参数作为一个整体，以<code>&quot;$1 $2 … $n&quot;</code>的形式输出所有参数；”<code>$@</code>“会将各个参数分开，以<code>&quot;$1&quot;&quot;$2&quot; … &quot;$n&quot;</code>的形式输出所有参数。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值</td>
</tr>
<tr>
<td>$$</td>
<td>当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID</td>
</tr>
<tr>
<td>$_</td>
<td>上一个命令的最后一个参数</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的 ID 号</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span>    <span class="comment"># 当前脚本的文件名（间接运行时还包括绝对路径）。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$n</span>    <span class="comment"># 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1 。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span>    <span class="comment"># 传递给脚本或函数的参数个数。</span></span><br><span class="line"><span class="built_in">echo</span> $*    <span class="comment"># 传递给脚本或函数的所有参数。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span>    <span class="comment"># 传递给脚本或函数的所有参数。被双引号 (&quot; &quot;) 包含时，与 $* 不同，下面将会讲到。</span></span><br><span class="line"><span class="built_in">echo</span> $?    <span class="comment"># 上个命令的退出状态，或函数的返回值。</span></span><br><span class="line"><span class="built_in">echo</span> $$    <span class="comment"># 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$_</span>    <span class="comment"># 上一个命令的最后一个参数</span></span><br><span class="line"><span class="built_in">echo</span> $!    <span class="comment"># 后台运行的最后一个进程的 ID 号</span></span><br></pre></td></tr></table></figure>


<p>详见链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4db526ff6560">https://www.jianshu.com/p/4db526ff6560</a></p>
<h3 id="amp-和wait并行"><a href="#amp-和wait并行" class="headerlink" title="&amp;和wait并行"></a>&amp;和wait并行</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>我们知道shell中的命令都是串行执行的，如果想要充分利用服务器的资源，就需要些小技巧了。</p>
<p>假定业务上多个业务逻辑没有先后关系，每个脚本的执行时间也很长<br>，推荐并行执行。</p>
<p>一般情况下,我们会把每个业务逻辑写到一个单独的脚本里，在服务器上逐一调用，每次都要手工去敲命令。</p>
<p>如果我们把这些脚本放到一个调用脚本里呢？<br>执行的时候去调用这个调用脚本，事实上linux会根据脚本中的顺序<br>串行去调用这些脚本，还不如自己在服务器上一个个的执行快呢，最起码手工逐个调用脚本还是并行的。</p>
<p><strong>在每个进程中使用&amp;符号进行让脚本在后台运行，无需等待当前进程结束。</strong></p>
<p><strong>为了确保每个进程都执行完成，最后务必使用wait关键字，用来确保每一个子进程都执行完成。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前目录下执行如下脚本 相对路径</span></span><br><span class="line"></span><br><span class="line">./1.sh &amp; <span class="comment">#!相当于启动子进程</span></span><br><span class="line"></span><br><span class="line">./2.sh &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span> <span class="comment">#相当于join操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;继续执行剩下的逻辑...&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort：将文件进行排序并输出</p>
<p>补充说明:</p>
<blockquote>
<p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。</p>
</blockquote>
<h4 id="语法：sort-选项-参数"><a href="#语法：sort-选项-参数" class="headerlink" title="语法：sort(选项)(参数)"></a>语法：sort(选项)(参数)</h4><ol>
<li><strong>选项：</strong></li>
</ol>
<ul>
<li><p>-b：忽略每行前面开始出的空格字符；</p>
</li>
<li><p>-c：检查文件是否已经按照顺序排序；</p>
</li>
<li><p>-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符；</p>
</li>
<li><p>-f：排序时，将小写字母视为大写字母；</p>
</li>
<li><p>-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</p>
</li>
<li><p>-m：将几个排序号的文件进行合并；</p>
</li>
<li><p>-M：将前面3个字母依照月份的缩写进行排序；</p>
</li>
<li><p>-n：依照数值的大小排序；</p>
</li>
<li><p>-o&lt;输出文件&gt;：将排序后的结果存入制定的文件；</p>
</li>
<li><p>-r：以相反的顺序来排序；</p>
</li>
<li><p>-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符；</p>
</li>
<li><p>+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</p>
</li>
</ul>
<ol start="2">
<li><strong>参数：</strong><br>文件：指定待排序的文件列表。</li>
</ol>
<p>sort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -t &quot;,&quot; -k 6n #按“,”分割，按第6列数值排序</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.linuxidc.com/linux/2018-12/155765.htm">https://www.linuxidc.com/linux/2018-12/155765.htm</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">man sort</span><br><span class="line"></span><br><span class="line">     -S, --buffer-size&#x3D;SIZE</span><br><span class="line">              use SIZE for main memory buffer</span><br><span class="line">     --radixsort</span><br><span class="line">             Try to use radix sort, if the sort specifications allow.  The radix sort can</span><br><span class="line">             only be used for trivial locales (C and POSIX), and it cannot be used for</span><br><span class="line">             numeric or month sort.  Radix sort is very fast and stable.</span><br><span class="line"></span><br><span class="line">     --mergesort</span><br><span class="line">             Use mergesort.  This is a universal algorithm that can always be used, but it</span><br><span class="line">             is not always the fastest.</span><br><span class="line"></span><br><span class="line">     --qsort</span><br><span class="line">             Try to use quick sort, if the sort specifications allow.  This sort algorithm</span><br><span class="line">             cannot be used with -u and -s.</span><br><span class="line"></span><br><span class="line">     --heapsort</span><br><span class="line">             Try to use heap sort, if the sort specifications allow.  This sort algorithm</span><br><span class="line">             cannot be used with -u and -s.</span><br><span class="line"></span><br><span class="line">     --mmap  Try to use file memory mapping system call.  It may increase speed in some</span><br><span class="line">             cases.</span><br></pre></td></tr></table></figure>



<h3 id="uniq-注意"><a href="#uniq-注意" class="headerlink" title="uniq 注意"></a>uniq 注意</h3><p>使用shell统计多行文本中非重复行数<br>sort命令可以对文本的内容进行排序<br>uniq命令可以对文本内容连续的内容进行去重，<strong>非连续的重复内容无法去重</strong></p>
<p>sort 文件 | uniq 可以达到去除所有重复数据的目的（因为先排序了，这样相同的内容一定在连续的一片，再uniq）</p>
<p>sort 文件 |uniq  等价于   sort -u 文件<br>所以最终的命令可以是：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> <span class="literal">-u</span> 文本 | wc <span class="literal">-l</span></span><br></pre></td></tr></table></figure>
<h3 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a>iconv</h3><p>由于UTF-8编码同时支持中文、还是日文、韩文、阿拉伯文在类的各种语言，所以它在Mac中被广泛使用，而目前Mac上的Excel在导入CSV文件时虽然给出了UTF8的选项，但是导入以后的中文还是乱码，这是因为它实际上是不支持UTF8编码方式导致的，至少对于Excel 2011 for Mac是这样。</p>
<p>那么怎么解决这个问题呢，方法很简单：<strong>将文件的编码方式由UTF8转为Excel支持的中文编码方式</strong>，Mac上的iconv工具专门就可以用来干这个事情。例如，在Excel给出的中文编码方式中有GB18030，那么我们可以通过Mac上的iconv工具将文件编码由UTF8转为GB18030。只需要在命令行中键入如下的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f UTF8 -t GB18030 源文件.csv &gt;新文件.csv</span><br></pre></td></tr></table></figure>



<h3 id="文件并、交、差"><a href="#文件并、交、差" class="headerlink" title="文件并、交、差"></a>文件并、交、差</h3><p><strong>方法一</strong>（直接用文件名）：取两个文本文件的并集、交集、差集</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">并</span></span><br><span class="line">sort -m &lt;(sort file1 | uniq) &lt;(sort file2 | uniq) | uniq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">交</span></span><br><span class="line">sort -m &lt;(sort file1 | uniq) &lt;(sort file2 | uniq) | uniq -d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">差 file1 - file2:</span></span><br><span class="line">sort -m &lt;(sort file1 | uniq) &lt;(sort file2 | uniq) &lt;(sort file2 | uniq) | uniq -u</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>（用变量参数）：取两个文本文件的并集、交集、差集</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file1=XXXX</span><br><span class="line">file2=YYYY</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并:</span></span><br><span class="line">sort -m &lt;(sort $file1 | uniq) &lt;(sort $file2 | uniq) | uniq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 交:</span></span><br><span class="line">sort -m &lt;(sort $file1 | uniq) &lt;(sort $file2 | uniq) | uniq -d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 差 file1 - file2:</span></span><br><span class="line">sort -m &lt;(sort $file1 | uniq) &lt;(sort $file2 | uniq) &lt;(sort $file2 | uniq) | uniq -u</span><br></pre></td></tr></table></figure>

<p><strong>方法三：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file1=XXXX</span><br><span class="line">file2=YYYY</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并:</span></span><br><span class="line">cat $file1 $file2 | sort | uniq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 交:</span></span><br><span class="line">cat $file1 $file2 | sort | uniq -d</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li><p>uniq -d 会输出重复行</p>
</li>
<li><p>uniq -u 只显示唯一的行</p>
</li>
</ul>
<p>grep命令</p>
<p>grep命令是常用来搜索文本内容的，根据输入的pattern，输出命中的内容。可以利用它的文件输入pattern特性，来求两个文件的交集。</p>
<p>那差集可以利用-v这个参数，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep -F -v -f a.file b.file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> grep -F -v -f b.file a.file</span></span><br><span class="line">其中第一个命令求B-A，第二个命令求A-B</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1）grep求交集不要求输入文件是排序的，但最好是唯一的</p>
<p>2）差集时注意输入文件的顺序</p>
<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>Linux split命令用于将一个文件分割成数个。</p>
<p>该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split [--help][--version][-&lt;行数&gt;][-b &lt;字节&gt;][-C&lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li><p>-&lt;行数&gt; : 指定每多少行切成一个小文件</p>
</li>
<li><p>-b&lt;字节&gt; : 指定每多少字节切成一个小文件</p>
</li>
<li><p>–help : 在线帮助</p>
</li>
<li><p>–version : 显示版本信息</p>
</li>
<li><p>-C&lt;字节&gt; : 与参数”-b”相似，但是在切 割时将尽量维持每行的完整性</p>
</li>
<li><p>[输出文件名] : 设置切割后文件的前置文件名，<br>split会自动在前置文件名后再加上编号</p>
</li>
</ul>
<p><strong>举个例子</strong><br>将文件message,按照10k分割  前缀是pg  后缀是三位置有效数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -b 10k -d -a 3   messages pg   </span><br></pre></td></tr></table></figure>
<p> -b 后面跟大小 可以是m k 或者是g </p>
<p>-d 表示文件后缀为数字类型</p>
<p>-a 3 表示文件后缀的数字类型是三位有效数字</p>
<p>message 是源文件名称</p>
<p>pg 是生成分割后的文件的前缀</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-03-03-19d8a54e9da736c90acaaebee8f688ca-image3-57d037.png">{width=”5.186111111111111in”<br>height=”3.7368055555555557in”}</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-03-16-9f52dd0a72b02beba2956f86c969d28d-image4-1ef15b.png">{width=”5.405555555555556in”<br>height=”2.9180555555555556in”}</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-03-31-6f66d8b0fb4adb680790691bc38f933b-image5-d93179.png">{width=”5.871527777777778in”<br>height=”2.8465277777777778in”}</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/19/13-02-44-c04e9d495ebf2d4668822b6e400c0db7-image6-ed0f28.png">{width=”6.014583333333333in”<br>height=”4.415972222222222in”}</p>
<h4 id="获取ip地址"><a href="#获取ip地址" class="headerlink" title="获取ip地址"></a>获取ip地址</h4><h5 id="方法一：ifconfig-a"><a href="#方法一：ifconfig-a" class="headerlink" title="方法一：ifconfig -a"></a>方法一：ifconfig -a</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|tr -d <span class="string">&quot;addr:&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>命令解释</strong></p>
<ol>
<li>ifconfig -a 　　　　 和window下执行此命令一样道理，返回本机所有ip信息</li>
<li>grep inet          截取包含ip的行</li>
<li>grep -v 127.0.0.1   去掉本地指向的那行</li>
<li>grep -v inet6       去掉包含inet6的行</li>
<li>awk { print $2}    <code> $2</code> 表示默认以空格分割的第二组 同理 $1表示第一组</li>
<li>tr -d “addr: “       删除”addr:”这个字符串</li>
</ol>
<p>其他方法参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/poloyy/p/12212868.html">https://www.cnblogs.com/poloyy/p/12212868.html</a></li>
</ul>
<h3 id="关于2-gt-amp-1的含义"><a href="#关于2-gt-amp-1的含义" class="headerlink" title="关于2&gt;&amp;1的含义"></a>关于2&gt;&amp;1的含义</h3><ol>
<li><p>含义：<strong>将标准错误输出重定向到标准输出</strong></p>
</li>
<li><p><strong>符号&gt;&amp;是一个整体</strong>，不可分开，分开后就不是上述含义了。<br>比如有些人可能会这么想：2是标准错误输入，1是标准输出，&gt;是重定向符号，那么&quot;将标准错误输出重定向到标准输出&quot;是不是就应该写成&quot;2&gt;1&quot;就行了？是这样吗？\</p>
<blockquote>
<p>如果是尝试过，你就知道<strong>2&gt;1的写法其实是将标准错误输出重定向到名为&quot;1&quot;的文件里去了</strong></p>
</blockquote>
</li>
<li><p>写成<strong>2&amp;&gt;1</strong>也是不可以的</p>
</li>
</ol>
<p><strong>为什么2&gt;&amp;1要放在后面</strong></p>
<p>考虑如下一条shell命令</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java <span class="literal">-jar</span> app.jar \&gt;log <span class="number">2</span>\&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一个&amp;表示把条命令放到后台执行</p>
</blockquote>
<p>为什么2&gt;&amp;1一定要写到&gt;log后面，才表示标准错误输出和标准输出都定向到log中？<br>我们<strong>不妨把1和2都理解是一个指针</strong>,然后来看上面的语句就是这样的：</p>
<ol>
<li><p>本来1-----&gt;屏幕 （1指向屏幕）</p>
</li>
<li><p>执行&gt;log后， 1-----&gt;log (1指向log)</p>
</li>
<li><p>执行2&gt;&amp;1后， 2-----&gt;1 (2指向1，而1指向log,因此2也指向了log)</p>
</li>
</ol>
<p>原文链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaominpro/article/details/82630528">https://blog.csdn.net/zhaominpro/article/details/82630528</a><blockquote>
<p>关于输入/输出重定向本文就不细说了，不懂的可以参考<a target="_blank" rel="noopener" href="http://www.runoob.com/linux/linux-shell-io-redirections.html">这里</a>，主要是要了解&gt;&lt; &lt;&lt; &gt;&gt; &lt;&amp; &gt;&amp; 这6个符号的使用</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3></li>
</ul>
<p>Bash 2.x 以上支持一维数组，下标从 0 开始。</p>
<p>使用 declare 声明或直接给变量名加下标来赋值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a variable</span><br><span class="line">variable=(item1 item2 item2 ... )</span><br><span class="line"></span><br><span class="line">variable=(item1 item2 item2 ... )</span><br><span class="line">variable[n]=value</span><br></pre></td></tr></table></figure>

<p>数组的引用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;variable[n]&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>举例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a stu</span><br><span class="line">stu=(math1101 math1102 math1103)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;stu[0]&#125;</span>  <span class="comment"># 列出stu的第一个元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;stu[*]&#125;</span>  <span class="comment"># 列出stu的所有元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#stu[*]&#125;</span> <span class="comment"># 给出数组stu中元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数组与数组元素的删除</span></span><br><span class="line"><span class="built_in">unset</span> stu[1]   <span class="comment"># 删除stu的第二个元素</span></span><br><span class="line"><span class="built_in">unset</span> stu      <span class="comment"># 删除整个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数组赋值时无须按顺序赋值</span></span><br><span class="line">x[3]=100; <span class="built_in">echo</span> <span class="variable">$&#123;x[*]&#125;</span></span><br><span class="line">state=(ME [3]=CA [2]=NT); <span class="built_in">echo</span> <span class="variable">$&#123;state[*]&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h4><p>内置命令 declare 可用来声明变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare [选项] variable[&#x3D;value]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>-r</strong></td>
<td><strong>将变量设为只读 (</strong> <strong>readonly</strong> <strong>)</strong></td>
</tr>
<tr>
<td><strong>-x</strong></td>
<td><strong>将变量输出到子</strong> <strong>shell</strong> <strong>中（**</strong>export** <strong>为全局变量）</strong></td>
</tr>
<tr>
<td><strong>-i</strong></td>
<td><strong>将变量设为整型 (</strong> <strong>integer</strong> <strong>)</strong></td>
</tr>
<tr>
<td><strong>-a</strong></td>
<td><strong>将变量设置为一个数组 (</strong> <strong>array</strong> <strong>)</strong></td>
</tr>
<tr>
<td><strong>-f</strong></td>
<td><strong>列出函数的名字和定义 (</strong> <strong>function</strong> <strong>)</strong></td>
</tr>
<tr>
<td><strong>-F</strong></td>
<td><strong>只列出函数名</strong></td>
</tr>
</tbody></table>
<p><strong>附</strong></p>
<p><strong>Shell数组添加元素注意事项</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/asty9000/article/details/87103111">https://blog.csdn.net/asty9000/article/details/87103111</a></p>
<table>
<thead>
<tr>
<th>添加方式</th>
<th>语法</th>
<th>可添加多个元素</th>
<th>下标必须连续</th>
<th>添加后下标改变</th>
<th>可能覆盖原有元素</th>
</tr>
</thead>
<tbody><tr>
<td>直接下标添加</td>
<td>array_name[index]=value</td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
<td><strong><em>否</em></strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td>数组长度添加</td>
<td><code>array_name[$&#123;#array_name[@]&#125;]=value或array_name[$&#123;#array_name[*]&#125;]=value</code></td>
<td><strong>否</strong></td>
<td><strong>是</strong></td>
<td><strong>否</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td>重新创建数组</td>
<td>array_name=(“${array_name[@]}” value1 … valueN)</td>
<td><strong>是</strong></td>
<td><strong>否</strong></td>
<td><strong>是</strong></td>
<td><strong>否</strong></td>
</tr>
<tr>
<td>赋值运算符+=</td>
<td>array_name+=(value1 … valueN)</td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
<td><strong>否</strong></td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="SSH免密登录配置-amp-解决配置成功后不生效问题"><a href="#SSH免密登录配置-amp-解决配置成功后不生效问题" class="headerlink" title="SSH免密登录配置 &amp; 解决配置成功后不生效问题"></a>SSH免密登录配置 &amp; 解决配置成功后不生效问题</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/donaldsy/article/details/100142401">https://blog.csdn.net/donaldsy/article/details/100142401</a></p>
<ol>
<li><p>A机器上，终端中打开 ~/.ssh文件夹，如果不存在就创建该文件</p>
</li>
<li><p>使用ssh-keygen命令生成公钥和私钥。</p>
<ol>
<li><p>默认使用id_rsa文件，如果已经存在该文件，可以键入其他文件</p>
</li>
<li><p>也可以直接使用ssh-keygen -f filename 命令指定文件</p>
</li>
</ol>
</li>
<li><p>使用 ssh-copy-id -i filename.pub user@IP 把公钥文件拷贝到server服务器，如ssh-copy-id -i rsa_work.pub <a href="mailto:&#114;&#x6f;&#x6f;&#x74;&#x40;&#x31;&#55;&#x32;&#x2e;&#x32;&#50;&#x2e;&#x35;&#x2e;&#55;&#53;">&#114;&#x6f;&#x6f;&#x74;&#x40;&#x31;&#55;&#x32;&#x2e;&#x32;&#50;&#x2e;&#x35;&#x2e;&#55;&#53;</a></p>
</li>
<li><p>如果这里不能登录，需要重启重启ssh服务</p>
<ol>
<li>ubuntu重启ssh服务：/etc/init.d/ssh restart 或者 service sshd restart</li>
<li>Mac下重启ssh服务：先关闭，再启动<br>Mac下关闭ssh：sudo launchctl unload -w /System/Library/LaunchDaemons/ssh.plist<br>Mac下启动ssh服务：sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist<br>正常情况下，通过上面的操作就可以直接直接通过ssh user@IP 的方式登录了，如果不能登录，通过下面的方法查看原因。</li>
</ol>
</li>
</ol>
<h2 id="Linux-这些工具堪称神器！你用过哪个？"><a href="#Linux-这些工具堪称神器！你用过哪个？" class="headerlink" title="Linux 这些工具堪称神器！你用过哪个？"></a>Linux 这些工具堪称神器！你用过哪个？</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WFMDFSTVrnisxjaG6i1b_A">https://mp.weixin.qq.com/s/WFMDFSTVrnisxjaG6i1b_A</a></p>
<p><strong>ag：</strong> 比grep、ack更快的递归搜索文件内容。</p>
<p><strong>tig：</strong> 字符模式下交互查看git项目，可以替代git命令。</p>
<p><strong>jq:</strong> json文件处理以及格式化显示，支持高亮，可以替换python -m json.tool。</p>
<p><strong>mycli：</strong> mysql客户端，支持语法高亮和命令补全，效果类似ipython，可以替代mysql命令。</p>
<p><strong>shellcheck：</strong> shell脚本静态检查工具，能够识别语法错误以及不规范的写法。</p>
<p><strong>fzf：</strong> 命令行下模糊搜索工具，能够交互式智能搜索并选取文件或者内容，配合终端ctrl-r历史命令搜索简直完美。</p>
<p><strong>PathPicker(fpp):</strong> 在命令行输出中自动识别目录和文件，支持交互式，配合git非常有用</p>
<p><strong>glances：</strong> 更强大的 htop / top 代替者。</p>
<p><strong>axel：</strong> 多线程下载工具，下载文件时可以替代curl、wget。</p>
<p><strong>sz/rz：</strong> 交互式文件传输，在多重跳板机下传输文件非常好用，不用一级一级传输。</p>
<p><strong>cloc：</strong> 代码统计工具，能够统计代码的空行数、注释行、编程语言。</p>
<p><strong>script/scriptreplay:</strong> 终端会话录制。</p>
<p><strong>multitail：</strong> 多重 tail。</p>
<p>通常你不止一个日志文件要监控，怎么办？终端软件里开多个 tab 太占地方，可以试试这个工具：</p>
<h3 id="bash调试"><a href="#bash调试" class="headerlink" title="bash调试"></a>bash调试</h3><p>调试需vscode下安装bash debug ,且bash版本是4.* or 5.*</p>
<p>升级bash如下</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peng-lan/p/11201711.html">Mac进行 usr/bin 目录下修改权限问题，operation not permitted</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/litifeng/p/8448019.html">Mac升级bash到最新版本</a></p>
<p>mac自带的bash为3.2版本，而最新的bash是4.9，需要升级了，才能支持关联数组等新特性。</p>
<p>1、brew install bash</p>
<p>2、安装到/usr/local/bin/bash里面。可以通过修改/etc/shells文件，来完成开机使用新版本的bash</p>
<p>3、但是，无法改变/bin/bash的版本，这里仍旧为3.2版本，这给使用脚本带来不便，因为默认都是#!/bin/bash</p>
<p>4、细查后，发现原来mac系统禁止更改系统目录的权限，引入sip机制，需要先关闭，修改，再打开这一系列操作。</p>
<p>5、下面是打开和关闭sip的步骤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)重启OSX系统，然后按住Command+R</span><br><span class="line"></span><br><span class="line">(2)出现界面之后，选择Utilities menu中Terminal</span><br><span class="line"></span><br><span class="line">(3)在Terminal中输入csrutil disable关闭SIP(csrutil enable打开SIP)</span><br><span class="line"></span><br><span class="line">(4)重启reboot OSX</span><br></pre></td></tr></table></figure>

<p>6、关闭sip后，加入软连接，在打开sip</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /bin/bash  /bin/bash.origin</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/bash /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="写出健壮的-Bash-脚本"><a href="#写出健壮的-Bash-脚本" class="headerlink" title="写出健壮的 Bash 脚本"></a>写出健壮的 Bash 脚本</h2><p>可解决如“<strong>如何让shell中某语句执行错误就能自动退出</strong>”问题</p>
<p>原文<a target="_blank" rel="noopener" href="https://www.oschina.net/news/26744/build-robust-bash-script">https://www.oschina.net/news/26744/build-robust-bash-script</a></p>
<h3 id="使用set-u"><a href="#使用set-u" class="headerlink" title="使用set -u"></a>使用set -u</h3><p>你因为没有对变量初始化而使脚本崩溃过多少次？对于我来说，很多次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chroot=<span class="variable">$1</span></span><br><span class="line">...</span><br><span class="line">rm -rf <span class="variable">$chroot</span>/usr/share/doc</span><br></pre></td></tr></table></figure>

<p>如果上面的代码你没有给参数就运行，你不会仅仅删除掉chroot中的文档，而是将系统的所有文档都删除。那你应该做些什么呢？好在bash提供了<em>set -u</em>，当你使用未初始化的变量时，让bash自动退出。你也可以使用可读性更强一点的<code>set -o nounset</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">david% bash /tmp/shrink-chroot.sh</span><br><span class="line"></span><br><span class="line"><span class="variable">$chroot</span>=</span><br><span class="line"></span><br><span class="line">david% bash -u /tmp/shrink-chroot.sh</span><br><span class="line"></span><br><span class="line">/tmp/shrink-chroot.sh: line 3: <span class="variable">$1</span>: unbound variable</span><br><span class="line"></span><br><span class="line">david%</span><br></pre></td></tr></table></figure>



<h3 id="使用set-e"><a href="#使用set-e" class="headerlink" title="使用set -e"></a>使用set -e</h3><p>你写的每一个脚本的开始都应该包含<em>set -e</em>。这告诉bash一但有任何一个语句返回非真的值，则退出bash。使用-e的好处是避免错误滚雪球般的变成严重错误，能尽早的捕获错误。更加可读的版本：<em>set -o errexit</em></p>
<p>使用-e把你从检查错误中解放出来。如果你忘记了检查，bash会替你做这件事。不过你也没有办法使用*$?*来获取命令执行状态了，因为bash无法获得任何非0的返回值。你可以使用另一种结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span>-ne 0]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;command failed&quot;</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>可以替换成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> || &#123; <span class="built_in">echo</span> <span class="string">&quot;command failed&quot;</span>; <span class="built_in">exit</span> 1; &#125;</span><br></pre></td></tr></table></figure>

<p>或者使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;command failed&quot;</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>如果你必须使用返回非0值的命令，或者你对返回值并不感兴趣呢？你可以使用 <em>command || true</em> ，或者你有一段很长的代码，你可以暂时关闭错误检查功能，不过我建议你谨慎使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> +e</span><br><span class="line"></span><br><span class="line">command1</span><br><span class="line"></span><br><span class="line">command2</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br></pre></td></tr></table></figure>

<p>相关文档指出，bash默认返回管道中最后一个命令的值，也许是你不想要的那个。比如执行 <em>false | true</em> 将会被认为命令成功执行。如果你想让这样的命令被认为是执行失败，可以使用 <em>set -o pipefail</em></p>
<h3 id="程序防御-考虑意料之外的事"><a href="#程序防御-考虑意料之外的事" class="headerlink" title="程序防御 - 考虑意料之外的事"></a>程序防御 - 考虑意料之外的事</h3><p>你的脚本也许会被放到“意外”的账户下运行，像缺少文件或者目录没有被创建等情况。你可以做一些预防这些错误事情。比如，当你创建一个目录后，如果父目录不存在，<strong>mkdir</strong> 命令会返回一个错误。如果你创建目录时给<strong>mkdir</strong>命令加上-p选项，它会在创建需要的目录前，把需要的父目录创建出来。另一个例子是 <strong>rm</strong> 命令。如果你要删除一个不存在的文件，它会“吐槽”并且你的脚本会停止工作。（因为你使用了-e选项，对吧？）你可以使用-f选项来解决这个问题，在文件不存在的时候让脚本继续工作。 </p>
<h3 id="准备好处理文件名中的空格"><a href="#准备好处理文件名中的空格" class="headerlink" title="准备好处理文件名中的空格"></a>准备好处理文件名中的空格</h3><p>有些人从在文件名或者命令行参数中使用空格，你需要在编写脚本时时刻记得这件事。你需要时刻记得用引号包围变量。</p>
<p>if [ $filename = “foo” ];</p>
<p>当*$filename*变量包含空格时就会挂掉。可以这样解决：</p>
<p>if [ “$filename” = “foo” ];</p>
<p>使用*$@*变量时，你也需要使用引号，因为空格隔开的两个参数会被解释成两个独立的部分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">david% <span class="function"><span class="title">foo</span></span>() &#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> &#125;; foo bar <span class="string">&quot;baz quux&quot;</span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line">baz</span><br><span class="line"></span><br><span class="line">quux</span><br><span class="line"></span><br><span class="line">david% <span class="function"><span class="title">foo</span></span>() &#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> &#125;; foo bar <span class="string">&quot;baz quux&quot;</span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line">baz quux</span><br></pre></td></tr></table></figure>

<p>我没有想到任何不能使用*”$@”*的时候，所以当你有疑问的时候，使用引号就没有错误。</p>
<p>如果你同时使用find和xargs，你应该使用 -print0 来让字符分割文件名，而不是换行符分割。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">david% touch <span class="string">&quot;foo bar&quot;</span></span><br><span class="line"></span><br><span class="line">david% find | xargs ls</span><br><span class="line"></span><br><span class="line">ls: ./foo: No such file or directory</span><br><span class="line"></span><br><span class="line">ls: bar: No such file or directory</span><br><span class="line"></span><br><span class="line">david% find -print0 | xargs -0 ls</span><br><span class="line"></span><br><span class="line">./foo bar</span><br></pre></td></tr></table></figure>

<p>其他见原文</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
<div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kuangyl-max.github.io/2021/11/15/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="小邝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/docker/" class="post-title-link" itemprop="url">Docker教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 13:45:40 / 修改时间：20:32:46" itemprop="dateCreated datePublished" datetime="2021-11-15T13:45:40+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          
            <span id="/2021/11/15/docker/" class="post-meta-item leancloud_visitors" data-flag-title="Docker教程" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
	<span>℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/15/docker/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/15/docker/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><a target="_blank" rel="noopener" href="https://www.docker.org.cn/docker/195.html"><strong>docker中文教程</strong> </a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it paddle bash</span><br></pre></td></tr></table></figure>



<h2 id="docker-安装及配置"><a href="#docker-安装及配置" class="headerlink" title="docker 安装及配置"></a>docker 安装及配置</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/macos-docker-install.html">https://www.runoob.com/docker/macos-docker-install.html</a></p>
<p>含Ubuntu，Linux，macOS，window，CentOS等</p>
<p><strong>Mac</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask --appdir=/Applications docker</span><br></pre></td></tr></table></figure>



<blockquote>
<h2 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h2><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p>
<ul>
<li>网易：<strong><a target="_blank" rel="noopener" href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></strong></li>
<li>阿里云：<strong>https://&lt;你的ID&gt;.mirror.aliyuncs.com</strong></li>
<li>七牛云加速器：<strong><a target="_blank" rel="noopener" href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></strong></li>
</ul>
<p>当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</p>
<p>阿里云镜像获取地址：<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors%EF%BC%8C%E7%99%BB%E9%99%86%E5%90%8E%EF%BC%8C%E5%B7%A6%E4%BE%A7%E8%8F%9C%E5%8D%95%E9%80%89%E4%B8%AD%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%E5%9C%B0%E5%9D%80%E4%BA%86%EF%BC%9A">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors，登陆后，左侧菜单选中镜像加速器就可以看到你的专属地址了：</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hankleo/p/13596264.html">mac下docker镜像加速</a></p>
<p>1.前往<code>https://cr.console.aliyun.com/</code>，注册、登录找到“镜像加速器”。复制加速器地址</p>
<p>2.在Docker Desktop下配置加速器</p>
<p>在任务栏点击 Docker Desktop 应用图标 -&gt; Perferences，在左侧导航菜单选择 Docker Engine，在右侧输入栏编辑 json 文件。将</p>
<p><code>https://xxxx.mirror.aliyuncs.com</code>加到 <code>&quot;registry-mirrors&quot;</code> 的数组里，点击 Apply &amp; Restart按钮，等待Docker重启并应用配置的镜像加速器。</p>
<h3 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h3><p>检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 <strong>docker info</strong>，如果从结果中看到了如下内容，说明配置成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br><span class="line">Registry Mirrors:</span><br><span class="line">    https:&#x2F;&#x2F;reg-mirror.qiniu.com</span><br></pre></td></tr></table></figure>
</blockquote>
<p>安装完成后，运行下面的命令，验证是否安装成功。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Docker-入门教程-阮一峰"><a href="#Docker-入门教程-阮一峰" class="headerlink" title="Docker 入门教程-阮一峰"></a><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程-阮一峰</a></h2><p>2013年发布至今， <a target="_blank" rel="noopener" href="https://www.docker.com/">Docker</a> 一直广受瞩目，被认为可能会改变软件行业。</p>
<p>但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。</p>
<h3 id="一、环境配置的难题"><a href="#一、环境配置的难题" class="headerlink" title="一、环境配置的难题"></a>一、环境配置的难题</h3><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p>
<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p>
<p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p>
<p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>
<h3 id="二、虚拟机"><a href="#二、虚拟机" class="headerlink" title="二、虚拟机"></a>二、虚拟机</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>
<p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>
<p><strong>（1）资源占用多</strong></p>
<p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p>
<p><strong>（2）冗余步骤多</strong></p>
<p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p>
<p><strong>（3）启动慢</strong></p>
<p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>
<h3 id="三、Linux-容器"><a href="#三、Linux-容器" class="headerlink" title="三、Linux 容器"></a>三、Linux 容器</h3><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>
<p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a target="_blank" rel="noopener" href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>由于容器是进程级别的，相比虚拟机有很多优势。</p>
<p><strong>（1）启动快</strong></p>
<p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>
<p><strong>（2）资源占用少</strong></p>
<p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>
<p><strong>（3）体积小</strong></p>
<p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>
<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>
<h3 id="四、Docker-是什么？"><a href="#四、Docker-是什么？" class="headerlink" title="四、Docker 是什么？"></a>四、Docker 是什么？</h3><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h3 id="五、Docker-的用途"><a href="#五、Docker-的用途" class="headerlink" title="五、Docker 的用途"></a>五、Docker 的用途</h3><p>Docker 的主要用途，目前有三大类。</p>
<p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>
<p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p>
<p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>
<h3 id="六、Docker-的安装"><a href="#六、Docker-的安装" class="headerlink" title="六、Docker 的安装"></a>六、Docker 的安装</h3><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p>
<p>Docker CE 的安装请参考官方文档。</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/install/">Mac</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-windows/install/">Windows</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">Debian</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/fedora/">Fedora</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/binaries/">其他 Linux 发行版</a></li>
</ul>
</blockquote>
<p>安装完成后，运行下面的命令，验证是否安装成功。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user">官方文档</a>）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>Docker 是服务器—-客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a target="_blank" rel="noopener" href="https://docs.docker.com/config/daemon/systemd/">官方文档</a>）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service 命令的用法</span></span><br><span class="line">$ sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl 命令的用法</span></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Mac启动方式</strong></p>
<p><strong>方法 1</strong> : 通过 launchctl 查看 docker server, 记住docker server 名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">launchctl list | grep docker</span><br><span class="line"></span><br><span class="line">111117   0       com.docker.docker.2388</span><br></pre></td></tr></table></figure>

<p>然后关闭和启动它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl stop com.docker.docker.2388 &amp;&amp; launchctl start com.docker.docker.2388</span><br></pre></td></tr></table></figure>

<p><strong>方法 2</strong> : 或者启动docker.app</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open &#x2F;Applications&#x2F;Docker.app</span><br></pre></td></tr></table></figure>

<h3 id="七、image-文件"><a href="#七、image-文件" class="headerlink" title="七、image 文件"></a>七、image 文件</h3><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p>
<p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p>
<h3 id="八、实例：hello-world"><a href="#八、实例：hello-world" class="headerlink" title="八、实例：hello world"></a>八、实例：hello world</h3><p>下面，我们通过最简单的 image 文件”<a target="_blank" rel="noopener" href="https://hub.docker.com/r/library/hello-world/">hello world”</a>，感受一下 Docker。</p>
<p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">下一篇文章</a>的第一节。有需要的朋友，可以先看一下。</p>
<p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull library/hello-world</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p>
<p>由于 Docker 官方提供的 image 文件，都放在<a target="_blank" rel="noopener" href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull hello-world</span><br></pre></td></tr></table></figure>
</blockquote>
<p>抓取成功以后，就可以在本机看到这个 image 文件了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在，运行这个 image 文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p>
<p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p>
<p>如果运行成功，你会在屏幕上读到下面的输出。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p>
<p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于那些不会自动终止的容器，必须使用<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="九、容器文件"><a href="#九、容器文件" class="headerlink" title="九、容器文件"></a>九、容器文件</h3><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p>
<p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p>
<h3 id="十、Dockerfile-文件"><a href="#十、Dockerfile-文件" class="headerlink" title="十、Dockerfile 文件"></a>十、Dockerfile 文件</h3><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p>
<p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p>
<p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p>
<h3 id="十一、实例：制作自己的-Docker-容器"><a href="#十一、实例：制作自己的-Docker-容器" class="headerlink" title="十一、实例：制作自己的 Docker 容器"></a>十一、实例：制作自己的 Docker 容器</h3><p>下面我以 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/08/koa.html">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p>
<p>作为准备工作，请先<a target="_blank" rel="noopener" href="https://github.com/ruanyf/koa-demos/archive/master.zip">下载源码</a>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ruanyf/koa-demos.git</span><br><span class="line">$ <span class="built_in">cd</span> koa-demos</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="编写-Dockerfile-文件"><a href="#编写-Dockerfile-文件" class="headerlink" title="编写 Dockerfile 文件"></a>编写 Dockerfile 文件</h4><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a target="_blank" rel="noopener" href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>
<p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a target="_blank" rel="noopener" href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码一共五行，含义如下。</p>
<blockquote>
<ul>
<li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li>
<li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li>
<li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li>
<li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>
<li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>
</ul>
</blockquote>
<h4 id="创建-image-文件"><a href="#创建-image-文件" class="headerlink" title="创建 image 文件"></a>创建 image 文件</h4><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p>
<p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h4><p><code>docker container run</code>命令会从 image 文件生成容器。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令的各个参数含义如下：</p>
<blockquote>
<ul>
<li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li>
<li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li>
<li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li>
<li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li>
</ul>
</blockquote>
<p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment">#</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment"># node demos/01.js</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 <a target="_blank" rel="noopener" href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js">demo</a> 没有写路由。</p>
<p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p>
<p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="CMD-命令"><a href="#CMD-命令" class="headerlink" title="CMD 命令"></a>CMD 命令</h4><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p>
<p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p>
<p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="发布-image-文件"><a href="#发布-image-文件" class="headerlink" title="发布 image 文件"></a>发布 image 文件</h4><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p>
<p>首先，去 <a target="_blank" rel="noopener" href="https://hub.docker.com/">hub.docker.com</a> 或 <a target="_blank" rel="noopener" href="https://cloud.docker.com/">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>
</blockquote>
<p>接着，为本地的 image 标注用户名和版本。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>也可以不标注用户名，重新构建一下 image 文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后，发布 image 文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p>
<h3 id="十二、其他有用的命令"><a href="#十二、其他有用的命令" class="headerlink" title="十二、其他有用的命令"></a>十二、其他有用的命令</h3><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p>
<p><strong>（1）docker container start</strong></p>
<p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>（2）docker container stop</strong></p>
<p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash container stop [containerID]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>
<p><strong>（3）docker container logs</strong></p>
<p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>（4）docker container exec</strong></p>
<p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>（5）docker container cp</strong></p>
<p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure>
</blockquote>
<p>非常感谢你一直读到了这里，这个系列还有<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">下一篇</a>，介绍如何使用 Docker 搭建真正的网站，欢迎<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">继续阅读</a>。</p>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul>
<li><p>2020.12.13: <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2020/12/ssh-tutorial.html">《SSH 入门教程》发布了</a></p>
<p>SSH 是登录 Linux 服务器的必备工具，只要你在做互联网开发，多多少少都会用到它。</p>
</li>
<li><p>2020.11.02: <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2020/11/wechat-miniprogram-tutorial-part-four.html">微信小程序入门教程之四：API 使用</a></p>
<p>今天是这个系列教程的最后一篇。</p>
</li>
<li><p>2020.10.29: <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2020/10/wechat-miniprogram-tutorial-part-three.html">微信小程序入门教程之三：脚本编程</a></p>
<p>这个系列教程的前两篇，介绍了小程序的项目结构和页面样式。</p>
</li>
<li><p>2020.10.27: <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2020/10/wechat-miniprogram-tutorial-part-two.html">微信小程序入门教程之二：页面样式</a></p>
<p>这个系列的上一篇教程，教大家写了一个最简单的 Hello world 微信小程序。</p>
</li>
</ul>
<p>创建你的第一个容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">username@localhost$</span><span class="bash">  docker run -d -p 80:80 docker/getting-started</span></span><br><span class="line">Unable to find image &#x27;docker/getting-started:latest&#x27; locally</span><br><span class="line">latest: Pulling from docker/getting-started</span><br><span class="line">188c0c94c7c5: Pull complete</span><br><span class="line">617561f33ec6: Pull complete</span><br><span class="line">7d856acdaa9c: Pull complete</span><br><span class="line">a0d3c6e28e6d: Pull complete</span><br><span class="line">af69a9b963c8: Pull complete</span><br><span class="line">0739f3815ad8: Pull complete</span><br><span class="line">7c7b75d0baf8: Pull complete</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="Docker-微服务教程"><a href="#Docker-微服务教程" class="headerlink" title="Docker 微服务教程"></a>Docker 微服务教程</h3><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html</a></p>
<p>本文采用三种方法，演示如何架设 WordPress 网站。</p>
<blockquote>
<ul>
<li>方法 A：自建 WordPress 容器</li>
<li>方法 B：采用官方的 WordPress 容器</li>
<li>方法 C：采用 Docker Compose 工具</li>
</ul>
</blockquote>
<h2 id="疑难"><a href="#疑难" class="headerlink" title="疑难"></a>疑难</h2><h3 id="VSCode-远程连接Docker"><a href="#VSCode-远程连接Docker" class="headerlink" title="VSCode 远程连接Docker"></a>VSCode 远程连接Docker</h3><h3 id="Windows下搭建最接近Linux体验的开发环境——使用WSL-Linux子系统"><a href="#Windows下搭建最接近Linux体验的开发环境——使用WSL-Linux子系统" class="headerlink" title="Windows下搭建最接近Linux体验的开发环境——使用WSL(Linux子系统)"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021742880">Windows下搭建最接近Linux体验的开发环境——使用WSL(Linux子系统)</a></h3><h3 id="Windows系统利用Docker实现Linux环境搭建"><a href="#Windows系统利用Docker实现Linux环境搭建" class="headerlink" title="Windows系统利用Docker实现Linux环境搭建"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41380248/article/details/89013751">Windows系统利用Docker实现Linux环境搭建</a></h3><h3 id="获取容器完整Id"><a href="#获取容器完整Id" class="headerlink" title="获取容器完整Id"></a>获取容器完整Id</h3><ol>
<li><p>查看container ID</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/01/19/13-45-22-fadf64317dcaf9a84fce217725efeb5d-image-20210119134519900-3ca6e2.png" alt="image-20210119134519900"></p>
<blockquote>
<p>–all , -a  :  显示所有容器(默认只显示当前运行的容器)</p>
</blockquote>
</li>
<li><p>根据container ID  ： 0a01e194a5a7获取 容器信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect  0a01e194a5a7</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;416df806cb3f4e7c27a0a76eb7073f03047add4e1372cda3b65453fd2f1b072f&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-01-18T09:17:07.5536068Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;/docker-entrypoint.sh&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">            <span class="string">&quot;daemon off;&quot;</span></span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">]</span><br><span class="line">$ docker inspect 0a01e194a5a7 | grep <span class="string">&#x27;&quot;Id&quot;&#x27;</span></span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;0a00e134a5b7139ed49d88b48b2bkf5d5517683fd143b946fa6aed634f3fe09c&quot;</span>,</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">$ docker inspect 0a01e194a5a7 | grep <span class="string">&#x27;&quot;Id&quot;&#x27;</span> | awk -F <span class="string">&#x27;&quot;&#x27;</span> <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br><span class="line">0a00e134a5b7139ed49d88b48b2bkf5d5517683fd143b946fa6aed634f3fe09c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过这个Id我们可以执行<code>docker exec -it Id /bin/bash </code> 开启一个交互模式的终端</p>
</blockquote>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">containerNAME=<span class="string">&quot;&quot;</span> <span class="comment">#容器名</span></span><br><span class="line">containerID=$(docker container ls --all  | grep <span class="string">&quot;<span class="variable">$containerNAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">integratedId=$(docker inspect <span class="string">&quot;<span class="variable">$containerID</span>&quot;</span> | grep <span class="string">&#x27;&quot;Id&quot;&#x27;</span> | awk -F <span class="string">&#x27;&quot;&#x27;</span> <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>或者</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a -q -f <span class="string">&quot;name=kind_mendeleev&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>或者</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.ID&#125;&#125;&#x27;</span> containerNAME</span></span><br></pre></td></tr></table></figure>

<p>注意，此处name 为：</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/01/19/14-17-24-ef4f3a405ab0e25d288c3adb3104a6b5-image-20210119141722116-4f5e7e.png" alt="image-20210119141722116"></p>
<table>
<thead>
<tr>
<th>Name, shorthand</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--all , -a</code></td>
<td></td>
<td>Show all containers (default shows just running)</td>
</tr>
<tr>
<td><code>--filter , -f</code></td>
<td></td>
<td>Filter output based on conditions provided</td>
</tr>
<tr>
<td><code>--format</code></td>
<td></td>
<td>Pretty-print containers using a Go template</td>
</tr>
<tr>
<td><code>--last , -n</code></td>
<td><code>-1</code></td>
<td>Show n last created containers (includes all states)</td>
</tr>
<tr>
<td><code>--latest , -l</code></td>
<td></td>
<td>Show the latest created container (includes all states)</td>
</tr>
<tr>
<td><code>--no-trunc</code></td>
<td></td>
<td>Don’t truncate output</td>
</tr>
<tr>
<td><code>--quiet , -q</code></td>
<td></td>
<td>Only display numeric IDs</td>
</tr>
<tr>
<td><code>--size , -s</code></td>
<td></td>
<td>Display total file sizes</td>
</tr>
</tbody></table>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
<div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kuangyl-max.github.io/2021/11/15/terminal-tabby/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="小邝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/15/terminal-tabby/" class="post-title-link" itemprop="url">Tabby配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-15 13:45:40 / 修改时间：21:15:10" itemprop="dateCreated datePublished" datetime="2021-11-15T13:45:40+08:00">2021-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          
            <span id="/2021/11/15/terminal-tabby/" class="post-meta-item leancloud_visitors" data-flag-title="Tabby配置" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
	<span>℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/15/terminal-tabby/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/15/terminal-tabby/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tabby"><a href="#Tabby" class="headerlink" title="Tabby"></a>Tabby</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>全平台通用。功能强大。<br>支持</p>
<ul>
<li><p>免密登录ssh服务器</p>
</li>
<li><p>sftp 免scp与服务器互传文件</p>
</li>
<li><p>拆分窗格</p>
</li>
<li><p>鼠标右键打开当前文件夹</p>
</li>
<li><p>配置同步</p>
<p>……</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a target="_blank" rel="noopener" href="https://tabby.sh/">Tabby - a terminal for a more modern age</a></p>
<p>Github:<a target="_blank" rel="noopener" href="https://github.com/eugeny/tabby">Eugeny/tabby</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#安装</span><br><span class="line">#方法1： https:&#x2F;&#x2F;github.com&#x2F;Eugeny&#x2F;tabby&#x2F;releases&#x2F;latest ,下载.exe文件</span><br><span class="line">#方法2</span><br><span class="line">scoop install terminus -g </span><br></pre></td></tr></table></figure>

<h2 id="配置ssh连接"><a href="#配置ssh连接" class="headerlink" title="配置ssh连接"></a>配置ssh连接</h2><p>1.打开Tabby设置，转到如下界面，并点击<code>New profile</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/21-03-08-a9042000e61cb4d75b0e34cfce428e87-typora-user-images-image-20211115210251688-b5c612.png" alt="image-20211115210251688"></p>
<p>2.点击<code>SSH connection</code></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/21-03-54-49aeb8c903403513c8a68dcaa8cd05c3-typora-user-images-image-20211115210353634-2f4bbb.png" alt="image-20211115210353634"></p>
<p>3.填写Host和Username及password，并保存</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/21-05-25-223eda57c83754b3c7cbe87624ead1ec-typora-user-images-image-20211115210523839-e1fef3.png" alt="image-20211115210523839"></p>
<p>4.点击下图中的位置</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/21-12-24-a5ed26dbfd0b60b3fce335a19a18dcd6-typora-user-images-image-20211115210608863-c2c9b2.png" alt="image-20211115210608863"></p>
<p>5.选择你的刚刚配置的sever即可进入服务器</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/21-07-14-db19bb05517da28a06fafd15abd86983-typora-user-images-image-20211115210712342-4eee44.png" alt="image-20211115210712342"></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/21-08-02-23cbb42c5a624c8d9febf91286a3ad0f-typora-user-images-image-20211115210801841-0b55d4.png" alt="image-20211115210801841"></p>
<h2 id="设置同步你的配置"><a href="#设置同步你的配置" class="headerlink" title="设置同步你的配置"></a>设置同步你的配置</h2><p>1.在Plugins内搜索并安装<code>sync-config</code></p>
<p>2.进入github-》settings -》Developer settings -》 Personal access tokens（即<a target="_blank" rel="noopener" href="https://github.com/settings/tokens">Personal Access Tokens (github.com)</a>）</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/20-55-11-2ff1eaee92ee4d6fc01ba72212717794-typora-user-images-image-20211115205510670-772853.png" alt="image-20211115205510670"></p>
<p>3.选择<code>Generate new token</code>,并填写相关信息（随便√的，能用就完事了）</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/20-56-45-394683581793bc6a84416f67e25845fe-typora-user-images-image-20211115205644578-e3639c.png" alt="image-20211115205644578"></p>
<p>4.复制token到Tabby -》SyncConfig 并选择上传即可</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/20-58-09-6be5f30c077c1b6a3e32febbdb428872-typora-user-images-image-20211115205808413-fe85b7.png" alt="image-20211115205808413"></p>
<h2 id="命令行内打开-本地文件路径-或-网页链接"><a href="#命令行内打开-本地文件路径-或-网页链接" class="headerlink" title="命令行内打开 本地文件路径 或 网页链接"></a>命令行内打开 本地文件路径 或 网页链接</h2><p>1.在Plugins内搜索并安装<code>clickable-links</code></p>
<p>2.重启Tabby，设置快捷键</p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/15/20-50-49-90f2c5773f6f84cee8c05580bd930db2-typora-user-images-image-20211115205041447-109152.png" alt="image-20211115205041447"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
<div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kuangyl-max.github.io/2021/10/28/tool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="小邝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/28/tool/" class="post-title-link" itemprop="url">工具合集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-28 13:45:40" itemprop="dateCreated datePublished" datetime="2021-10-28T13:45:40+08:00">2021-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-22 17:42:31" itemprop="dateModified" datetime="2021-11-22T17:42:31+08:00">2021-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          
            <span id="/2021/10/28/tool/" class="post-meta-item leancloud_visitors" data-flag-title="工具合集" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
	<span>℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/10/28/tool/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/10/28/tool/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Window-终端配置"><a href="#Window-终端配置" class="headerlink" title="Window 终端配置"></a>Window 终端配置</h1><p>相关软件快捷安装脚本 及 Fira字体：<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/kuangyl-max/kuangyl-max.github.io@master/download/install.zip">点击下载</a></p>
<h2 id="Scoop配置"><a href="#Scoop配置" class="headerlink" title="Scoop配置"></a>Scoop配置</h2><p>Scoop的定位主要是“开源、命令行的开发者工具”</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luoyooi/article/details/102990113">Windows下Scoop安装、配置与使用_luoyooi的博客-CSDN博客_scoop</a></p>
<p><strong>安装</strong></p>
<p>在PowerShell中运行以下命令，将scoop安装到其默认位置(<code>C:\Users\&lt;user&gt;\scoop</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object</span><br><span class="line">System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;get.scoop.sh&#39;)</span><br><span class="line">#或者</span><br><span class="line">iwr -useb get.scoop.sh | iex</span><br></pre></td></tr></table></figure>

<p>安装完成后，输入<code>scoop help</code>验证是否成功（常见的命令可以通过此方法来查看）。</p>
<p>用户安装的程序和scoop本身位于C:Users&lt;user&gt;scoop。全局安装的程序（–global）位于C:\ProgramData\scoop。可以通过环境变量更改这些设置。具体步骤如下：</p>
<p><strong>将Scoop安装到自定义目录(命令行方式)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$env:SCOOP&#x3D;&#39;D:Applications\Scoop&#39;</span><br><span class="line"></span><br><span class="line">[Environment]::SetEnvironmentVariable(&#39;SCOOP&#39;, $env:SCOOP,&#39;User&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>将Scoop配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$env:SCOOP_GLOBAL&#x3D;&#39;F:\GlobalScoopApps&#39;</span><br><span class="line"></span><br><span class="line">[Environment]::SetEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;,</span><br><span class="line">$env:SCOOP_GLOBAL, &#39;Machine&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>上面两句运行的结果(环境变量)</strong></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/media/2020/12/05/17-38-45-69d072a8079102da338071daa6fa4c10-image55-d2410c.png" alt="在这里插入图片描述">{width=”5.768055555555556in”<br>height=”4.741666666666666in”}<br>如果不想运行命令行，直接添加环境变量也可。设置完安装位置后，建议将默认目录下的所有文件复制到新目录（<strong>不是剪切！！</strong>）</p>
<p>参考链接：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/50993df76b1c">scoop——强大的Windows命令行包管理工具 - 简书(jianshu.com)</a></p>
</li>
<li><p>配色 如何保存更改 ：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cum44153/article/details/109043040">zsh自定义命令提示符_如何使用Microsoft的ColorTool自定义命令提示符的配色方案_cum44153的博客-CSDN博客</a></p>
</li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4b2b7074d9e2">像MAC一样使用win10的Terminal - 简书(jianshu.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43455581/article/details/105565970">使用Oh-My-Posh美化FluentTerminal_罗伯特祥的博客-CSDN博客</a></li>
</ul>
<blockquote>
<p> 如果遇到<strong>powershell乱码</strong>,  可以更改字体(如Fira Code Retina)</p>
<p>或者<a target="_blank" rel="noopener" href="https://blog.csdn.net/yihuajack/article/details/111405007">oh-my-posh3及oh-my-zsh提示prompt出现乱码的原因及使用Nerd字体的解决方法_yihuajack的博客-CSDN博客</a></p>
</blockquote>
<h2 id="scoop下工具安装"><a href="#scoop下工具安装" class="headerlink" title="scoop下工具安装"></a>scoop下工具安装</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scoop install <span class="number">7</span>zip</span><br><span class="line">scoop install aria2</span><br><span class="line">scoop install bfg</span><br><span class="line">scoop install cacert</span><br><span class="line">scoop install colortool</span><br><span class="line">scoop install <span class="built_in">curl</span></span><br><span class="line">scoop install cygwin</span><br><span class="line">scoop install gawk</span><br><span class="line">scoop install grep</span><br><span class="line">scoop install maven</span><br><span class="line">scoop install ntop</span><br><span class="line">scoop install redis</span><br><span class="line">scoop install sed</span><br><span class="line">scoop install unzip</span><br><span class="line">scoop install vim</span><br><span class="line">scoop install <span class="built_in">wget</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cygwin 相当于虚拟Linux环境；内部可安装apt-cyg</span></span><br><span class="line"><span class="comment">#之后安装如下包</span></span><br><span class="line">apt<span class="literal">-cyg</span> install tree </span><br></pre></td></tr></table></figure>

<blockquote>
<p>若下载不了，则开启VPN</p>
</blockquote>
<h2 id="配置右键菜单栏"><a href="#配置右键菜单栏" class="headerlink" title="配置右键菜单栏"></a>配置右键菜单栏</h2><p>HKEY_CLASSES_ROOT\Directory\Background\shell新建PowershellMenu</p>
<p>空白处右键菜单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\PowershellMenu]</span><br><span class="line">@&#x3D;&quot;Open PowerShell Here&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;C:\\\\Windows\\\\SysWOW64\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\PowershellMenu\command]</span><br><span class="line">@&#x3D;&quot;C:\\\\Windows\\\\SysWOW64\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -NoExit -Command Set-Location -LiteralPath &#39;%v&#39;&quot;</span><br></pre></td></tr></table></figure>

<p>HKEY_CLASSES_ROOT\Directory\shell新建PowershellMenu</p>
<p>文件夹右键菜单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\PowershellMenu]</span><br><span class="line">@&#x3D;&quot;Open PowerShell Here&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;C:\\\\Windows\\\\SysWOW64\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\PowershellMenu\command]</span><br><span class="line">@&#x3D;&quot;C:\\\\Windows\\\\SysWOW64\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -NoExit -Command Set-Location -LiteralPath &#39;%L&#39;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Chocolatey配置"><a href="#Chocolatey配置" class="headerlink" title="Chocolatey配置"></a>Chocolatey配置</h2><p>Chocolatey依赖于Windows PowerShell及其NuGet包管理器系统，该系统主要用于解决软件库依赖关系。常用来管理window桌面端应用，如googlechrome,QQ等</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hffyyg/article/details/83990873?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">Windows上的巧克力味Chocolatey详解_hffyyg的博客-CSDN博客_chocolatey</a></p>
<h2 id="终端工具"><a href="#终端工具" class="headerlink" title="终端工具"></a>终端工具</h2><h3 id="terminus"><a href="#terminus" class="headerlink" title="terminus"></a>terminus</h3><p>全平台通用。功能强大。</p>
<p><a target="_blank" rel="noopener" href="https://tabby.sh/">Tabby - a terminal for a more modern age</a></p>
<p>Github:<a target="_blank" rel="noopener" href="https://github.com/eugeny/tabby">Eugeny/tabby</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#安装</span><br><span class="line">#方法1： https:&#x2F;&#x2F;github.com&#x2F;Eugeny&#x2F;tabby</span><br><span class="line">#方法2</span><br><span class="line">scoop install terminus -g </span><br></pre></td></tr></table></figure>

<p>详细配置见：<a href="https://kuangyl-max.github.io/2021/11/15/terminal-tabby/">Tabby配置 | 博客 (kuangyl-max.github.io)</a></p>
<h3 id="fluentTerminal"><a href="#fluentTerminal" class="headerlink" title="fluentTerminal"></a>fluentTerminal</h3><p>可配置背景图</p>
<h3 id="Xshell"><a href="#Xshell" class="headerlink" title="Xshell"></a>Xshell</h3><h3 id="Cmder"><a href="#Cmder" class="headerlink" title="Cmder"></a>Cmder</h3><p>颜值还行，可配置背景图，但功能较为单一</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onelikeone/p/9301631.html">Window 命令行神器：cmder - 行走的思想 - 博客园 (cnblogs.com)</a></p>
<p><img src="https://raw.githubusercontent.com/kuangyl-max/markdownMedia/master/img/fix-dir/typora-user-images/2021/11/20/18-25-19-e1c35c518493493a488f7c0c04228e26-typora-user-images-image-20211120182517464-154935.png" alt="image-20211120182517464"></p>
<h1 id="Onedriver"><a href="#Onedriver" class="headerlink" title="Onedriver"></a>Onedriver</h1><h2 id="同步任意文件夹"><a href="#同步任意文件夹" class="headerlink" title="同步任意文件夹"></a>同步任意文件夹</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#需在<span class="built_in">cmd</span>内执行</span><br><span class="line">mklink /j &quot;onedrive文件夹地址\需要同步的文件夹名&quot; &quot;需要同步的文件夹地址&quot;</span><br><span class="line">mklink /j &quot;H:\OneDriver\OneDrive - stu.suda.edu.cn\研究生\算法&quot; &quot;H:\算法&quot;</span><br></pre></td></tr></table></figure>

<h1 id="自建博客"><a href="#自建博客" class="headerlink" title="自建博客"></a>自建博客</h1><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><strong>利用Hexo在多台电脑上提交和更新github pages博客</strong></p>
<p><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration.html">https://hexo.io/zh-cn/docs/configuration.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0b1fccce74e0?tdsourcetag=s_pcqq_aiomsg">[https://www.jianshu.com/p/0b1fccce74e0?tdsourcetag=s_pcqq_aiomsg]{.ul}</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程_Fangzh的技术博客-CSDN博客_hexo</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4bcf2848b3fc">[https://www.jianshu.com/p/4bcf2848b3fc]{.ul}</a></p>
<p><strong>写文章</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44815733/article/details/88786480">[https://blog.csdn.net/weixin_44815733/article/details/88786480]{.ul}</a></p>
<h2 id="docsify"><a href="#docsify" class="headerlink" title="docsify"></a>docsify</h2><p><strong>有了docsify神器，从此爱上看文档</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4883e95aa903">https://www.jianshu.com/p/4883e95aa903</a></p>
<p><a target="_blank" rel="noopener" href="https://docsify.js.org/#/zh-cn/">官方中文文档</a></p>
<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h2 id="vscode插件"><a href="#vscode插件" class="headerlink" title="vscode插件"></a>vscode插件</h2><p><strong>1.markdown-all-in-one—-基础功能+快捷键。<br>2.markdown toc—生成目录<br>3.markdown+math–编辑公式<br>4.Markdown PDF–转为PDF和其他格式<br>5.Markdown Preview Enhanced—–所以这款是增强显示的。<br>6.Markdown Shortcuts—–解决复制表格的问题。</strong></p>
<h2 id="markdown互转word"><a href="#markdown互转word" class="headerlink" title="markdown互转word"></a>markdown互转word</h2><h3 id="一键将-Word-转换为-Markdown"><a href="#一键将-Word-转换为-Markdown" class="headerlink" title="一键将 Word 转换为 Markdown"></a>一键将 Word 转换为 Markdown</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/df6a136d06d8">https://www.jianshu.com/p/df6a136d06d8</a></p>
<h3 id="Writage-Pandoc"><a href="#Writage-Pandoc" class="headerlink" title="Writage + Pandoc"></a>Writage + Pandoc</h3><ol>
<li><p>下载并安装 Writage，下载地址：<a target="_blank" rel="noopener" href="http://www.writage.com/">http://www.writage.com/</a></p>
<p>打开 Writage网页，点击Download，再点击Download Now完成下载<br>运行安装程序，一般按照默认选项安装就好啦</p>
</li>
<li><p>安装后重启电脑，新建或打开任一 Word 文档，在 文件 菜单栏下选 另存为，查看 <strong>【保存类型】</strong> 中是否有 Markdown 格式。</p>
</li>
</ol>
<blockquote>
<p>如果插件安装成功，就会自动出现Markdown选项；否则，重新安装一遍吧~）</p>
</blockquote>
<h3 id="Word-to-Markdown-Converter在线转换"><a href="#Word-to-Markdown-Converter在线转换" class="headerlink" title="Word to Markdown Converter在线转换"></a>Word to Markdown Converter在线转换</h3><ol>
<li><strong>设置word文档中的标准样式，如一级、二级标题，项目符号或编号等，如此才能与markdown的格式对应</strong></li>
</ol>
<p>（稍微有点繁琐的前期准备，如果文档一开始就是按照标准样式排版，就没有这个烦恼啦）</p>
<p>设置</p>
<ol>
<li><p>打开网页Word to Markdown</p>
<blockquote>
<p>Converter：<a target="_blank" rel="noopener" href="https://word-to-markdown.herokuapp.com/">https://word-to-markdown.herokuapp.com/</a></p>
</blockquote>
</li>
<li><p>选择需要转换的Word文件,点击Convert</p>
</li>
<li><p>大功告成啦！<br>页面左边显示的是Markdown文档的内容，右边显示的是预览出来的样子</p>
</li>
</ol>
<p><strong>但还需要进一步手动编辑整理完善表格</strong></p>
<p>（如果，Word文档本身不包括表格，Word to Markdown<br>Converter使用体验可谓相当便捷稳妥啦！）</p>
<p><strong>图片的下载与存储</strong></p>
<p>除了标准格式设置与表格调整问题，<br><strong>图片的下载与存储</strong>也会是我们可能会遇到的问题</p>
<ul>
<li><p><strong>Markdown转换为Word</strong><br>在Markdown文档中，图片以网络超链接的形式保存,如果markdown文档中有这一类图片，那么需要在网络连接的情况下，才能正常输出有图片的word文档。否则，图片处显示空白</p>
</li>
<li><p><strong>Word转换为Markdown</strong><br>Word转换为Markdown文档之后，文档中的图片输出到本地文件夹下，将该文件夹与输出的Markdown文档在同一目录下，在Markdown文档中图片引用本地相对路径，也就是说，必须保证Markdown文档与存放图片的本地文件夹在一起，才能完整的在markdown编辑器中显示图片</p>
</li>
</ul>
<h3 id="在线版word2markdown"><a href="#在线版word2markdown" class="headerlink" title="在线版word2markdown"></a>在线版word2markdown</h3><p><a target="_blank" rel="noopener" href="https://word2md.com/">https://word2md.com/</a></p>
<h3 id="Ulysses-mac支持-纯文本-Markdown2Word-，但付费"><a href="#Ulysses-mac支持-纯文本-Markdown2Word-，但付费" class="headerlink" title="Ulysses mac支持 纯文本 Markdown2Word ，但付费"></a>Ulysses mac支持 纯文本 Markdown2Word ，但付费</h3><p>目前只研究了Mac下的方案：</p>
<ol>
<li>word-to-markdown，google用word to</li>
</ol>
<p>markdown搜出来第一个，看来这个名字起得好。用这个的话得装个LibreOffice</p>
<ol>
<li><p>pandoc，这个就比较大名鼎鼎了</p>
</li>
<li><p>unoconv，介绍</p>
</li>
</ol>
<p>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b0be43b03015">https://www.jianshu.com/p/b0be43b03015</a></p>
<h2 id="Markdown如何存放图片"><a href="#Markdown如何存放图片" class="headerlink" title="Markdown如何存放图片"></a>Markdown如何存放图片</h2><h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><p>配置</p>
<ol>
<li><p>申请七牛云做免费图床</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/335783774/answer/756830851">https://www.zhihu.com/question/335783774/answer/756830851</a></p>
</li>
</ol>
<p>存储空间名称markdown-source-of-bayes</p>
<ol start="2">
<li><p>配置插件</p>
<p><a target="_blank" rel="noopener" href="https://www.codingyang.com/2020/03/getQiniu.html#%E8%8E%B7%E5%8F%96%E5%AF%86%E9%92%A5">https://www.codingyang.com/2020/03/getQiniu.html#%E8%8E%B7%E5%8F%96%E5%AF%86%E9%92%A5</a></p>
</li>
</ol>
<p>Sm_ms,picGo</p>
<h3 id="pandoc"><a href="#pandoc" class="headerlink" title="pandoc"></a>pandoc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc -s $infile -t markdown -o $outfile --extract-media&#x3D;$filename#导出图片到目录下</span><br></pre></td></tr></table></figure>

<p>pandoc是文档转换利器。在将docx文档转为md文档过程中，如果直接输入<code>pandoc -o f.md f.docx</code>,会丢失word文档中的图片。输入<code>pandoc -o f.md f.docx ---extract-media=f </code>则不会丢失图片。</p>
<p>pandoc语法<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fd761fc43753">https://www.jianshu.com/p/fd761fc43753</a></p>
<p><strong>示例</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo $ cat word2md.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">infile=$1</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$infile</span></span></span><br><span class="line">filename=$(echo $infile | awk -F &#x27;.&#x27; &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">outfile=$&#123;filename&#125;.md</span><br><span class="line">pandoc -s $infile -t markdown -o $outfile --extract-media=$filename</span><br><span class="line">echo &quot;convert success, $outfile &quot;</span><br><span class="line"></span><br><span class="line">foo $ bash ./word2md.sh mydoc.docx </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h3><p>draw.io 绘图可以导出成 HTML，而 markdown 是支持直接嵌入 HTML 的</p>
<p>点击图形中的全屏按钮，再点击编辑，居然还可以直接修改原图的副本。厉害了！</p>
<p>具体插入的方法是，打开 draw.io 导出的 HTML<br>文件，将其中的 <body> 中的内容复制出来即可（不包含<code> &lt;body&gt;</code>标签）。<strong>github不支持解析</strong></p>
<h3 id="picGo-GitHub-上传图片"><a href="#picGo-GitHub-上传图片" class="headerlink" title="picGo+GitHub 上传图片"></a>picGo+GitHub 上传图片</h3><p>Typora批量上传图片</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zenglintao/p/12876725.html">https://www.cnblogs.com/zenglintao/p/12876725.html</a></p>
<p>图床配置</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43367829/article/details/104882071">https://blog.csdn.net/qq_43367829/article/details/104882071</a></p>
<p>注意 创建的GitHub图床默认分支为main,没有master分支，</p>
<h1 id="开发养成"><a href="#开发养成" class="headerlink" title="开发养成"></a>开发养成</h1><p>编程中最难的事：如何优雅地为程序中的变量和函数命名<br>命名不一致解决思路：<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/395223359">https://www.zhihu.com/question/395223359</a><br><a target="_blank" rel="noopener" href="https://www.douban.com/note/571297448/">https://www.douban.com/note/571297448/</a><br>(创建中间层，添加注解@)<br>工具<br><a target="_blank" rel="noopener" href="https://graphql.org/%EF%BC%8CTypeScrip">https://graphql.org/，TypeScrip</a></p>
<p>python – 解析一个.py文件,读取AST,修改它,然后回写修改后的源代码<a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-mvtnzhha-bsk.html">http://www.voidcn.com/article/p-mvtnzhha-bsk.html</a></p>
<p>统一纠正变量名<br>读取各项目ast，对每个变量计算编辑距离，编辑距离为0~len(word) 为一类<br>批量更正变量并写回去</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p>安装及配置：<a href="https://kuangyl-max.github.io/2021/11/22/clash/">clash配置 | 博客 (kuangyl-max.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.nbmao.com/archives/4463">2021年最新Clash For Windows 详细使用教程 - 笨猫博客 (nbmao.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://hello-shudong.com/auth/login">登录 — GW树洞 (hello-shudong.com)</a> ：邀请码<code>gayP</code></p>
<p><strong>为git设置代理</strong></p>
<blockquote>
<p>设置后加速git clone等命令执行速度，解决Timeout问题。</p>
<p>此处使用clash for window 设置代理，其端口为7890</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">http代理</span></span><br><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:7890&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">https代理</span></span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:7890&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">查看代理</span></span><br><span class="line">git config -l</span><br><span class="line"><span class="meta">#</span><span class="bash">取消http代理</span></span><br><span class="line"><span class="meta">#</span><span class="bash">git config --global --<span class="built_in">unset</span> http.proxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash">取消https代理</span></span><br><span class="line"><span class="meta">#</span><span class="bash">git config --global --<span class="built_in">unset</span> https.proxy</span></span><br></pre></td></tr></table></figure>

<h2 id="电脑维护"><a href="#电脑维护" class="headerlink" title="电脑维护"></a>电脑维护</h2><ul>
<li>CCleaner</li>
<li>SpaceSniffer</li>
<li>Geek</li>
<li>Snipaste</li>
</ul>
<h2 id="数据标注"><a href="#数据标注" class="headerlink" title="数据标注"></a>数据标注</h2><ol>
<li>labelImg</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/tzutalin/labelImg">https://github.com/tzutalin/labelImg</a></p>
<p>使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.环境配置</span></span><br><span class="line">brew install qt  # Install qt-5.x.x by Homebrew</span><br><span class="line">brew install libxml2</span><br><span class="line"><span class="meta">#</span><span class="bash">or using pip</span></span><br><span class="line">pip3 install pyqt5 lxml # Install qt and lxml by pip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2.配置labelimg</span></span><br><span class="line">git clone https://hub.fastgit.org/tzutalin/labelImg.git</span><br><span class="line">cd labelImg</span><br><span class="line">make qt5py3</span><br><span class="line">python3 labelImg.py</span><br><span class="line">python3 labelImg.py [IMAGE_PATH] [PRE-DEFINED CLASS FILE]</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>Yolo_mark</strong></li>
</ol>
<p><strong>Windows</strong>和<strong>Linux</strong> GUI，用于在图像中标记对象的边界框，以训练Yolo v3和v2</p>
<p><a target="_blank" rel="noopener" href="https://github.com/AlexeyAB/Yolo_mark">https://github.com/AlexeyAB/Yolo_mark</a></p>
<p>其他</p>
<p>深度学习图像标注工具汇总</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chaipp0607/article/details/79036312">https://blog.csdn.net/chaipp0607/article/details/79036312</a></p>
<p>浏览器 PDF 预览及打印（效果很棒）</p>
<p><a target="_blank" rel="noopener" href="https://www.printfriendly.com/">https://www.printfriendly.com/</a></p>
<p>Send Anywhere</p>
<p>Send Anywhere官方版是款支持多种平台的文件传输共享工具。</p>
<p>Send Anywhere最新版主打网络传输文件，支持安卓、iOS、windows、macOS、Linux以及Windows Phon。Send Anywhere几乎能可以将你所有的电子设备全部打通!你甚至在电脑上无需安装任何APP，直接通过Chrome、Firefox、Safari或IE浏览器即可与手机收发文件。</p>
<p>1、bandzip（解压 window）<br>2、ditto（复制剪贴板window）<br>3、shareX（截图window）</p>
<p><a target="_blank" rel="noopener" href="https://getsharex.com/">https://getsharex.com/</a></p>
<p>4、everthing（找文件）<br>5、uTools（百宝箱）<br>6、IDM（下载）<br>7、RST（硬盘优化）<br>8、VS Code（编辑器）<br>9、天翼云盘（网盘）<br>10、chrome（浏览器）<br>11、quicker（鼠标党助手 window,chrome插件）</p>
<p><a target="_blank" rel="noopener" href="https://getquicker.net/Download">https://getquicker.net/Download</a></p>
<p>FilePane for Mac 是一款轻量级，多功能的文件快速复制粘贴工具，功能上同之前分享过的 <a target="_blank" rel="noopener" href="https://www.macsky.net/22701.html">PopClip</a> 类似，可用于快速管理文件。它适用于系统中任何应用程序的几乎任何可选择和可拖动内容，并根据您提供的数据建议各种快速操作。您可以轻松复制/移动/创建文件和文件夹，编辑/共享/转换图像等等。</p>
<p>Chrome插件</p>
<p>① 百度药丸</p>
<p>使用更纯净的百度 1.屏蔽百度广告推广 2.阻止百度追踪 3.支持居中显示治愈偏头痛</p>
<p>②onetab</p>
<p>能把所有打开的网页/标签页一键「全部关闭」并「保存成列表」，你随后可以一个个 (或一次性全部) 恢复它们。这样不仅变相实现了释放和回收浏览器占用的内存、解决 CPU 资源占用问题、让系统和浏览器的速度恢复正常，而且还能将打开的网页全部保存下来备用。</p>
<p><strong>Session Buddy</strong>插件功能介绍</p>
<p>很多人应该都知道，Chrome 虽然也有内置的Session Manager，但是功能什么的简单。Session Buddy 扩展提供的功能为暂存标签，会自动记录已经关闭的标签，当然你可以手动点击保存，下次需要时调用。至于节省内存开销，这事还是交给 Google 来做吧。</p>
<p>当然具有类似功能的插件，我们网站之前也有介绍过一些：</p>
<blockquote>
<p>2.<a target="_blank" rel="noopener" href="http://www.cnplugins.com/fuzhu/tab-hibernation/">TAb Hibernation</a>:可以将我们目前未使用到的网页进入休眠，让这些分页暂时不占用内存，但我们需要使用时，按一下就可以唤醒，解决内存不足的问题.<br>3.<a target="_blank" rel="noopener" href="http://www.cnplugins.com/office/the-great-suspender/">The Great Suspender</a>:可以让你把不需要的标签进入睡眠模式以节省内存，保证流畅的浏览体验。不同于其他类似扩展，The Great Suspender 提供两种休眠方式： 手动休眠、或者一段时间不使用自动休眠。扩展还支持白名单，无论自动休眠还是手动休眠，白名单中的网站是不会休眠的.</p>
</blockquote>
<p>③喵喵折</p>
<p>购物助手</p>
<p>④搜图助手</p>
<p>奇妙加速器，免费<a target="_blank" rel="noopener" href="https://www.qimiao.com/">https://www.qimiao.com/</a></p>
<p>网页版文件快传</p>
<p><a target="_blank" rel="noopener" href="https://snapdrop.net/">https://snapdrop.net/</a></p>
<p>快传 ：Feem和AirDroid</p>
<p><strong>Linux远程拷贝工具(WinSCP)</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dengjin20104042056/article/details/97378487">https://blog.csdn.net/dengjin20104042056/article/details/97378487</a></p>
<h2 id="论文工具"><a href="#论文工具" class="headerlink" title="论文工具"></a>论文工具</h2><p>LaTeX新手入门以及TeXlive和TeXstudio的安装使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/zywhehe/article/details/83113214">https://blog.csdn.net/zywhehe/article/details/83113214</a><br>TeX Live 下载及安装说明(mac 和window)<br><a target="_blank" rel="noopener" href="https://www.latexstudio.net/archives/10208.html">https://www.latexstudio.net/archives/10208.html</a><br><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/">https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/</a></p>
<p>VS Code + LaTeX<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144729565">https://zhuanlan.zhihu.com/p/144729565</a></p>
<p>一般来讲，LaTeX装好后默认的编译方式是pdflatex，但是这种方式不能编译中文源码。对于中文源码，采用的是xelatex的编译方式。对于编译中文文档有两种方式，第一种：在中文源文件首行添加：% !TEX program = xelatex，如果有参考文献，可以再添加% !BIB options = “%DOCFILE%”。显然，这个操作不够智能，因此，我们第一步是，添加xelatex的编译方式(2.3节)。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wdkirchhoff/article/details/41707157">AUCTeX+Emacs 是目前我见过的能最大限度提高 LaTeX 编辑效率的编辑器 （转）_芝兰生于深谷，不以无人而不芳-CSDN博客</a></p>
<p>Mendeley－一款免费好用的文献管理软件<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28762628">https://zhuanlan.zhihu.com/p/28762628</a><br>自动插入参考文献，史上最简Endnote教程！！#论文写作+Endnote X8安装文件<a target="_blank" rel="noopener" href="http://www.xszydq.com/17326.html">http://www.xszydq.com/17326.html</a></p>
<p>翻译狗：<a target="_blank" rel="noopener" href="https://www.fanyigou.com/trans/login.html?code=6ZH3PQVY0F">登录-Word翻译,Pdf翻译,文献论文翻译-翻译狗 (fanyigou.com)</a></p>
<h3 id="论文查询"><a href="#论文查询" class="headerlink" title="论文查询"></a>论文查询</h3><ol>
<li>**<a href="https://link.zhihu.com/?target=https://scholar.google.com.hk/?hl=zh-CN">谷歌学术</a>**：谷歌大概是最友好的一个平台了，尤其是在国外的校内网中使用谷歌学术。</li>
<li>**<a href="https://link.zhihu.com/?target=https://xueshu.baidu.com/">百度学术</a>**：这大概是百度产品中，算是非常良心的一个了，不能用谷歌的话，百度顶上吧。</li>
<li>**<a href="https://link.zhihu.com/?target=http://www.cnki.net/">中国知网</a>**：知网是国内比较不错的平台，可在境外的话，会遇到IP限制，大概是超过国内许可范围了。</li>
<li>**<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24299207">Sci-Hub</a>**：这个比较有趣，大家可以配合知网来使用，从知网搜寻论文，然后在Sci-Hub中下载。但你懂的，Sci-Hub的地址经常变动，所以需要的时候直接用搜索引擎吧。</li>
<li>**<a href="https://link.zhihu.com/?target=https://lunwen.im/">喵咪论文 - 简单自由的论文下载平台</a>**：亲自试了一下，使用起来还是很方便的，但是随手测试了一下，论文查找到的概率也不是太大。</li>
<li><a href="https://link.zhihu.com/?target=http://www.ncpssd.org/index.aspx">国家哲学社会科学文献中心</a>: 如果是中文的论文，那用这个查看也还行，主要是界面比知网要人性化一些。</li>
<li><a target="_blank" rel="noopener" href="https://papers.labml.ai/papers/monthly/">https://papers.labml.ai/papers/monthly/</a></li>
<li><a target="_blank" rel="noopener" href="https://scholar.google.com.hk/schhp?hl=zh-CN">Google 学术搜索</a></li>
<li><a target="_blank" rel="noopener" href="http://www.4243.net/">大木虫学术导航 (4243.net)</a>：<font color=red>功能极其强悍</font></li>
</ol>
<p>另外就是一些不错的期刊：</p>
<ol>
<li><strong><a href="https://link.zhihu.com/?target=https://www.sciencemag.org">Science官网</a></strong></li>
<li><strong><a href="https://link.zhihu.com/?target=https://www.sciencemag.org">Science | AAAS</a></strong></li>
</ol>
<h3 id="论文撰写"><a href="#论文撰写" class="headerlink" title="论文撰写"></a>论文撰写</h3><p>officeTab：模仿WPS多个文章同时显示</p>
<p>word小恐龙： <a target="_blank" rel="noopener" href="http://gw.xkonglong.com/">http://gw.xkonglong.com/</a></p>
<p>word精灵</p>
<p>grammarly ：语法纠正</p>
<p><a target="_blank" rel="noopener" href="https://aimwriting.mtutor.engkoo.com/editor">微软爱写作</a>：在线写作，提供逻辑连接词例子，可批改评分</p>
<p><a target="_blank" rel="noopener" href="https://quillbot.com/">Paraphrasing Tool | QuillBot AI</a>：句子重构，降低查重</p>
<p><a target="_blank" rel="noopener" href="https://www.phrasebank.manchester.ac.uk/">Academic Phrasebank | The University of Manchester</a>：论文例句</p>
<p><a target="_blank" rel="noopener" href="https://www.bigan.net/check/">论文查重软件_论文检测软件_笔杆网 (bigan.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.xiegelunwen.com/#/zhllc">写个论文 - 论文降重神器，写论文更简单 (xiegelunwen.com)</a></p>
<h3 id="论文管理"><a href="#论文管理" class="headerlink" title="论文管理"></a>论文管理</h3><p><strong>Readcube</strong>：这是一个付费的管理软件，这里有一篇介绍Readcube的文章，<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/6bf14803dc99">高效率科研神器——驾驭文献洪流</a>，有需要可以继续了解一下。</p>
<p>EndNote 是SCI（Thomson Scientific 公司）的官方软件，自身具有强大的功能，<strong>是一款集文献检索、文摘及全文管理、文献共享等功能于一身的老牌软件</strong></p>
<p>Citavi有<strong>全功能免费版（支持每个项目插入不多于100篇文献）</strong>，具有<strong>强大的参考文献编辑功能，</strong>可以从各个方面实现对参考文献的编辑需求。</p>
<p>Citavi很大一个特点是<strong>支持PDF阅读功能，且可以支持多种批注格式</strong></p>
<p>Mendeley是一款Elsevier公司旗下的<strong>免费文献管理软件，</strong>所有人都可以在Mendeley上搜索到世界各地的学术文献，这些学术文件都是由用户自己上传到Mendeley“library”进行编辑管理，<strong>这款软件拥有整理组织文献、PDF标记和文件分享、网络备份的强大功能。</strong>（其余工具见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/105066833">研究生必备文献整理工具 - 知乎 (zhihu.com)</a>）</p>
<p>noteexpress：对中文支持更全面，但对英文文献不太靠谱</p>
<p>Zotero：最大特点是浏览器的抓取功能异常强大。</p>
<p><strong>总结：首推citavi</strong></p>
<h3 id="开题相关工具"><a href="#开题相关工具" class="headerlink" title="开题相关工具"></a>开题相关工具</h3><p>如果要快速了解某个领域，那需要大量阅读该领域的相关文献，才能了解到以下：</p>
<ol>
<li>这个领域的研究热点、主要研究内容、权威的学者等</li>
<li>研究存在的不足</li>
<li>对自己而言，该从哪个领域进行切入才有研究意义等</li>
</ol>
<p>这里我直接根据知乎的回答来推荐工具：</p>
<p>**<a href="https://link.zhihu.com/?target=http://cluster.ischool.drexel.edu/~cchen/citespace/download/">CiteSpace</a>**：这是一个可视化软件，可以将下载的论文进行CiteSpace分析，让你能够尽快地了解领域的发展情况。</p>
<p>**<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20902898">Histcite</a>**：这是一款非常强大的引文分析工具，可以快速绘制出某个研究领域的发展脉络，快速锁定某个研究方向的重要文献和学术大牛，还可以找到某些具有开创性成果的无指定关键词的论文。</p>
<p>**<a href="https://link.zhihu.com/?target=http://xueshu.baidu.com/u/biye?fr=kaiti301">百度开题</a>**：这里必须隆重介绍一下这个百度开题，其使用简单，效果也比较炫酷，是开题不可多得的工具。</p>
<h3 id="英文文献翻译"><a href="#英文文献翻译" class="headerlink" title="英文文献翻译"></a>英文文献翻译</h3><p>这里要推荐一个网站，叫tongtianta.site，<a href="https://link.zhihu.com/?target=http://www.tongtianta.site/">网站</a>功能很简单： 对论文进行翻译，中英文对照阅读</p>
<p><a target="_blank" rel="noopener" href="https://www.deepl.com/translator">DeepL翻译：全世界最准确的翻译</a></p>
<h2 id="中国计算机学会推荐国际学术期刊"><a href="#中国计算机学会推荐国际学术期刊" class="headerlink" title="中国计算机学会推荐国际学术期刊"></a>中国计算机学会推荐国际学术期刊</h2><p><strong>(**数据库</strong>/<strong>数据挖掘</strong>/<strong>内容检索</strong>)**</p>
<p>一、<strong>A</strong> 类 </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>刊物简称</th>
<th>刊物全称</th>
<th>出版社</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TODS</td>
<td>ACM  Transactions on Database Systems</td>
<td>ACM</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/tods/">http://dblp.uni-trier.de/db/journals/tods/</a></td>
</tr>
<tr>
<td>2</td>
<td>TOIS</td>
<td>ACM  Transactions on Information Systems</td>
<td>ACM</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/tois/">http://dblp.uni-trier.de/db/journals/tois/</a></td>
</tr>
<tr>
<td>3</td>
<td>TKDE</td>
<td>IEEE  Transactions on Knowledge and Data Engineering</td>
<td>IEEE</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/tkde/">http://dblp.uni-trier.de/db/journals/tkde/</a></td>
</tr>
<tr>
<td>4</td>
<td>VLDBJ</td>
<td>The  VLDB Journal</td>
<td>Springer</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/vldb/">http://dblp.uni-trier.de/db/journals/vldb/</a></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://icde2021.gr/accepted-papers/">https://icde2021.gr/accepted-papers/</a><br><a target="_blank" rel="noopener" href="http://vldb.org/pvldb/vol14-volume-info/">http://vldb.org/pvldb/vol14-volume-info/</a></p>
<p><a target="_blank" rel="noopener" href="https://kdd.org/kdd2021/accepted-papers/index">https://kdd.org/kdd2021/accepted-papers/index</a><br><a target="_blank" rel="noopener" href="https://sigir.org/sigir2021/accepted-papers/">https://sigir.org/sigir2021/accepted-papers/</a></p>
<p>二、<strong>B</strong> 类 </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>刊物简称</th>
<th>刊物全称</th>
<th>出版社</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TKDD</td>
<td>ACM  Transactions on Knowledge   Discovery  from Data</td>
<td>ACM</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/tkdd/">http://dblp.uni-trier.de/db/journals/tkdd/</a></td>
</tr>
<tr>
<td>2</td>
<td>TWEB</td>
<td>ACM  Transactions on the Web</td>
<td>ACM</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/tweb/">http://dblp.uni-trier.de/db/journals/tweb/</a></td>
</tr>
<tr>
<td>3</td>
<td>AEI</td>
<td>Advanced  Engineering Informatics</td>
<td>Elsevier</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/aei/">http://dblp.uni-trier.de/db/journals/aei/</a></td>
</tr>
<tr>
<td>4</td>
<td>DKE</td>
<td>Data  and Knowledge Engineering</td>
<td>Elsevier</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/dke/">http://dblp.uni-trier.de/db/journals/dke/</a></td>
</tr>
<tr>
<td>5</td>
<td>DMKD</td>
<td>Data Mining and Knowledge Discovery</td>
<td>Springer</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/datamine/">http://dblp.uni-trier.de/db/journals/datamine/</a></td>
</tr>
<tr>
<td>6</td>
<td>EJIS</td>
<td>European  Journal of Information   Systems</td>
<td>Springer</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/ejis/">http://dblp.uni-trier.de/db/journals/ejis/</a></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>GeoInformatica</td>
<td>Springer</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/geoinformatica/">http://dblp.uni-trier.de/db/journals/geoinformatica/</a></td>
</tr>
<tr>
<td>8</td>
<td>IPM</td>
<td>Information  Processing and Management</td>
<td>Elsevier</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/ipm/">http://dblp.uni-trier.de/db/journals/ipm/</a></td>
</tr>
<tr>
<td>9</td>
<td></td>
<td>Information  Sciences</td>
<td>Elsevier</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/isci/">http://dblp.uni-trier.de/db/journals/isci/</a></td>
</tr>
<tr>
<td>10</td>
<td><a target="_blank" rel="noopener" href="http://www.dimva.org/">IS</a><a target="_blank" rel="noopener" href="http://www.dimva.org/"> </a></td>
<td>Information  Systems</td>
<td><a target="_blank" rel="noopener" href="http://www.gi-fg-sidar.de/">Elsevier</a><a target="_blank" rel="noopener" href="http://www.gi-fg-sidar.de/"> </a></td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/is/">http://dblp.uni-trier.de/db/journals/is/</a></td>
</tr>
<tr>
<td>11</td>
<td>JASIST</td>
<td>Journal  of the American Society for Information Science and Technology</td>
<td>American  Society for   Information  Science and Technology</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/jasis/">http://dblp.uni-trier.de/db/journals/jasis/</a></td>
</tr>
<tr>
<td>12</td>
<td>JWS</td>
<td>Journal  of Web Semantics</td>
<td>Elsevier</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/ws/">http://dblp.uni-trier.de/db/journals/ws/</a></td>
</tr>
<tr>
<td>13</td>
<td>KAIS</td>
<td>Knowledge  and Information Systems</td>
<td>Springer</td>
<td><a target="_blank" rel="noopener" href="http://dblp.uni-trier.de/db/journals/kais/">http://dblp.uni-trier.de/db/journals/kais/</a></td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22867411">https://www.zhihu.com/question/22867411</a></p>
<ul>
<li><p>Dash</p>
<p>官网地址 ：<a target="_blank" rel="noopener" href="https://kapeli.com/dash">https://kapeli.com/dash</a><br>Dash for mac是使用与Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架。（190元）</p>
</li>
<li><p>mathpix</p>
<p><a target="_blank" rel="noopener" href="https://mathpix.com/">https://mathpix.com/</a></p>
<p>图片转LaTeX公式，适用于Markdown,word等文档</p>
</li>
<li><p>tmux/tmuxp。比screen好用，可以用来分屏，托管进程等，服务器端必备神器，ubuntu下基本就不用使用terminator之类的分屏工具了。最近看youtube视频还发现有人在服务器上使用tmux和vim结对编程，两个人同时attach到一个session里，基情四射。</p>
</li>
<li><p>wemux: tmux 共享，<a href="https://link.zhihu.com/?target=https://github.com/zolrath/wemux">https://github.com/zolrath/wemux</a></p>
</li>
<li><p>sshfs: 本地挂在服务器文件夹</p>
</li>
<li><p>tmate: <a href="https://link.zhihu.com/?target=https://tmate.io/">https://tmate.io</a> 终端共享工具，结对编程。很多现代化编辑器 vscode, atom 提供结对编程的插件。</p>
</li>
<li><p>asciinema: 终端会话记录工具。<a href="https://link.zhihu.com/?target=https://asciinema.org/">https://asciinema.org/</a></p>
</li>
<li><p>oh-my-zsh。替代原生的bash shell，提供了好多方便的特性和漂亮主题，支持插件。linux/mac下vim+tmux+zsh简直是绝配，甚至可以直接在服务器上方便地撸代码，跟本地开发体验没区别。</p>
</li>
<li><p>item2(mac)。替代原生的终端。<a href="https://link.zhihu.com/?target=https://medium.com/@RyanDavidson/make-your-terminal-more-colourful-and-productive-with-iterm2-and-zsh-11b91607b98c">https://medium.com/@RyanDavidson/make-your-terminal-more-colourful-and-productive-with-iterm2-and-zsh-11b91607b98c</a></p>
</li>
<li><p>brew(mac)。类似ubuntu下的apt-get，可以方便安转各种软件和工具。</p>
</li>
<li><p>Alfred(mac): mac 下一款功能强大的工具，不过我一般只用它快速打开软件。可以用 python 编写一些自己的 workflow 提高效率(<a href="https://link.zhihu.com/?target=https://github.com/deanishe/alfred-workflow">https://github.com/deanishe/alfred-workflow</a>)，比如把时间戳转成日期等。 <a href="https://link.zhihu.com/?target=https://github.com/derimagia/awesome-alfred-workflows">https://github.com/derimagia/awesome-alfred-workflows</a></p>
</li>
<li><p>Dash(mac,全英): 强悍的文档查询工具。支持非常多编程语言和框架</p>
</li>
<li><p>devdocs.io: 文档查询工具</p>
</li>
<li><p>Zeal——好用的离线 API 文档大全！(支持window，Linux，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/souldee/p/9523497.html%EF%BC%8Cfeed%EF%BC%9A[Zeal">https://www.cnblogs.com/souldee/p/9523497.html，feed：[Zeal</a> User Contributions &amp; Cheat Sheets](<a target="_blank" rel="noopener" href="https://zealusercontributions.vercel.app/">https://zealusercontributions.vercel.app/</a>))</p>
</li>
<li><p>Karabiner-Elements(mac): 改键工具 <a href="https://link.zhihu.com/?target=https://github.com/tekezo/Karabiner-Elements">https://github.com/tekezo/Karabiner-Elements</a></p>
</li>
<li><p>autojump。方便在命令行里来回跳转目录。</p>
</li>
<li><p>gitx(mac):方便查看代码提交历史，便于了解整个代码仓库是怎样一步步构建的。<a href="https://link.zhihu.com/?target=http://gitx.frim.nl/user_manual.html">http://gitx.frim.nl/user_manual.html</a></p>
</li>
<li><p>tig: text-mode interface for git. 喜欢命令行的可以尝试下。 <a href="https://link.zhihu.com/?target=https://github.com/jonas/tig">https://github.com/jonas/tig</a></p>
</li>
<li><p>tldr: 更好的man手册</p>
</li>
<li><p>YouCompleteMe: vim 代码补全<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44638957/article/details/91985270">https://blog.csdn.net/weixin_44638957/article/details/91985270</a></p>
</li>
<li><p>EditorConfig: <a href="https://link.zhihu.com/?target=http://editorconfig.org/">http://editorconfig.org/</a> 用来统一编辑器配置。如果成员用不同的操作系统和编辑器，建议使用。尤其是对于 python 这种使用缩进的语言</p>
</li>
<li><p>mac-setup: <a href="https://link.zhihu.com/?target=https://github.com/sb2nov/mac-setup">https://github.com/sb2nov/mac-setup</a> mac 下各种编程语言开发环境配置指引</p>
</li>
<li><p>pdf2go网址：<a target="_blank" rel="noopener" href="https://www.pdf2go.com/zh">https://www.pdf2go.com/zh</a> 免费PDF工具</p>
</li>
<li><p>ilovePDF网址：<a target="_blank" rel="noopener" href="https://www.ilovepdf.com/zh-cn">https://www.ilovepdf.com/zh-cn</a> 免费PDF工具</p>
</li>
<li><p>temp-mail网址：<a target="_blank" rel="noopener" href="https://temp-mail.org/">https://temp-mail.org/</a> 临时邮箱，避免垃圾广告</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/jlevy/the-art-of-command-line">jlevy/the-art-of-command-line: Master the command line, in one page (github.com)</a></p>
</li>
</ul>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="课程-amp-资料"><a href="#课程-amp-资料" class="headerlink" title="课程&amp;资料"></a>课程&amp;资料</h2><p>【链接】最值得看的十大机器学习公开课<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yushupan/article/details/78582630">https://blog.csdn.net/yushupan/article/details/78582630</a></p>
<p>【链接】计算机视觉有哪些比较好的公开课？补充计<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/35831904">https://www.zhihu.com/question/35831904</a></p>
<p>机器学习与生成对抗网络<a target="_blank" rel="noopener" href="https://my.oschina.net/u/4579551/blog/4350931">https://my.oschina.net/u/4579551/blog/4350931</a></p>
<p>分类机器学习中，某一标签占比太大（标签稀疏），如何学习？<a target="_blank" rel="noopener" href="https://my.oschina.net/u/4579551/blog/4750226">https://my.oschina.net/u/4579551/blog/4750226</a></p>
<p>使用深度学习的图像分类-Koko.PDF<br><a target="_blank" rel="noopener" href="https://max.book118.com/html/2018/1016/7123041051001153.shtm">https://max.book118.com/html/2018/1016/7123041051001153.shtm</a></p>
<p>pandas官方中文文档-草鸡详细！！！！<a target="_blank" rel="noopener" href="https://www.pypandas.cn/deep/basics/image_classification.html#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D">https://www.pypandas.cn/deep/basics/image_classification.html#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D</a></p>
<p>汇总】CV 图像分类常见的 36 个模型<br><a target="_blank" rel="noopener" href="https://my.oschina.net/u/4579551/blog/4701954">https://my.oschina.net/u/4579551/blog/4701954</a></p>
<p>超详细！！！<br><a target="_blank" rel="noopener" href="http://www.feiguyunai.com/">http://www.feiguyunai.com/</a></p>
<p>Jupyter Notebook介绍、安装及使用教程<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/91365f343585">https://www.jianshu.com/p/91365f343585</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013709332/article/details/105029123/">https://blog.csdn.net/u013709332/article/details/105029123/</a></p>
<p>Python深度学习 基于TensorFlow 在线版<br><a target="_blank" rel="noopener" href="http://www.feiguyunai.com/index.php/2018/05/26/python-ml-tf-01/">http://www.feiguyunai.com/index.php/2018/05/26/python-ml-tf-01/</a></p>
<p>机器学习 几百篇文章<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/GarfieldEr007/category_5619819.html">https://blog.csdn.net/GarfieldEr007/category_5619819.html</a></p>
<p>零基础学习-深度学习核心-梯度下降与最优化<br><a target="_blank" rel="noopener" href="http://www.feiguyunai.com/index.php/2017/11/08/pythonai-dl-grade01/">http://www.feiguyunai.com/index.php/2017/11/08/pythonai-dl-grade01/</a></p>
<p>给大家再分享几个好用的知识文章检索工具哦：[OK]<br>1、<a target="_blank" rel="noopener" href="https://www.cn-ki.net/">https://www.cn-ki.net/</a> 仿知网<br>2、<a target="_blank" rel="noopener" href="https://www.jiumodiary.com/">https://www.jiumodiary.com/</a> 鸠摩搜索</p>
<p>实在不行就用这个狗屁不通文章生成器[doge]<br><a target="_blank" rel="noopener" href="https://suulnnka.github.io/BullshitGenerator/index.html">https://suulnnka.github.io/BullshitGenerator/index.html</a></p>
<p><strong>神经网络与深度学习</strong></p>
<p><a target="_blank" rel="noopener" href="https://nndl.github.io/">https://nndl.github.io/</a></p>
<h1 id="C-入门教程"><a href="#C-入门教程" class="headerlink" title="C++入门教程"></a>C++入门教程</h1><p><a target="_blank" rel="noopener" href="http://www.weixueyuan.net/cpp/rumen//e">http://www.weixueyuan.net/cpp/rumen//e</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
<div>
    
 </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kuangyl-max.github.io/2020/10/28/youdao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="小邝">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/28/youdao/" class="post-title-link" itemprop="url">有道API调用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-28 13:45:40" itemprop="dateCreated datePublished" datetime="2020-10-28T13:45:40+08:00">2020-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-16 16:31:53" itemprop="dateModified" datetime="2021-11-16T16:31:53+08:00">2021-11-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/API/" itemprop="url" rel="index"><span itemprop="name">API</span></a>
                </span>
            </span>

          
            <span id="/2020/10/28/youdao/" class="post-meta-item leancloud_visitors" data-flag-title="有道API调用" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
	<span>℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/10/28/youdao/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/10/28/youdao/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="有道API调用"><a href="#有道API调用" class="headerlink" title="有道API调用"></a>有道API调用</h1><p>在有道智云&gt;产品服务&gt;自然语言翻译服务&gt;文本翻译&gt;技术文档&gt;API接入指南 查看相关信息，根据有道智云提供的demo实现一个公共API调用的实例。注意，API接入指南右侧可快速导航到常用语言Demo中的JS demo</p>
<h2 id="有道API调用说明"><a href="#有道API调用说明" class="headerlink" title="有道API调用说明"></a>有道API调用说明</h2><p>文本翻译API接口提供有道的翻译服务，包含了中英翻译和小语种翻译功能。只需要通过调用文本翻译API，传入待翻译的内容，并指定要翻译的源语言（支持源语言语种自动检测）和目标语言种类，就可以得到相应的翻译结果。</p>
<ul>
<li>调用API需要向接口发送以下字段来访问服务<br><img src="https://img-blog.csdnimg.cn/20200924120622936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3MTk2MQ==,size_16,color_FFFFFF,t_70#pic_left" alt="在这里插入图片描述"><br>代码实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;有道智云&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;jqueryvalidation.org&#x2F;files&#x2F;demo&#x2F;site-demos.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;text-align: center;border: 1px solid;width: 20%;padding: 10px;margin: 0 auto;&quot;&gt;</span><br><span class="line">        &lt;h3&gt;有道翻译&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;p&gt;&lt;label&gt;输入:&lt;&#x2F;label&gt;</span><br><span class="line">            &lt;input id&#x3D;&quot;in&quot; type&#x3D;&quot;text&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;&lt;label&gt;from:&lt;&#x2F;label&gt;</span><br><span class="line">            &lt;input id&#x3D;&quot;from&quot; type&#x3D;&quot;text&quot; value&#x3D;&#39;zh-CHS&#39; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;&lt;label&gt;to:&lt;&#x2F;label&gt;</span><br><span class="line">            &lt;input id&#x3D;&quot;to&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;en&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;button&gt;确定&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            提示：zh-CHS(中文) || ja(日语) || en(英文) || fr(法语) ...</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;padding-top: 20px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;text-align: center; border: 1px solid;width: 50%;margin: 0 auto;&quot;&gt;</span><br><span class="line">        &lt;h&gt;翻译结果&lt;&#x2F;h&gt;</span><br><span class="line">        &lt;p id&#x3D;&quot;out&quot; border&#x3D;&quot;1&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;shared.ydstatic.com&#x2F;js&#x2F;jquery&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;blueimp-md5&#x2F;2.10.0&#x2F;js&#x2F;md5.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;js-sha256&#x2F;0.9.0&#x2F;sha256.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">        var appKey &#x3D; &#39;your appKey&#39;;</span><br><span class="line">        var key &#x3D; &#39;your key&#39;;&#x2F;&#x2F;注意：暴露appSecret，有被盗用造成损失的风险</span><br><span class="line">        &#x2F;&#x2F;     当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。</span><br><span class="line">        &#x2F;&#x2F; 由于该事件在文档就绪后发生，因此把所有其他的 jQuery 事件和函数置于该事件中是非常好的做法。</span><br><span class="line">        &#x2F;&#x2F; ready() 函数规定当 ready 事件发生时执行的代码。</span><br><span class="line">        $(document).ready(function () &#123;</span><br><span class="line">            $(&quot;button&quot;).click(function () &#123;</span><br><span class="line">                var salt &#x3D; (new Date).getTime();</span><br><span class="line">                var curTime &#x3D; Math.round(new Date().getTime() &#x2F; 1000);</span><br><span class="line">                var query &#x3D; $(&quot;#in&quot;).val()</span><br><span class="line">                var str1 &#x3D; appKey + truncate(query) + salt + curTime + key;</span><br><span class="line">                console.log(str1);</span><br><span class="line">                var sign &#x3D; sha256(str1);</span><br><span class="line">                $.ajax(&#123;&#x2F;&#x2F;ajax() 方法通过 HTTP 请求加载远程数据</span><br><span class="line">                    url: &#39;http:&#x2F;&#x2F;openapi.youdao.com&#x2F;api&#39;,</span><br><span class="line">                    type: &#39;post&#39;,&#x2F;&#x2F;请求方式（post或get）默认为get</span><br><span class="line">                    dataType: &#39;jsonp&#39;,&#x2F;&#x2F;JSONP格式</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        q: query,</span><br><span class="line">                        appKey: appKey,</span><br><span class="line">                        salt: salt,</span><br><span class="line">                        from: $(&quot;#from&quot;).val(),</span><br><span class="line">                        to: $(&quot;#to&quot;).val(),</span><br><span class="line">                        sign: sign,</span><br><span class="line">                        signType: &quot;v3&quot;,</span><br><span class="line">                        curtime: curTime,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    success: function (data) &#123;&#x2F;&#x2F;请求成功后调用的回调函数</span><br><span class="line">                        console.log(data);&#x2F;&#x2F;json</span><br><span class="line">                        var out &#x3D; JSON.stringify(data.web);</span><br><span class="line">                        console.log(out);</span><br><span class="line">                        $(&quot;#out&quot;).text(out);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;); </span><br><span class="line">        function truncate(q) &#123;</span><br><span class="line">            var len &#x3D; q.length;</span><br><span class="line">            if (len &lt;&#x3D; 20) return q;</span><br><span class="line">            return q.substring(0, 10) + len + q.substring(len - 10, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://img-blog.csdnimg.cn/20200924120849188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTA3MTk2MQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
<div>
    
 </div>
  
  
  


  





          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小邝"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">小邝</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kuangyl-max" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kuangyl-max" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
</div>
<div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"VldYGbfDFwTUlOKd9hViAlUO-gzGzoHsz","app_key":"6N6QvtWLrytbGARKbo2g3tMS","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'VldYGbfDFwTUlOKd9hViAlUO-gzGzoHsz',
      appKey     : '6N6QvtWLrytbGARKbo2g3tMS',
      placeholder: "无需登录即可评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>



<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
